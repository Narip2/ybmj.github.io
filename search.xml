<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hdu6158 The Designer]]></title>
    <url>%2F2019%2F11%2F28%2Fhdu6158-The-Designer%2F</url>
    <content type="text"><![CDATA[题目链接 题意有点难描述，还是直接阅读原题吧。 分析设两圆切点为 $O$。可以默认其为坐标原点。两个圆反演之后就是两条直线。 图片来源 然后接下来只要计算每个小圆的半径即可。 对于 $N$ 很大的情况，这里的做法是当每个小圆的面积趋近于 $eps$ 时就停止计算。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;using db = double;const db eps = 1e-14;const db PI = acos(-1.0);inline int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;inline int cmp(db a, db b) &#123; return sign(a - b); &#125;struct Point &#123; db x, y; Point(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; bool operator&lt;(const Point&amp; rhs) const &#123; int s = cmp(x, rhs.x); if (s) return s == -1; return cmp(y, rhs.y) == -1; &#125; bool operator==(const Point&amp; rhs) const &#123; return cmp(x, rhs.x) == 0 &amp;&amp; cmp(y, rhs.y) == 0; &#125; void print() &#123; cerr &lt;&lt; "Point : " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; &#125;&#125;;typedef Point Vector;Vector operator+(Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator-(Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator*(Vector A, db p) &#123; return Vector(A.x * p, A.y * p); &#125;Vector operator/(Vector A, db p) &#123; return Vector(A.x / p, A.y / p); &#125;db Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y; &#125;db Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125;db Length2(Vector A) &#123; return Dot(A, A); &#125;db Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;struct Line &#123; Point u; Vector v; Line() &#123;&#125; Line(Point u, Vector v) : u(u), v(v) &#123;&#125;&#125;;struct Circle &#123; Point c; db r; Circle() : c(Point(0, 0)), r(0) &#123;&#125; Circle(Point c, db r = 0) : c(c), r(r) &#123;&#125; // 根据角度a，返回圆上一点 Point point(db a) &#123; return Point(c.x + cos(a) * r, c.y + sin(a) * r); &#125;&#125;;// 经过a点，与向量v垂直的垂线Line Perpendicular(Point a, Vector v) &#123; if (sign(v.y) == 0) return &#123;a, Point(0, 1)&#125;; else &#123; Point u = Point(0, v.x * a.x / v.y + a.y); return &#123;a, u - a&#125;; &#125;&#125;// 过O的圆，反演后得到的直线Line Inversion_C2L(Point O, db R, Circle A) &#123; Line line = Line(O, A.c - O); db rate = R * R / (2 * A.r); Point b = line.v * (rate / Length(line.v)) + O; return Perpendicular(b, A.c - O);&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; db r1, r2; int n; scanf("%lf%lf%d", &amp;r1, &amp;r2, &amp;n); if (r1 &gt; r2) swap(r1, r2); db R = 3 * r2 + 5; Circle O(Point(0, 0), R); Circle A(Point(r1, 0), r1), B(Point(r2, 0), r2); Line left = Inversion_C2L(O.c, R, B); Line right = Inversion_C2L(O.c, R, A); db r = (right.u.x - left.u.x) / 2; db mid = (left.u.x + right.u.x) / 2; db a = mid * mid, b = 0; db rr = R * R * r / (a - r * r); db ans = PI * rr * rr; for (int i = 2; i &lt;= n; i++) &#123; if (!(i &amp; 1)) &#123; b += 2 * r; a = mid * mid + b * b; rr = R * R * r / (a - r * r); &#125; db area = PI * rr * rr; ans += area; if (sign(area) &lt; 1) break; &#125; printf("%.5f\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>反演变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu4773 Problem of Apollonius]]></title>
    <url>%2F2019%2F11%2F28%2Fhdu4773-Problem-of-Apollonius%2F</url>
    <content type="text"><![CDATA[题目链接 题意给定两个相离的圆以及一个点 $P$，求有多少个圆符合过 $P$ 点且和两圆外切。输出这些圆的圆心和半径。保证 $P$ 不在两圆内。 分析假设符合条件的圆为 $D$，那么将 $D$ 对 $P$ 反演之后会得到一条直线。将两圆对 $P$ 反演之后得到两个圆。而这条直线与每个圆都只有一个交点（相切），因此这条直线就是两圆的公切线。 因为题目要求必须是外切，因此我们可以通过判断三个圆的圆心与直线的相对位置来判断是否是外切。 两个反演圆的圆心和 $P$ 必须在直线的同一侧才是外切，这个可以画图看一下。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;using db = double;const db eps = 1e-8; //精度系数const db PI = acos(-1.0); //πconst int N = 4;inline int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;inline int cmp(db a, db b) &#123; return sign(a - b); &#125;struct Point &#123; db x, y; Point(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; const bool operator&lt;(Point A) const &#123; return x == A.x ? y &lt; A.y : x &lt; A.x; &#125;&#125;;typedef Point Vector;Vector operator+(Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator-(Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator*(Vector A, db p) &#123; return Vector(A.x * p, A.y * p); &#125;Vector operator/(Vector A, db p) &#123; return Vector(A.x / p, A.y / p); &#125;db Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y; &#125; //向量点乘db Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125; //向量长度db Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125; //向量叉乘struct Line &#123; Point u; Vector v; Line() &#123;&#125; Line(Point u, Vector v) : u(u), v(v) &#123;&#125; void unit() &#123; db len = Length(v); v.x /= len, v.y /= len; &#125;&#125;;//点在直线上投影Point GetLineProjection(Point P, Line line) &#123; return line.u + line.v * (Dot(line.v, P - line.u) / Dot(line.v, line.v));&#125;struct Circle &#123; Point c; db r; Circle() : c(Point(0, 0)), r(0) &#123;&#125; Circle(Point c, db r = 0) : c(c), r(r) &#123;&#125; Point point(db a) &#123; return Point(c.x + cos(a) * r, c.y + sin(a) * r); &#125;&#125;;// a[i] 和 b[i] 分别是第i条切线在圆A和圆B上的切点int getTangents(Circle A, Circle B, Point* a, Point* b) &#123; int cnt = 0; if (A.r &lt; B.r) &#123; swap(A, B); swap(a, b); &#125; db d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); db rdiff = A.r - B.r; db rsum = A.r + B.r; if (sign(d2 - rdiff * rdiff) &lt; 0) return 0; //内含 db base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (sign(d2) == 0 &amp;&amp; sign(A.r - B.r) == 0) return -1; //无限多条切线 if (sign(d2 - rdiff * rdiff) == 0) &#123; //内切，一条切线 a[cnt] = A.point(base); b[cnt] = B.point(base); ++cnt; return 1; &#125; //有外公切线 db ang = acos(rdiff / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); ++cnt; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); ++cnt; if (sign(d2 - rsum * rsum) == 0) &#123; //一条内公切线 a[cnt] = A.point(base); b[cnt] = B.point(PI + base); ++cnt; &#125; else if (sign(d2 - rsum * rsum) &gt; 0) &#123; //两条内公切线 db ang = acos(rsum / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); ++cnt; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); ++cnt; &#125; return cnt;&#125; // 两圆公切线 返回切线的条数，-1表示无穷多条切线// 不过圆心O的圆A，反演后得到的圆Circle Inversion_C2C(Point O, db R, Circle A) &#123; db oa = Length(A.c - O); db br = R * R * A.r / (oa * oa - A.r * A.r); db ob = oa * br / A.r; db bx = O.x + (A.c.x - O.x) * ob / oa; db by = O.y + (A.c.y - O.y) * ob / oa; return Circle(Point(bx, by), br);&#125;Circle Inversion_L2C(Point O, db R, Line line) &#123; Point p = GetLineProjection(O, line); db d = Length(O - p); db br = R * R / (2 * d); Vector bv = (p - O) / d * br; return Circle(O + bv, br);&#125;bool theSameSideOfLine(Point A, Point B, Line line) &#123; return sign(Cross(A - line.u, line.v)) * sign(Cross(B - line.u, line.v)) &gt; 0;&#125; // 返回 true 如果 A B 两点在直线同侧int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; Circle A, B; Point P; scanf("%lf%lf%lf", &amp;A.c.x, &amp;A.c.y, &amp;A.r); scanf("%lf%lf%lf", &amp;B.c.x, &amp;B.c.y, &amp;B.r); scanf("%lf%lf", &amp;P.x, &amp;P.y); Circle NA = Inversion_C2C(P, 10, A); Circle NB = Inversion_C2C(P, 10, B); Point LA[N], LB[N]; Circle ansC[N]; int q = getTangents(NA, NB, LA, LB), ans = 0; for (int i = 0; i &lt; q; ++i) if (theSameSideOfLine(NA.c, NB.c, Line(LA[i], LB[i] - LA[i]))) &#123; if (!theSameSideOfLine(P, NA.c, Line(LA[i], LB[i] - LA[i]))) continue; ansC[ans++] = Inversion_L2C(P, 10, Line(LA[i], LB[i] - LA[i])); &#125; printf("%d\n", ans); for (int i = 0; i &lt; ans; ++i) &#123; printf("%.8f %.8f %.8f\n", ansC[i].c.x, ansC[i].c.y, ansC[i].r); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>反演变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6097 Mindis]]></title>
    <url>%2F2019%2F11%2F28%2Fhdu6097-Mindis%2F</url>
    <content type="text"><![CDATA[题目链接 题意 The center coordinate of the circle C is O, the coordinate of O is (0,0) , and the radius is r.P and Q are two points not outside the circle, and PO = QO.You need to find a point D on the circle, which makes PD+QD minimum.Output minimum distance sum. 分析设P’ 为P相对于O的反演点。我们可以发现 $\Delta OPD \sim \Delta ODP’$。因此我们可以用 $DP’ = DP \times k$ 其中 $k$ 为相似比。 因此我们的问题变成了在圆上找一点 $D$，使得 $DP’ + DQ’$ 最小。如果直线 $P’Q’$ （$P’$ 和 $Q’$ 一定不在圆内）与圆有交点，那么 $D$ 就为交点。不然的话 $D$ 就为中垂线和圆的交点。 需要注意的是 $P’, Q’$ 和 $O$ 重合的情况，此时是无法反演的。 还有 $P = Q$ 的情况也要注意。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;using db = double;const db eps = 1e-9;const db PI = acos(-1.0);inline int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;inline int cmp(db a, db b) &#123; return sign(a - b); &#125;struct Point &#123; db x, y; Point(db x = 0, db y = 0) : x(x), y(y) &#123;&#125; bool operator&lt;(const Point&amp; rhs) const &#123; int s = cmp(x, rhs.x); if (s) return s == -1; return cmp(y, rhs.y) == -1; &#125; bool operator==(const Point&amp; rhs) const &#123; return cmp(x, rhs.x) == 0 &amp;&amp; cmp(y, rhs.y) == 0; &#125; void print() &#123; cerr &lt;&lt; "Point : " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; &#125;&#125;;typedef Point Vector;Vector operator+(Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator-(Vector A, Vector B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator*(Vector A, db p) &#123; return Vector(A.x * p, A.y * p); &#125;Vector operator/(Vector A, db p) &#123; return Vector(A.x / p, A.y / p); &#125;db Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y; &#125;db Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125;db Length2(Vector A) &#123; return Dot(A, A); &#125;db Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;Vector unit(Vector A) &#123; db len = Length(A); return A / len;&#125;struct Circle &#123; Point c; db r; Circle() : c(Point(0, 0)), r(0) &#123;&#125; Circle(Point c, db r = 0) : c(c), r(r) &#123;&#125; // 根据角度a，返回圆上一点 Point point(db a) &#123; return Point(c.x + cos(a) * r, c.y + sin(a) * r); &#125;&#125;;struct Line &#123; Point u; Vector v; Line() &#123;&#125; Line(Point u, Vector v) : u(u), v(v) &#123;&#125;&#125;;//点在直线上投影Point GetLineProjection(Point P, Line line) &#123; return line.u + line.v * (Dot(line.v, P - line.u) / Dot(line.v, line.v));&#125;Point Inversion_P2P(Point O, db R, Point A) &#123; if (A == O) return A; // 因为本题的特殊性，可以这么写s Vector v = A - O; db len = Length(v); db ob = R * R / len; return O + v * (ob / len);&#125;vector&lt;Point&gt; CircleXLine(Circle O, Line l) &#123; Point k = GetLineProjection(O.c, l); db d = O.r * O.r - Length2(k - O.c); if (sign(d) == -1) return &#123;&#125;; if (sign(d) == 0) return &#123;k&#125;; Point del = unit(l.v) * sqrt(d); return &#123;k - del, k + del&#125;;&#125;// 经过a点，与向量v垂直的垂线Line Perpendicular(Point a, Vector v) &#123; if (sign(v.y) == 0) return &#123;a, Point(0, 1)&#125;; else &#123; Point u = Point(0, v.x * a.x / v.y + a.y); return &#123;a, u - a&#125;; &#125;&#125;// 垂直平分线Line PerpendicularBisector(Point a, Point b) &#123; Point m = (a + b) / 2; return Perpendicular(m, b - a);&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; db r; Point p, q; scanf("%lf%lf%lf%lf%lf", &amp;r, &amp;p.x, &amp;p.y, &amp;q.x, &amp;q.y); if (p == q) &#123; printf("%.10f\n", 2 * (r - Length(p))); continue; &#125; Circle O(Point(0, 0), r); Point pp = Inversion_P2P(O.c, r, p); Point qq = Inversion_P2P(O.c, r, q); vector&lt;Point&gt; ps = CircleXLine(O, &#123;pp, qq - pp&#125;); db ans = 1e9; if (ps.size()) &#123; ans = Length(ps[0] - p) + Length(ps[0] - q); &#125; else &#123; Line l = PerpendicularBisector(pp, qq); ps = CircleXLine(O, l); for (auto&amp; u : ps) ans = min(ans, Length(u - p) + Length(u - q)); &#125; printf("%.8f\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>反演变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj4025 二分图]]></title>
    <url>%2F2019%2F11%2F14%2Fbzoj4025-%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[题目链接 题意$n$ 个节点的无向图，有 $m$ 条边，每条边都有一个出现时间和消失时间。要回答出每个时刻该图是否是二分图。 $n \leq 1e5, m \leq 2e5, T \leq 1e5$ 分析首先每个时刻有哪些边这个是可以通过线段树维护的，类似线段树分治的做法。 接下来就是遍历整颗线段树，进入某个节点的时候加边，退出某个节点的时候删边。 接下来考虑对于一个边集，如何知道其是否构成二分图，还要支持加边和删边的操作。 判断是否是二分图的标准是奇环是否存在。 考虑维护一棵生成树，如果加了一条边之后出现了偶环，那么应该删去环中最早应该删去的边（线段树上加边和删边的顺序正好满足这个性质）。 如果加了一条边之后出现了奇环，那么表示该节点所覆盖的时刻都不是二分图，这里可以剪枝。 最后回溯的时候把之前加的边删掉。 用可撤销并查集就可以做到。维护每个点到根的距离的奇偶性，需要注意的是并查集的形态和实际树的形态是不同的：比如连接 $u,v$ 两条边，假设他们的根是 $x,y$。那么 $dis(x,y)$ 的距离应该是 $dis(u,x) ^ dis(v,y) ^ 1$，而不是 $1$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define Lson l, m, lson#define Rson m + 1, r, rsontypedef pair&lt;int, int&gt; pii;const int maxn = 1e5 + 5;vector&lt;pii&gt; seg[maxn &lt;&lt; 2];struct UFS &#123; int par[maxn], h[maxn], top; bool dis[maxn]; struct Node &#123; int x, y, fa, h; bool dis; Node(int x = 0, int y = 0, int fa = 0, int h = 0, bool dis = 0) : x(x), y(y), fa(fa), h(h), dis(dis) &#123;&#125; &#125; stk[maxn]; void init(int n) &#123; top = 0; for (int i = 1; i &lt;= n; i++) par[i] = i, h[i] = 1, dis[i] = 0; &#125; int find(int x) &#123; return x == par[x] ? x : find(par[x]); &#125; int dist(int x) &#123; return x == par[x] ? dis[x] : dist(par[x]) ^ dis[x]; &#125; void merge(int u, int v) &#123; int x = find(u), y = find(v); if (h[x] &gt; h[y]) swap(x, y); stk[top++] = Node(x, y, par[x], h[y], dis[x]); if (h[x] == h[y]) h[y]++; par[x] = y; dis[x] = dist(u) ^ dist(v) ^ 1; &#125; void undo(int k) &#123; for (int i = 0; i &lt; k; i++) &#123; Node it = stk[--top]; par[it.x] = it.fa; h[it.y] = it.h; dis[it.x] = it.dis; &#125; &#125;&#125; ufs;bool ans[maxn];void update(int l, int r, int rt, int L, int R, int u, int v) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].push_back(make_pair(u, v)); return; &#125; int m = l + r &gt;&gt; 1; if (L &lt;= m) update(Lson, L, R, u, v); if (m + 1 &lt;= R) update(Rson, L, R, u, v);&#125;void dfs(int l, int r, int rt) &#123; int cnt = 0, flag = 1; for (int i = 0; i &lt; seg[rt].size(); i++) &#123; pii e = seg[rt][i]; int x = ufs.find(e.first), y = ufs.find(e.second); if (x == y &amp;&amp; !(ufs.dist(e.first) ^ ufs.dist(e.second))) &#123; flag = 0; break; &#125; else if (x != y) &#123; cnt++; ufs.merge(e.first, e.second); &#125; &#125; if (flag) &#123; if (l == r) ans[l] = true; else &#123; int m = l + r &gt;&gt; 1; dfs(Lson); dfs(Rson); &#125; &#125; ufs.undo(cnt);&#125;int main() &#123; int n, m, T; scanf("%d%d%d", &amp;n, &amp;m, &amp;T); for (int i = 0, u, v, s, t; i &lt; m; i++) &#123; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;s, &amp;t); if (s &lt; t) update(0, T, 1, s, t - 1, u, v); &#125; ufs.init(n); dfs(0, T, 1); for (int i = 0; i &lt; T; i++) if (ans[i]) puts("Yes"); else puts("No");&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树分治</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可撤销并查集]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[可撤销并查集如果并查集想要支持回退操作，那么必然不能进行路径压缩。 所以只能通过按秩（高度）合并的方法来保证复杂度。 每次将一个版本（原树的根和原树的秩以及一些其它需要维护的东西）放进栈中，回退的时候从栈中一个一个复原。 代码1234567891011121314151617181920212223242526272829struct UFS &#123; int par[maxn], h[maxn], top; struct Node &#123; int x, y, fa, h; Node(int x = 0, int y = 0, int fa = 0, int h = 0) : x(x), y(y), fa(fa), h(h) &#123;&#125; &#125; stk[maxn]; void init(int n) &#123; top = 0; for (int i = 1; i &lt;= n; i++) par[i] = i, h[i] = 0; &#125; int find(int x) &#123; return x == par[x] ? x : find(par[x]); &#125; void merge(int u, int v) &#123; int x = find(u), y = find(v); // if (x == y) return; 和回退的次数相关 if (h[x] &gt; h[y]) swap(x, y); stk[top++] = Node(x, y, par[x], h[y]); if (h[x] == h[y]) h[y]++; par[x] = y; &#125; void undo(int k) &#123; for (int i = 0; i &lt; k; i++) &#123; Node &amp;it = stk[--top]; par[it.x] = it.fa; h[it.y] = it.h; &#125; &#125;&#125; ufs;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚树]]></title>
    <url>%2F2019%2F11%2F13%2F%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[虚树OI Wiki 上有详细的图解，这里就不赘述做法了。 简单说一下思想。 虚树就是将询问中涉及到的点从原树中拿出来，重新建树。这样就保证虚树中只涉及询问的点以及这些点的 $LCA$。从而起到控制复杂度的作用。 代码12345678910111213141516171819202122232425262728// 以1为根节点，只有单向边int stk[maxn], top;vector&lt;int&gt; g[maxn];void clean(int u) &#123; for (auto &amp;v : g[u]) clean(v); g[u].clear();&#125;inline void addEdge(int u, int v) &#123; g[u].push_back(v); &#125;void build(vector&lt;int&gt; &amp;ps) &#123; clean(1); sort(ps.begin(), ps.end(), [&amp;](const int &amp;a, const int &amp;b) &#123; return dfn[a] &lt; dfn[b]; &#125;); stk[top = 1] = 1; for (auto &amp;u : ps) &#123; if (u == 1) continue; int fa = lca(u, stk[top]); if (fa != stk[top]) &#123; while (dfn[fa] &lt; dfn[stk[top - 1]]) &#123; addEdge(stk[top - 1], stk[top]); --top; &#125; addEdge(fa, stk[top--]); if (dfn[fa] &gt; dfn[stk[top]]) stk[++top] = fa; &#125; stk[++top] = u; &#125; for (int i = 1; i &lt; top; i++) addEdge(stk[i], stk[i + 1]);&#125; 例题 luogu2495]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整体二分]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[整体二分整体二分就是带着所有的询问一起二分。 每次二分过后，就把满足条件的询问放到左边，不满足条件的询问放到右边，继续递归二分。 比如 solve(int l, int r, vector&lt;int&gt; vec)，其中 $[l,r]$ 当前的操作序列，$vec$ 表示当前的询问。 时间复杂度分析：想象一棵满二叉树，假如每个节点都只进行一次遍历操作，那么总复杂度就是 $O(n \log n)$ 以 luogu3527 为例。 给定一个环，每个节点有一个所属国家，$k$ 次事件，每次对 $[l,r]$ 区间上的每个点点权加上一个值，求每个国家最早多少次操作之后所有点的点权和能达到一个值。 假设二分端点是 $m$，那么先做 $[l,m]$ 这些操作的更新，然后将询问分成两部分，如果已经满足则放到左边，不满足的话减掉这些更新的和再放到右边。然后继续递归二分即可。 注意会爆long long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;using ll = long long;int a[maxn], ans[maxn];int le[maxn], ri[maxn], x[maxn];vector&lt;int&gt; G[maxn];int n, m, q;__int128 diff[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline __int128 query(int x) &#123; __int128 ret = 0; for (int i = x; i &gt; 0; i -= lowb(i)) ret += diff[i]; return ret;&#125;inline void add(int l, int r, int val) &#123; for (int i = l; i &lt;= m; i += lowb(i)) diff[i] += val; for (int i = r + 1; i &lt;= m; i += lowb(i)) diff[i] -= val;&#125;void update(int l, int r, int sign) &#123; for (int i = l; i &lt;= r; i++) &#123; if (ri[i] &gt;= le[i]) add(le[i], ri[i], sign * x[i]); else &#123; add(le[i], m, sign * x[i]); add(1, ri[i], sign * x[i]); &#125; &#125;&#125;void solve(int l, int r, vector&lt;int&gt; c) &#123; if (c.empty()) return; if (l == r) &#123; for (auto &amp;u : c) ans[u] = l; return; &#125; int m = l + r &gt;&gt; 1; update(l, m, 1); vector&lt;int&gt; left, right; for (auto &amp;u : c) &#123; __int128 sum = 0; for (auto &amp;v : G[u]) sum += query(v); if (sum &gt;= a[u]) &#123; left.push_back(u); &#125; else &#123; a[u] -= sum; right.push_back(u); &#125; &#125; update(l, m, -1); solve(l, m, left); solve(m + 1, r, right);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, c; i &lt;= m; i++) scanf("%d", &amp;c), G[c].push_back(i); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) scanf("%d%d%d", le + i, ri + i, x + i); vector&lt;int&gt; c(n); for (int i = 1; i &lt;= n; i++) c[i - 1] = i; solve(1, q + 1, c); for (int i = 1; i &lt;= n; i++) if (ans[i] == q + 1) puts("NIE"); else printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小树形图]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最小树形图定义有向图中固定根的最小“生成树”，即根可以通过树边到达图中任意一个点，且所有树边的权值和最小。 算法思想设最终得到的最小树形图为 $T$，原图为 $G$。 考虑将每个点权值最小的入边加入 $T$ 中。若 $T$ 中无环，则 $T$ 就是图 $G$ 的最小树形图。 为什么不是出边呢？因为在最终的树形图中每个点的入度都为1，但出度不一定为1。 这样做的正确性？因为图 $G$ 中所有的点都存在于 $T$ 中，因此对于任意一点 $u$，它可以选择任意一条入边加入 $T$ 中。所以必然选择权值最小的边。 若 $T$ 中有环，则要考虑从环上去掉一条边。具体去哪条边我们是不知道的，因此我们需要将环缩点之后重新做一次操作。 我们可以发现环中红色的边是要去掉的。 所以我们只要不断重复此过程，直到所得到图无环，我们就得到了最小树形图。 因此时间复杂度为 $O(VE)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 1e3 + 5;const int INF = 0x3f3f3f3f;struct Edge &#123; int u, v, w;&#125;;struct MDST &#123; vector&lt;Edge&gt; edges; int vis[maxn], id[maxn]; int pre[maxn], val[maxn]; void init() &#123; edges.clear(); &#125; void addEdge(int u, int v, int w) &#123; edges.push_back(&#123;u, v, w&#125;); &#125; int zhuliu(int n, int rt) &#123; int ans = 0; for (;;) &#123; for (int i = 1; i &lt;= n; i++) val[i] = INF, vis[i] = id[i] = 0; val[rt] = 0; for (auto &amp;e : edges) if (e.u != e.v &amp;&amp; e.w &lt; val[e.v]) pre[e.v] = e.u, val[e.v] = e.w; for (int i = 1; i &lt;= n; i++) if (i != rt &amp;&amp; val[i] == INF) return -1; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i == rt) continue; ans += val[i]; int u = i; // 找环 while (vis[u] != i &amp;&amp; !id[u] &amp;&amp; u != rt) &#123; vis[u] = i; u = pre[u]; &#125; if (!id[u] &amp;&amp; u != rt) &#123; id[u] = ++cnt; for (int v = pre[u]; v != u; v = pre[v]) id[v] = cnt; &#125; &#125; if (!cnt) break; // 重标号缩点 for (int i = 1; i &lt;= n; i++) if (!id[i]) id[i] = ++cnt; for (auto &amp;e : edges) &#123; if (id[e.u] != id[e.v]) e.w -= val[e.v]; e.u = id[e.u], e.v = id[e.v]; &#125; rt = id[rt]; n = cnt; &#125; return ans; &#125;&#125;; 输出方案考虑每次缩环之后要记录“新边”和“要被去掉的边”。 新边就是减去权值后新编号的边。 要被去掉的边就是之前权值最小的入边。 因为可能存在某条边被去掉，然后在这之后又被重新使用，如下图。 因此我们要按照逆拓扑序来找。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int maxn = 1e5 + 5;const int INF = 0x3f3f3f3f;struct Edge &#123; int u, v, w, id;&#125;;struct MDST &#123; vector&lt;Edge&gt; edges; int vis[maxn], id[maxn]; int pre[maxn], val[maxn]; int eid[maxn], used[maxn * 10]; int dele[maxn * 10], add[maxn * 10]; // 10 倍可能不够？ void init() &#123; edges.clear(); &#125; void addEdge(int u, int v, int w, int id) &#123; edges.push_back(&#123;u, v, w, id&#125;); &#125; int zhuliu(int n, int rt) &#123; int m = edges.size(); int ans = 0, tot = m; memset(used, 0, sizeof(used)); for (;;) &#123; for (int i = 1; i &lt;= n; i++) val[i] = INF, vis[i] = id[i] = 0; val[rt] = 0; for (auto &amp;e : edges) if (e.u != e.v &amp;&amp; e.w &lt; val[e.v]) pre[e.v] = e.u, val[e.v] = e.w, eid[e.v] = e.id; for (int i = 1; i &lt;= n; i++) if (i != rt &amp;&amp; val[i] == INF) return -1; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i == rt) continue; used[eid[i]]++; ans += val[i]; int u = i; while (vis[u] != i &amp;&amp; !id[u] &amp;&amp; u != rt) &#123; vis[u] = i; u = pre[u]; &#125; if (!id[u] &amp;&amp; u != rt) &#123; id[u] = ++cnt; for (int v = pre[u]; v != u; v = pre[v]) id[v] = cnt; &#125; &#125; if (!cnt) break; for (int i = 1; i &lt;= n; i++) if (!id[i]) id[i] = ++cnt; for (auto &amp;e : edges) &#123; if (id[e.u] != id[e.v]) &#123; e.w -= val[e.v]; dele[tot] = eid[e.v]; add[tot] = e.id; e.id = tot++; &#125; e.u = id[e.u], e.v = id[e.v]; &#125; rt = id[rt]; n = cnt; &#125; for (int i = tot - 1; i &gt;= m; i--) &#123; if (used[i]) &#123; used[dele[i]]--; used[add[i]]++; &#125; &#125; return ans; &#125;&#125; mdst; 不定根最小树形图我们可以通过建立一个虚拟根节点来解决这个问题，虚根向所有点建一条权值为 $val$ 的边。如果得到的结果比两倍的 $val$ 还大，说明图不连通。 $val$ 可以设置为所有边的权值和加一。 那么怎么知道最后选择哪个根呢？因为虚根是不会存在于一个环中，因此从虚根出发的边不会被替换，因此可以记录边的编号。 例题 hdu2121 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int maxn = 1e5 + 5;const ll INF = 1e18;int root;ll sum;struct Edge &#123; int u, v, id; ll w;&#125;;struct MDST &#123; vector&lt;Edge&gt; edges; int vis[maxn], id[maxn]; int pre[maxn], eid[maxn]; ll val[maxn]; void addEdge(int u, int v, ll w, int id) &#123; edges.push_back(&#123;u, v, id, w&#125;); &#125; ll zhuliu(int n, int rt) &#123; ll ans = 0; for (;;) &#123; for (int i = 1; i &lt;= n; i++) val[i] = INF, vis[i] = id[i] = 0; val[rt] = 0; for (auto &amp;e : edges) if (e.u != e.v &amp;&amp; e.w &lt; val[e.v]) pre[e.v] = e.u, val[e.v] = e.w, eid[e.v] = e.id; for (int i = 1; i &lt;= n; i++) if (i != rt &amp;&amp; val[i] == INF) return -1; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if (i == rt) continue; if (pre[i] == rt) root = eid[i]; ans += val[i]; if (ans &gt;= 2 * sum) return -1; int u = i; while (vis[u] != i &amp;&amp; !id[u] &amp;&amp; u != rt) &#123; vis[u] = i; u = pre[u]; &#125; if (!id[u] &amp;&amp; u != rt) &#123; id[u] = ++cnt; for (int v = pre[u]; v != u; v = pre[v]) id[v] = cnt; &#125; &#125; if (!cnt) break; for (int i = 1; i &lt;= n; i++) if (!id[i]) id[i] = ++cnt; for (auto &amp;e : edges) &#123; if (id[e.u] != id[e.v]) e.w -= val[e.v]; e.u = id[e.u], e.v = id[e.v]; &#125; rt = id[rt]; n = cnt; &#125; return ans; &#125;&#125; mdst;int main() &#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; mdst.edges.clear(); ll w; sum = 1; for (int i = 0, u, v; i &lt; m; i++) &#123; scanf("%d%d%lld", &amp;u, &amp;v, &amp;w); ++u, ++v; sum += w; mdst.addEdge(u, v, w, 0); &#125; for (int i = 1; i &lt;= n; i++) mdst.addEdge(n + 1, i, sum, i); ll ans = mdst.zhuliu(n + 1, n + 1); if (ans == -1) puts("impossible"); else printf("%lld %d\n", ans - sum, root - 1); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小树形图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治]]></title>
    <url>%2F2019%2F11%2F11%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[CDQ分治对于区间$[l,r)$，先分治计算 $[l,m), [m,r)$，然后再计算 $[l,m)$ 中的元素对 $[m,r)$ 的贡献。 需要注意的就是右边的区间不会对左边的区间产生贡献，否则无法CDQ分治。 以 luogu3810 为例。 有 $n$ 个元素，第 $i$ 个元素有 $a_i,b_i,c_i$ 三个属性，设 $f(i)$ 表示满足 $ a_j \leq a_i, b_j \leq b_i, c_j \leq c_i $ 的 $j$ 的数量。对于 $d \in [0, n)$，求 $f(i) = d$ 的数量。 首先按 $a$ 排序后就能保证右边的不会对左边产生贡献。 然后开始分治。 对于区间 $[l,r)$，先分治 $[l,m), [m,r)$。 然后计算区间 $[l,m)$ 对 区间 $[m,r)$ 的贡献。 首先可以把 $[l,m)$ 和 $[m,r)$ 按照 $b$ 排序，然后维护一个关于 $c$ 的树状数组。每次区间查询即可。 需要注意的就是对于两个相同的元素，他们相互之间是贡献的，因此第一步要先去重。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;using ll = long long;struct Node &#123; int a, b, c, id, num, ans; bool operator==(const Node &amp;rhs) const &#123; return (a == rhs.a &amp;&amp; b == rhs.b &amp;&amp; c == rhs.c); &#125;&#125; a[maxn];int ans[maxn], sum[maxn];int n, k;inline void add(int p, int x) &#123; for (int i = p; i &lt;= k; i += i &amp; -i) sum[i] += x;&#125;inline int query(int l, int r) &#123; int ret = 0; for (int i = r; i &gt; 0; i -= i &amp; -i) ret += sum[i]; for (int i = l - 1; i &gt; 0; i -= i &amp; -i) ret -= sum[i]; return ret;&#125;void solve(int l, int r) &#123; if (r - l &lt;= 1) return; int m = l + r &gt;&gt; 1; solve(l, m); solve(m, r); int p = l; for (int i = m; i &lt; r; i++) &#123; while (p &lt; m &amp;&amp; a[p].b &lt;= a[i].b) add(a[p].c, a[p].num), p++; a[i].ans += query(1, a[i].c); &#125; for (int i = l; i &lt; p; i++) add(a[i].c, -a[i].num); sort(a + l, a + r, [&amp;](const Node &amp;A, const Node &amp;B) &#123; if (A.b == B.b) return A.c &lt; B.c; return A.b &lt; B.b; &#125;);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;a[i].a, &amp;a[i].b, &amp;a[i].c), a[i].id = i, a[i].num = 1, a[i].ans = 0; sort(a, a + n, [&amp;](const Node &amp;A, const Node &amp;B) &#123; if (A.a == B.a &amp;&amp; A.b == B.b) return A.c &lt; B.c; if (A.a == B.a) return A.b &lt; B.b; return A.a &lt; B.a; &#125;); int m = 0; for (int i = 1; i &lt; n; i++) &#123; if (a[i] == a[m]) a[m].num++; else a[++m] = a[i]; &#125; solve(0, m + 1); for (int i = 0; i &lt;= m; i++) ans[a[i].ans + a[i].num - 1] += a[i].num; for (int i = 0; i &lt; n; i++) printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树分治]]></title>
    <url>%2F2019%2F11%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[线段树分治线段树分治即对时间轴建立线段树（标记永久化）。 这样我们将所有操作离线后，对于每个修改的操作，它所能影响的就是一个时间段。可以直接在线段树上更新。 查询则变成了一个单点查询（某个时间点）。 它的一个好处是可以把删除操作去掉。如果删除操作不好做的话可以考虑用线段树分治来解决。 以 bzoj4311 为例。 你要维护一个向量集合，支持以下操作： 插入一个向量 $(x,y)$。 删除插入的第 $i$ 个向量。 查询当前集合与 $(x,y)$ 点积的最大值是多少。 将所有操作离线后，我们就可以知道每一个向量所存在的时间段。然后在线段树上相应的区间中插入这个向量。 因为答案一定在上凸壳上，所以线段树上每个节点维护一个上凸壳。 查询就是单点查询，在路径上的每一个节点都三分一下最大值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define Lson l, m, lson#define Rson m + 1, r, rsonconst int maxn = 2e5 + 5;typedef long long ll;struct Point &#123; ll x, y; Point(ll x = 0, ll y = 0) : x(x), y(y) &#123;&#125; bool operator&lt;(const Point &amp;a) const &#123; if (x == a.x) return y &lt; a.y; return x &lt; a.x; &#125;&#125;;Point operator-(Point a, Point b) &#123; return Point(a.x - b.x, a.y - b.y); &#125;ll Cross(Point A, Point B) &#123; return A.x * B.y - A.y * B.x; &#125;ll Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;ll dot(Point A, Point B) &#123; return A.x * B.x + A.y * B.y; &#125;vector&lt;Point&gt; seg[maxn &lt;&lt; 2];ll ans;struct Vector &#123; int x, y, id; int in, out; Vector(int x = 0, int y = 0, int id = 0, int in = 0, int out = 0) : x(x), y(y), id(id), in(in), out(out) &#123;&#125;&#125;;struct Query &#123; int x, y, id; Query(int x = 0, int y = 0, int id = 0) : x(x), y(y), id(id) &#123;&#125;&#125;;vector&lt;Vector&gt; vec;vector&lt;Query&gt; query;void build(int l, int r, int rt) &#123; int n = seg[rt].size(), k = 0; sort(seg[rt].begin(), seg[rt].end()); vector&lt;Point&gt; tmp(2 * n); for (int i = 0; i &lt; n; tmp[k++] = seg[rt][i++]) while (k &gt; 1 &amp;&amp; Cross(tmp[k - 2], tmp[k - 1], seg[rt][i]) &gt;= 0) --k; tmp.resize(k); seg[rt] = tmp; if (l == r) return; int m = l + r &gt;&gt; 1; build(Lson); build(Rson);&#125;void update(int l, int r, int rt, int L, int R, int x, int y) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].push_back(Point(x, y)); return; &#125; int m = l + r &gt;&gt; 1; if (L &lt;= m) update(Lson, L, R, x, y); if (m + 1 &lt;= R) update(Rson, L, R, x, y);&#125;void find(int rt, Point p) &#123; int l = 0, r = seg[rt].size() - 1; int m1, m2; while (r - l &gt;= 3) &#123; m1 = l + (r - l) / 3, m2 = r - (r - l) / 3; if (dot(seg[rt][m1], p) &gt; dot(seg[rt][m2], p)) r = m2; else l = m1; &#125; for (int i = l; i &lt;= r; i++) ans = max(ans, dot(seg[rt][i], p));&#125;void ask(int l, int r, int rt, int p, int x, int y) &#123; if (seg[rt].size() &gt; 0) find(rt, Point(x, y)); if (l == r) return; int m = l + r &gt;&gt; 1; if (p &lt;= m) ask(Lson, p, x, y); else ask(Rson, p, x, y);&#125;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0, op, x, y, id; i &lt; n; i++) &#123; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d", &amp;x, &amp;y); int m = vec.size(); vec.push_back(Vector(x, y, m + 1, i + 1, n)); &#125; else if (op == 2) &#123; scanf("%d", &amp;id); vec[id - 1].out = i + 1; &#125; else &#123; scanf("%d%d", &amp;x, &amp;y); query.push_back(Query(x, y, i + 1)); &#125; &#125; for (int i = 0; i &lt; vec.size(); i++) &#123; Vector &amp;v = vec[i]; update(1, n, 1, v.in, v.out, v.x, v.y); &#125; build(1, n, 1); for (int i = 0; i &lt; query.size(); i++) &#123; Query &amp;q = query[i]; ans = 0; ask(1, n, 1, q.id, q.x, q.y); printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf1243D 0-1 MST]]></title>
    <url>%2F2019%2F11%2F07%2Fcf1243D-0-1-MST%2F</url>
    <content type="text"><![CDATA[题意一个 $n$ 个点无向连通完全图，边权只有 $0$ 和 $1$。问最小权值生成树。 指定 $m$ 条边的权值为 $1$，剩下边的权值都为 $0$。 $1 \leq n \leq 10^5$ 分析首先答案是连通块的个数减一。 接下来就是如何求补图连通块的个数。 维护一个队列，队列中的元素都是一个连通块的。 从每个未访问节点出发，将所有相连的节点都打上标记，然后将没有标记且未访问过的节点放入队列中（这些点都在同一个连通块中）。清空标记。继续 $bfs$。 对于那些未访问过的节点，用一个双向链表来维护，每次放入队列时，就从链表中删除相应元素。 复杂度分析：首先每个点只会入队一次。接下来的复杂度主要是在 $bfs$ 时链表的遍历。换个角度考虑，每个点只会被遍历它的度数次。因此最终的复杂度是 $O(|V| + |E|)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt; G[maxn];bool vis[maxn];bool used[maxn];pair&lt;int, int&gt; a[maxn]; inline void del(int u) &#123; a[a[u].first].second = a[u].second; a[a[u].second].first = a[u].first;&#125;void bfs(int s) &#123; used[s] = true; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; auto u = q.front(); q.pop(); for (auto &amp;v : G[u]) vis[v] = true; for (int v = a[0].second; v; v = a[v].second) if (!vis[v] &amp;&amp; !used[v]) q.push(v), del(v), used[v] = true; for (auto &amp;v : G[u]) vis[v] = false; &#125;&#125;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, a, b; i &lt; m; i++) &#123; scanf("%d%d", &amp;a, &amp;b); G[a].push_back(b); G[b].push_back(a); &#125; int cnt = 0; for (int i = 1; i &lt;= n; i++) a[i].first = i - 1, a[i].second = i + 1; a[0].second = 1; a[n].second = 0; for (int i = 1; i &lt;= n; i++) if (!used[i]) bfs(i), cnt++; printf("%d\n", cnt - 1);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>连通块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT 快速沃尔什变换]]></title>
    <url>%2F2019%2F11%2F06%2FFWT-%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[FWT 快速沃尔什变换目前我了解的FWT的功能就是在 $O(n\log n) 时间复杂度内求：$ $C_k = \sum_{i|j=k}a_ib_j$ $C_k = \sum_{i\&amp;j=k}a_ib_j$ $C_k = \sum_{i\oplus j=k}a_ib_j$ 其思想和 $FFT$ 很类似。把原多项式 $A$ 转化成另一个多项式 $FWT(A)$。 然后 $A \oplus B = IFWT(FWT(A) \times FWT(B))$ 其中 $\oplus$ 表示一些位运算。 然后接下来的问题是针对不同的位运算，去找出如何求 $FWT$ 和 $IFWT$。 一些定义$A = [a_0, a_1, a_2, …, a_{n-1}]$ 设 $A$ 的长度为 $2$ 的幂次，将 $A = [A_0, A_1]$ 分成长度相同的两部分。 OR$C = A|B = [\sum_{i|j=0}a_ib_j, \sum_{i|j=1}a_ib_j, \sum_{i|j=2}a_ib_j, …, \sum_{i|j=k}a_ib_j]$ $C_k = \sum_{i|j=k}a_ib_j$ $FWT(A) = [\sum_{i | 0 = 0}a_i, \sum_{i | 1 = 1}a_i, \sum_{i | 2 = 2}a_i, …, \sum_{i | (n-1) = (n-1)}a_{n-1}]$ FWT 变换所满足的规律$$FWT(A) = [FWT(A_0), FWT(A_0 + A_1)]$$ FWT 变换所满足的性质$FWT(A+B) = FWT(A) + FWT(B)$ $FWT(A|B) = FWT(A) \times FWT(B)$ $FWT(A|B) = FWT([(A|B)_0, (A|B)_1])$$ = [FWT((A|B)_0), FWT((A|B)_0 + (A|B)_1)]$$ = [FWT(A_0 | B_0), FWT(A_0 | B_0 + A_0 | B_1 + A_1 | B_0 + A_1 | B_1)]$$ = [FWT(A_0) \times FWT(B_0), FWT(A_0) \times FWT(B_0) + FWT(A_0) \times FWT(B_1) + FWT(A_1) \times FWT(B_0) + FWT(A_1) \times FWT(B_1))]$$ = [FWT(A_0) \times FWT(B_0), (FWT(A_0) + FWT(A_1)) \times (FWT(B_0) + FWT(B_1))]$$ = [FWT(A_0), FWT(A_0 + A_1)] \times [FWT(B_0), FWT(B_0 + B_1)]$$ = FWT(A) \times FWT(B)$ IFWT 变换所满足的规律$$IFWT(A) = [IFWT(A_0), IFWT(A_1) - IFWT(A_0)]$$ AND$C = A\&amp;B = [\sum_{i\&amp;j=0}a_ib_j, \sum_{i\&amp;j=1}a_ib_j, \sum_{i\&amp;j=2}a_ib_j, …, \sum_{i\&amp;j=k}a_ib_j]$ $C_k = \sum_{i\&amp;j=k}a_ib_j$ FWT 变换所满足的规律$$FWT(A) = [FWT(A_0 + A_1), FWT(A_1)]$$ FWT 变换所满足的性质$FWT(A+B) = FWT(A) + FWT(B)$ $FWT(A\&amp;B) = FWT(A) \times FWT(B)$ IFWT 变换所满足的规律$$IFWT(A) = [IFWT(A_0) - IFWT(A_1), IFWT(A_1)]$$ XOR$C = A\oplus B = [\sum_{i\oplus j=0}a_ib_j, \sum_{i\oplus j=1}a_ib_j, \sum_{i\oplus j=2}a_ib_j, …, \sum_{i\oplus j=k}a_ib_j]$ $C_k = \sum_{i\oplus j=k}a_ib_j$ FWT 变换所满足的规律$$FWT(A) = [FWT(A_0) + FWT(A_1), FWT(A_0) - FWT(A_1)]$$ FWT 变换所满足的性质$FWT(A+B) = FWT(A) + FWT(B)$ $FWT(A\oplus B) = FWT(A) \times FWT(B)$ IFWT 变换所满足的规律$$IFWT(A) = [\frac{IFWT(A_0) + IFWT(A_1)}{2}, \frac{IFWT(A_0) - IFWT(A_1)}{2}$$ 代码洛谷P4717 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;const int maxn = 1e6 + 6;int a[maxn], b[maxn];int inv2 = (mod + 1) / 2;// 空间要开到2的幂次（清空也要清空到2的幂次）template &lt;class T&gt;void fwt(int a[], int m, T f) &#123; for (int i = 1; i &lt; m; i &lt;&lt;= 1) for (int p = i &lt;&lt; 1, j = 0; j &lt; m; j += p) for (int k = 0; k &lt; i; k++) f(a[j + k], a[i + j + k]);&#125;inline void AND(int &amp;a, int &amp;b) &#123; (a += b) %= mod; &#125;inline void OR(int &amp;a, int &amp;b) &#123; (b += a) %= mod; &#125;inline void XOR(int &amp;a, int &amp;b) &#123; int l = a, r = b; a = (l + r) % mod, b = (l - r + mod) % mod;&#125;inline void rAND(int &amp;a, int &amp;b) &#123; a = (a - b + mod) % mod; &#125;inline void rOR(int &amp;a, int &amp;b) &#123; b = (b - a + mod) % mod; &#125;inline void rXOR(int &amp;a, int &amp;b) &#123; int l = a, r = b; a = 1LL * (l + r) % mod * inv2 % mod; b = 1LL * (l - r + mod) % mod * inv2 % mod;&#125;int c[maxn], d[maxn];int n, N;void solve(int a[], int b[], int op) &#123; for (int i = 0; i &lt; N; i++) c[i] = a[i], d[i] = b[i]; if (op == 0) &#123; fwt(c, N, OR); fwt(d, N, OR); for (int i = 0; i &lt; N; i++) c[i] = 1LL * c[i] * d[i] % mod; fwt(c, N, rOR); &#125; else if (op == 1) &#123; fwt(c, N, AND); fwt(d, N, AND); for (int i = 0; i &lt; N; i++) c[i] = 1LL * c[i] * d[i] % mod; fwt(c, N, rAND); &#125; else &#123; fwt(c, N, XOR); fwt(d, N, XOR); for (int i = 0; i &lt; N; i++) c[i] = 1LL * c[i] * d[i] % mod; fwt(c, N, rXOR); &#125; for (int i = 0; i &lt; N; i++) printf("%d ", c[i]); puts("");&#125;int main() &#123; scanf("%d", &amp;n); N = 1 &lt;&lt; n; for (int i = 0; i &lt; N; i++) scanf("%d", a + i); for (int i = 0; i &lt; N; i++) scanf("%d", b + i); solve(a, b, 0); solve(a, b, 1); solve(a, b, 2);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder1879 Rikka with Triangles]]></title>
    <url>%2F2019%2F10%2F31%2FhihoCoder1879-Rikka-with-Triangles%2F</url>
    <content type="text"><![CDATA[题意平面上有 $n$ 个点，求锐角三角形的总面积。存在三点共线。 $1 \leq n \leq 2000$ 分析直接求锐角并不好求，考虑用总面积减去直角三角形和钝角三角形的面积。 我们可以通过枚举顶点，然后极角排序。计算顶点这个角是锐角三角形的总面积和是直角和钝角的总面积。这里维护一个滑动窗口即可（因为三点共线的情况，这里的细节较多。推荐先对同方向的向量进行合并）。 然后我们发现对于一个锐角三角形，我们会算三遍它的面积。对于对于一个直角或钝角三角形，它们会被当做锐角三角形算两次，因此我们要减去二倍的直角或钝角三角形的面积。 最后的答案再除以三即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;using ll = long long;using i128 = __int128;const int maxn = 2e3 + 5;inline int sign(i128 a) &#123; return a &lt; 0 ? -1 : a &gt; 0; &#125;inline int cmp(i128 a, i128 b) &#123; return sign(a - b); &#125;struct Point &#123; i128 x, y; Point operator+(const Point &amp;rhs) const &#123; return &#123;rhs.x + x, rhs.y + y&#125;; &#125; Point operator-(const Point &amp;rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; Point operator*(i128 rhs) const &#123; return &#123;x * rhs, y * rhs&#125;; &#125; Point operator/(i128 rhs) const &#123; return &#123;x / rhs, y / rhs&#125;; &#125; bool operator&lt;(const Point &amp;rhs) const &#123; int s = cmp(x, rhs.x); if (s) return s == -1; return cmp(y, rhs.y) == -1; &#125; bool operator==(const Point &amp;rhs) const &#123; return cmp(x, rhs.x) == 0 &amp;&amp; cmp(y, rhs.y) == 0; &#125; void Mod() &#123; x %= mod; y %= mod; &#125; // 是否在上半区 bool quad() const &#123; return sign(y) == 1 || (sign(y) == 0 &amp;&amp; sign(x) &gt;= 0); &#125; i128 dot(Point rhs) &#123; return x * rhs.x + y * rhs.y; &#125; i128 det(Point rhs) &#123; return x * rhs.y - y * rhs.x; &#125;&#125;;bool cmpAngle(Point a, Point b) &#123; if (a.quad() != b.quad()) return a.quad() &lt; b.quad(); else return sign(a.det(b)) &gt; 0;&#125;Point a[maxn], ps[maxn], pp[maxn];ll inv3 = 332748118;ll solve(int n) &#123; if (n &lt;= 1) return 0; Point pt1 = pp[1], pt2 = pp[1]; ll ret = 0; int cur1 = 1, cur2 = 1; for (int i = 1; i &lt;= n; i++) &#123; while (true) &#123; int nxt = cur1 + 1; if (nxt &gt; n) nxt = 1; if (nxt == i) break; if (!(ps[i].det(ps[nxt]) &gt;= 0 &amp;&amp; ps[i].dot(ps[nxt]) &gt; 0)) break; pt1 = pt1 + pp[nxt]; cur1 = nxt; &#125; while (true) &#123; int nxt = cur2 + 1; if (nxt &gt; n) nxt = 1; if (nxt == i) break; if (!(ps[i].det(ps[nxt]) &gt;= 0)) break; pt2 = pt2 + pp[nxt]; cur2 = nxt; &#125; auto tmp1 = pt1, tmp2 = pt2 - pt1; tmp1.Mod(), tmp2.Mod(); ret = (ret + pp[i].det(tmp1)) % mod; ret = (ret - pp[i].det(tmp2) * 2LL % mod + mod) % mod; if (cur1 == i) &#123; cur1++; pt1 = pt1 + pp[cur1]; &#125; if (cur2 == i) &#123; cur2++; pt2 = pt2 + pp[cur2]; &#125; pt1 = pt1 - pp[i]; pt2 = pt2 - pp[i]; &#125; return ret;&#125;int main() &#123; int T, n; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); ll x, y; for (int i = 1; i &lt;= n; i++) scanf("%lld%lld", &amp;x, &amp;y), a[i] = &#123;x, y&#125;; ll tot = 0; for (int i = 1; i &lt;= n; i++) &#123; int sz = 0, m = 1; for (int j = 1; j &lt;= n; j++) if (j != i) ps[++sz] = a[j] - a[i]; sort(ps + 1, ps + 1 + sz, cmpAngle); pp[1] = ps[1]; for (int i = 2; i &lt;= sz; i++) &#123; if (ps[m].det(ps[i]) == 0 &amp;&amp; ps[m].dot(ps[i]) &gt; 0) &#123; pp[m] = pp[m] + ps[i]; &#125; else &#123; ps[++m] = ps[i]; pp[m] = ps[i]; &#125; &#125; if (m == 1) continue; if (ps[m].det(ps[1]) == 0 &amp;&amp; ps[m].dot(ps[1]) &gt; 0) &#123; pp[1] = pp[1] + ps[m]; m--; &#125; tot = (tot + solve(m)) % mod; &#125; printf("%lld\n", tot * inv3 % mod); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新计算几何]]></title>
    <url>%2F2019%2F10%2F31%2F%E6%96%B0%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[点积$\vec{a} \cdot \vec{b} = |\vec{a}| \cdot |\vec{b}| \cdot cos(\theta) = a_x \cdot b_x + a_y \cdot b_y$ $\vec{a} \cdot \vec{b} &lt; 0$ 两向量成钝角 $\vec{a} \cdot \vec{b} = 0$ 两向量垂直 $\vec{a} \cdot \vec{b} &gt; 0$ 两向量成锐角 几何意义：一个向量在另一个向量上的投影长度。 叉积$|\vec{a} \times \vec{b}| = |\vec{a}| \cdot |\vec{b}| \cdot sin&lt;\vec{a}, \vec{b}&gt; = x_a \times y_b - x_b \times y_a$ $sin&lt;\vec{a}, \vec{b}&gt;$ 指有向角。即从 $\vec{a}$ 逆时针旋转到 $\vec{b}$ 的角度。 $\vec{a} \times \vec{b} &lt; 0$ $\vec{a}$ 在 $\vec{b}$ 的逆时针 $\vec{a} \times \vec{b} = 0$ 两向量同向或反向 $\vec{a} \times \vec{b} &gt; 0$ $\vec{a}$ 在 $\vec{b}$ 的顺时针 叉积还可以表示以两向量为边的平行四边形的有向面积。 极角排序直接用 $atan2$ 这个函数进行极角排序的话，精度是非常查的。考虑 $(1e9,1), (1e9-1,1)$ 这两个向量的极角，差距是非常小的，大概在 $1e{-18}$ 左右。 而如果纯用叉积来判断，会出现环的情况。 所以我们可以先将平面分为两个半区：上半区和下半区。对于处在同一半区的向量，利用叉积来判断相对位置即可。 经典题目：Rikka with Triangles 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;using db = double;const db eps = 1e-9;inline int sign(db a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;inline int cmp(db a, db b) &#123; return sign(a - b); &#125;struct Point &#123; db x, y; Point operator+(const Point &amp;rhs) const &#123; return &#123;rhs.x + x, rhs.y + y&#125;; &#125; Point operator-(const Point &amp;rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; Point operator*(db rhs) const &#123; return &#123;x * rhs, y * rhs&#125;; &#125; Point operator/(db rhs) const &#123; return &#123;x / rhs, y / rhs&#125;; &#125; bool operator&lt;(const Point &amp;rhs) const &#123; int s = cmp(x, rhs.x); if (s) return s == -1; return cmp(y, rhs.y) == -1; &#125; bool operator==(const Point &amp;rhs) const &#123; return cmp(x, rhs.x) == 0 &amp;&amp; cmp(y, rhs.y) == 0; &#125; // 是否在上半区 bool quad() const &#123; return sign(y) == 1 || (sign(y) == 0 &amp;&amp; sign(x) &gt;= 0); &#125; // (-pi, pi] db alpha() &#123; return atan2(y, x); &#125; db abs2() &#123; return x * x + y * y; &#125; db abs() &#123; return sqrt(abs2()); &#125; db distTo(const Point &amp;rhs) &#123; return (*this - rhs).abs(); &#125; db dot(const Point &amp;rhs) &#123; return x * rhs.x + y * rhs.y; &#125; db det(const Point &amp;rhs) &#123; return x * rhs.y - y * rhs.x; &#125; Point rotate(db an) &#123; return &#123;x * cos(an) - y * sin(an), x * sin(an) + y * cos(an)&#125;; &#125;&#125;;inline db cross(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;inline db cross(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; return cross(b - a, c - a);&#125;inline db dot(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.x + a.y + b.y; &#125;inline db dot(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; return dot(b - a, c - a);&#125;// 先判断是否处于同一半区，再根据叉积判断相对位置bool cmpAngle(Point a, Point b) &#123; if (a.quad() != b.quad()) return a.quad() &lt; b.quad(); else return sign(cross(a, b)) &gt; 0;&#125;// 直线平行bool isLLparallel(const Point &amp;a, const Point &amp;b, const Point &amp;c, const Point &amp;d) &#123; db a1 = cross(c, d, a), a2 = -cross(c, d, b); return sign(a1 + a2) != 0;&#125;Point intersectLL(const Point &amp;a, const Point &amp;b, const Point &amp;c, const Point &amp;d) &#123; db x = cross(c, d, a), y = -cross(c, d, b); return (a * y + b * x) / (x + y);&#125;// p1 -&gt; p2 左侧vector&lt;Point&gt; ConvexCut(const vector&lt;Point&gt; &amp;ps, Point p1, Point p2) &#123; vector&lt;Point&gt; ret; int n = ps.size(); for (int i = 0; i &lt; n; i++) &#123; auto p3 = ps[i], p4 = ps[(i + 1) % n]; int s1 = sign(cross(p1, p2, p3)), s2 = sign(cross(p1, p2, p4)); if (s1 &gt;= 0) ret.push_back(p3); if (s1 * s2 &lt; 0) ret.push_back(intersectLL(p1, p2, p3, p4)); &#125; return ret;&#125;struct Line &#123; // p[0] -&gt; p[1] Point p[2]; Point &amp;operator[](int k) &#123; return p[k]; &#125; Point dir() &#123; return p[1] - p[0]; &#125; // k 在直线左侧 bool include(Point k) &#123; return sign(cross(p[1] - p[0], k - p[0])) &gt; 0; &#125;&#125;;Point intersectLL(Line &amp;a, Line &amp;b) &#123; return intersectLL(a[0], a[1], b[0], b[1]);&#125;bool parallel(Line k1, Line k2) &#123; return sign(cross(k1.dir(), k2.dir())) == 0; &#125;bool sameDir(Line k1, Line k2) &#123; return parallel(k1, k2) &amp;&amp; sign(dot(k1.dir(), k2.dir())) == 1;&#125;bool operator&lt;(Line k1, Line k2) &#123; if (sameDir(k1, k2)) return k2.include(k1[0]); return cmpAngle(k1.dir(), k2.dir());&#125;// k1 和 k2 的交点在 k3 的左侧int checkpos(Line k1, Line k2, Line k3) &#123; return k3.include(intersectLL(k1, k2));&#125;vector&lt;Line&gt; halfPlaneIS(vector&lt;Line&gt; &amp;L) &#123; // 极角排序 sort(L.begin(), L.end()); deque&lt;Line&gt; q; for (int i = 0; i &lt; L.size(); i++) &#123; if (i &amp;&amp; sameDir(L[i], L[i - 1])) continue; while (q.size() &gt; 1 &amp;&amp; !checkpos(q[q.size() - 2], q[q.size() - 1], L[i])) q.pop_back(); while (q.size() &gt; 1 &amp;&amp; !checkpos(q[1], q[0], L[i])) q.pop_front(); q.push_back(L[i]); &#125; while (q.size() &gt; 2 &amp;&amp; !checkpos(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back(); while (q.size() &gt; 2 &amp;&amp; !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front(); vector&lt;Line&gt; ans; for (int i = 0; i &lt; q.size(); i++) ans.push_back(q[i]); return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCPC XiaMen Onsite]]></title>
    <url>%2F2019%2F10%2F30%2F2019-CCPC-XiaMen-Onsite%2F</url>
    <content type="text"><![CDATA[B-Zayin and Elements题意$n$ 个怪兽，$m$ 个骑士，每个骑士有三个属性 $a_i,b_i,c_i$。每个骑士可以消灭指定的一些怪兽。当一个骑士消灭一个怪兽时，如果其 $a_i &gt; 0$，那么会消耗 $1$ 单位的 $a_i$。否则如果其 $b_i &gt; 0$，那么会消耗 $0.5$ 单位的 $b_i$。否则如果其 $c_i &gt; 0$，那么会消耗 $1$ 单位的 $c_i$。问消灭完所有怪兽后，最大的 $\sum^m_{i=1} \lfloor b_i + c_i \rfloor$ 是多少。 $1 \leq n \leq 100, 1 \leq m \leq 20, 0 \leq a_i + b_i + c_i \leq 10$ 分析比赛的时候还不会一般图匹配，所以一直当网络流做。一直卡在没有办法解决 $b$ 的花费。因为用 $b$ 消灭一个怪兽的代价和消灭两个怪兽的代价是相同的。 对于每单位的 $a$ 建一个点 $a_1$，对每单位的 $b$ 建两个点 $b_1,b_2$，对每单位的 $c$ 建两个点 $c_1,c_2$。 对于某个怪兽 $x$，建 $(x,a_1), (x,b_1), (x,b_2), (b_1,b_2), (x,c_1), (c_1,c_2)$。 然后跑一般图最大匹配。注意要优先匹配怪兽，因为首先要满足的条件是所有怪兽被消灭。然后再去顺序匹配 $a,b,c$。因为带花树在匹配数不增加的情况下不会改变已匹配的边，所以匹配要有一个优先级。 有解当且仅当所有的怪兽都是匹配点。 答案就是最大匹配数减去怪兽的数量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000;struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; queue&lt;int&gt; Q; int n, clk; int match[maxn]; int par[maxn]; int Type[maxn]; int pre[maxn]; int vis[maxn]; void init(int n) &#123; this-&gt;n = n; clk = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0, match[i] = 0; &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i, Type[i] = -1; Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125;&#125; match;int vec[1000];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); int tot = n; vector&lt;int&gt; av, bv, cv; for (int i = 1, cnt, a, b, c; i &lt;= m; i++) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;cnt); for (int j = 0; j &lt; cnt; j++) scanf("%d", vec + j); for (int j = 0; j &lt; a; j++) &#123; int x = ++tot; av.push_back(x); for (int k = 0; k &lt; cnt; k++) match.addEdge(x, vec[k]); &#125; for (int j = 0; j &lt; 2 * b; j += 2) &#123; int x = ++tot; int y = ++tot; bv.push_back(x); bv.push_back(y); match.addEdge(x, y); for (int k = 0; k &lt; cnt; k++) &#123; match.addEdge(x, vec[k]); match.addEdge(y, vec[k]); &#125; &#125; for (int j = 0; j &lt; 2 * c; j += 2) &#123; int x = ++tot; int y = ++tot; cv.push_back(x); cv.push_back(y); match.addEdge(x, y); for (int k = 0; k &lt; cnt; k++) match.addEdge(x, vec[k]); &#125; &#125; int ans = 0; bool ok = true; match.n = tot; for (int i = 1; i &lt;= n; i++) &#123; if (!match.match[i]) &#123; int x = match.Augument(i); ans += x; if (!x) &#123; ok = false; break; &#125; &#125; &#125; if (!ok) puts("-1"); else &#123; for (auto &amp;v : av) if (!match.match[v]) ans += match.Augument(v); for (auto &amp;v : bv) if (!match.match[v]) ans += match.Augument(v); for (auto &amp;v : cv) if (!match.match[v]) ans += match.Augument(v); printf("%d\n", ans - n); &#125; match.init(tot); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>一般图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3446 daizhenyang's chess]]></title>
    <url>%2F2019%2F10%2F30%2Fhdu3446-daizhenyang-s-chess%2F</url>
    <content type="text"><![CDATA[题目链接 题意给定一个 $n \times m$ 大小的棋盘，棋盘上有一些空位置。给定棋子的初始位置，两人轮流移动棋子，不能走的人输。 规定： 走过的位置不能再走。 每次所走的位置相对于原来的位置的偏移是给定的。比如给了两种走法 $(+1,+2), (-1,0)$。 分析将图中每个空位置看作点，“相邻”的点建一条边。跑一次最大匹配。 然后再将起始点加入图中，跑一次最大匹配。 如果两次的匹配数相等，则说明从起始点这个未盖点出发，没有找到增广路。即不管先手怎么走，后手只要走其对应的配偶就必胜。 如果匹配数增加，则说明有一条从起始点出发的增广路。即交替路的长度为奇数，先手必胜。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300;char maze[20][20];int dr[] = &#123;-2, -2, -2, -2, -1, -1, -1, -1, -1, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2&#125;;int dc[] = &#123;-2, -1, 1, 2, -2, -1, 0, 1, 2, -1, 1, -2, -1, 0, 1, 2, -2, -1, 1, 2&#125;;int n, m;struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; queue&lt;int&gt; Q; int n, clk; int match[maxn]; int par[maxn]; int Type[maxn]; int pre[maxn]; int vis[maxn]; void init(int n) &#123; this-&gt;n = n; for (int i = 1; i &lt;= n; i++) G[i].clear(); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i, Type[i] = -1; Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125; int work() &#123; int ans = 0; clk = 0; for (int i = 1; i &lt;= n; i++) vis[i] = 0, match[i] = 0; for (int i = 1; i &lt;= n; i++) if (!match[i]) ans += Augument(i); return ans; &#125;&#125; match;int id[20][20];int build() &#123; int tot = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; id[i][j] = 0; if (maze[i][j] == '.') id[i][j] = ++tot; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (!id[i][j]) continue; for (int k = 0; k &lt; 20; k++) &#123; int nr = i + dr[k]; int nc = j + dc[k]; if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= m || !id[nr][nc]) continue; int x = id[i][j], y = id[nr][nc]; match.addEdge(x, y); &#125; &#125; &#125; match.n = tot++; match.work(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (maze[i][j] == 'K') &#123; for (int k = 0; k &lt; 20; k++) &#123; int nr = i + dr[k]; int nc = j + dc[k]; if (nr &lt; 0 || nr &gt;= n || nc &lt; 0 || nc &gt;= m || !id[nr][nc]) continue; match.addEdge(tot, id[nr][nc]); &#125; break; &#125; &#125; &#125; match.n = tot; match.vis[tot] = match.match[tot] = 0; int res = match.Augument(tot); match.init(tot); return res == 0;&#125;int main() &#123; int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%s", maze[i]); printf("Case #%d: daizhenyang ", kase++); if (build()) puts("lose"); else puts("win"); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>一般图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3551 Hard Problem]]></title>
    <url>%2F2019%2F10%2F30%2Fhdu3551-Hard-Problem%2F</url>
    <content type="text"><![CDATA[题目链接 题意给一张 $n$ 个点 $m$ 条边的无向图。再给一个度数序列 $d_1, d_2 … d_n$，问是否可以找到一个子图，使得子图中每个点的度数和对应的 $d_i$ 相同。 $1 \leq n \leq 50, 1 \leq m \leq 200$ 分析一个显然的想法是对度数拆点。 不妨假设一次匹配的意义为删边操作所带来度数减少。 那么设 $D_i$ 为 $i$ 点在原图中的度数，那么 $deg_i = D_i - d_i$ 就是将要减少的度数。 将每个点拆成 $deg_i$ 个点。 每条边拆成两个点。 跑一次最大匹配，如果是完美匹配，则证明可以找到这样一个子图。并且如果已匹配边的两个端点是原图中一条边拆成的两个点，那么表示这条边在原图中不会被删去。 匹配的顺序是优先去匹配点再去匹配边拆成的点，因为要保证每个点的度数都满足要求。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 805;using pii = pair&lt;int, int&gt;;vector&lt;pii&gt; edges;int deg[maxn];struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; queue&lt;int&gt; Q; int n, clk; int match[maxn]; int par[maxn]; int Type[maxn]; int pre[maxn]; int vis[maxn]; void init(int n) &#123; this-&gt;n = n; clk = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0, match[i] = 0; &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i, Type[i] = -1; Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125; int work() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) if (!match[i]) ans += Augument(i); return ans; &#125;&#125; match;int pre[maxn];int main() &#123; int n, m, T; int kase = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) deg[i] = 0; edges.clear(); for (int i = 0, u, v; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); deg[u]++, deg[v]++; edges.push_back(&#123;u, v&#125;); &#125; pre[0] = 1; for (int i = 1, x; i &lt;= n; i++) &#123; scanf("%d", &amp;x); deg[i] -= x; pre[i] = pre[i - 1] + deg[i]; &#125; int tot = pre[n] + m * 2 - 1; printf("Case %d: ", kase++); bool ok = true; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &lt; 0) &#123; puts("NO"); ok = false; break; &#125; &#125; if (!ok) continue; match.init(tot); for (int i = 0; i &lt; m; i++) &#123; int u = pre[n] + i * 2, v = u + 1; int x = edges[i].first, y = edges[i].second; for (int j = pre[x - 1]; j &lt; pre[x]; j++) match.addEdge(j, u); for (int j = pre[y - 1]; j &lt; pre[y]; j++) match.addEdge(j, v); match.addEdge(u, v); &#125; int ans = match.work(); for (int i = 1; i &lt;= tot; i++) &#123; if (match.match[i] == 0) &#123; ok = false; break; &#125; &#125; if (ok) puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>一般图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj3316 Game]]></title>
    <url>%2F2019%2F10%2F30%2Fzoj3316-Game%2F</url>
    <content type="text"><![CDATA[题目链接 题意一个 $19 \times 19$ 的棋盘，上面有 $n$ 个棋子。两个人交替每次拿走一个棋子，要求两次拿走的棋子的曼哈顿距离不超过 $L$。最后谁不能拿谁输。先手不受限制。 问最后谁输谁赢。 分析一回合的操作可以看作一个匹配。 如果两颗棋子的曼哈顿距离小于 $L$，则建一条边。 如果图中存在完美匹配，那么先手必输，因为后手只要拿对应的匹配即可。 否则的话先手只要走一个未盖点，这样的话后手一定会走在匹配点上。接下来先手只要走对应的配偶，则必胜。因为从未盖点出发不会走到另外一个未盖点（否则就可以继续增广，就不是最大匹配了）。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 400;int x[maxn], y[maxn];struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; queue&lt;int&gt; Q; int n, clk; int match[maxn], par[maxn]; int Type[maxn], pre[maxn], vis[maxn]; void init(int n) &#123; this-&gt;n = n; clk = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0, match[i] = 0; &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i, Type[i] = -1; Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125; int work() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) if (!match[i]) ans += Augument(i); return ans; &#125;&#125; match;int n, L;bool ok(int i, int j) &#123; int ans = abs(x[i] - x[j]) + abs(y[i] - y[j]); return ans &lt;= L;&#125;int main() &#123; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d%d", x + i, y + i); scanf("%d", &amp;L); match.init(n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; if (ok(i, j)) match.addEdge(i, j); &#125; &#125; match.work(); bool ok = true; for (int i = 1; i &lt;= n; i++) &#123; if (!match.match[i]) &#123; ok = false; break; &#125; &#125; if (ok) puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>一般图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uoj171 挑战NPC]]></title>
    <url>%2F2019%2F10%2F30%2Fuoj171-%E6%8C%91%E6%88%98NPC%2F</url>
    <content type="text"><![CDATA[题目链接 题意$n$ 个球，$m$ 个球筐，每个球筐最多装 $3$ 个球。每个球只能放进特定的球筐中。每个球都必须放进一个球筐中。如果一个球筐内的球数小于等于 $1$，则称这个球筐是半空的。求半空的球筐最多有多少个？ $1 \leq n \leq 3m, 1 \leq m \leq 100$ 分析如果题目只要求可行性的话，只要拆点二分图匹配即可。 每个球筐拆成三个点 $a, b, c$。 但是因为要求半空的球筐数量最多，所以我们希望在满足每个球都能放进一个球筐中的前提下，优先去匹配球筐内的点。（球筐内部如果存在一个匹配，那么最多只有一个球可以和这个球筐进行匹配）。 因此图就不是二分图了，就要用到一般图匹配。 对于每个球筐，我们将其拆成三个点后，只要在任意两个点连一条即可（如 $b,c$ 之间）。因为这三个点本质上是等价的。 因为要先满足每个球都能放进一个球筐中，所以我们应该优先去匹配球，即从每个球开始找增广路。 最后有解的条件是每个球都匹配到了球筐。 答案就是最大匹配数减去球数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 605;struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; int n, clk; int match[maxn]; int par[maxn]; int Type[maxn]; int pre[maxn]; int vis[maxn]; void init(int n) &#123; this-&gt;n = n; clk = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0, match[i] = 0; &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; queue&lt;int&gt; Q; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i; memset(Type, -1, sizeof(Type)); Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125; int work() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) if (!match[i]) ans += Augument(i); return ans; &#125;&#125; match;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, e; scanf("%d%d%d", &amp;n, &amp;m, &amp;e); match.init(n + 3 * m); for (int i = 0; i &lt; m; i++) match.addEdge(n + i * 3 + 1, n + i * 3 + 2); for (int i = 0, u, v; i &lt; e; i++) &#123; scanf("%d%d", &amp;u, &amp;v); match.addEdge(u, n + (v - 1) * 3 + 1); match.addEdge(u, n + (v - 1) * 3 + 2); match.addEdge(u, n + (v - 1) * 3 + 3); &#125; int ans = match.work(); printf("%d\n", ans - n); for (int i = 1; i &lt;= n; i++) printf("%d ", (match.match[i] - n - 1) / 3 + 1); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>一般图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019ICPC南京网络赛]]></title>
    <url>%2F2019%2F10%2F28%2F2019ICPC%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[C-Tsy’s number 5题意计算 $$\sum^n_{i=1} \sum^n_{j=1} \phi(i) \phi(j) 2^{\phi(i) \phi(j)}$$。 结果模 $998244353$。 $1 \leq n \leq 1e5$ 分析设 $f_i = \sum^n_{k=1}[\phi(k) = i]$，即为 $1$ 到 $n$ 中 $\phi$ 为 $i$ 的个数。 $$\begin{aligned}\sum^n_{i=1} \sum^n_{j=1} \phi(i) \phi(j) 2^{\phi(i) \phi(j)} &amp;= \sum^n_{i=1} \sum^n_{j=1}ijf_if_j2^{ij} \\&amp;= 2\sum^n_{i=1} \sum^i_{j=1}ijf_if_j2^{ij} - \sum^n_{i=1}i^2f_i^22^{i^2} \\&amp;= 2\sum^n_{i=1} if_i\sum^i_{j=1}jf_j (\sqrt2)^{i^2 + j^2 - (i - j)^2} - \sum^n_{i=1}i^2f_i^22^{i^2} \\&amp;= 2\sum^n_{i=1} if_i(\sqrt2)^{i^2}\sum^i_{j=1}jf_j (\sqrt2)^{j^2}(\sqrt2)^{ - (i - j)^2} - \sum^n_{i=1}i^2f_i^22^{i^2} \\\end{aligned}$$ 然后就可以直接 $NTT$ 了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;using ll = long long;const int maxn = 1e6 + 5;bool vis[maxn];int prime[maxn], phi[maxn];int f[maxn];void CalPhi(int n) &#123; memset(vis, 0, sizeof(vis)); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125; memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; i++) f[phi[i]]++;&#125;ll Pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;namespace ntt &#123;int Pow(int a, int b, int p) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1LL * ret * a % p; a = 1LL * a * a % p; b &gt;&gt;= 1; &#125; return ret;&#125;const int mod = 119 &lt;&lt; 23 | 1;const int G = 3;int wn[20];void getwn() &#123; // 千万不要忘记 for (int i = 0; i &lt; 20; i++) wn[i] = Pow(G, (mod - 1) / (1 &lt;&lt; i), mod);&#125;void change(int y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;void ntt(int y[], int len, int on) &#123; change(y, len); for (int h = 2, id = 1; h &lt;= len; h &lt;&lt;= 1, id++) &#123; for (int j = 0; j &lt; len; j += h) &#123; int w = 1; for (int k = j; k &lt; j + h / 2; k++) &#123; int u = y[k] % mod; int t = 1LL * w * (y[k + h / 2] % mod) % mod; y[k] = (u + t) % mod, y[k + h / 2] = ((u - t) % mod + mod) % mod; w = 1LL * w * wn[id] % mod; &#125; &#125; &#125; if (on == -1) &#123; // 原本的除法要用逆元 int inv = Pow(len, mod - 2, mod); for (int i = 1; i &lt; len / 2; i++) swap(y[i], y[len - i]); for (int i = 0; i &lt; len; i++) y[i] = 1LL * y[i] * inv % mod; &#125;&#125;// /*int A[maxn], B[maxn];void multiply(int x[], int y[], int n, int m) &#123; // n,m 表示长度 （阶数要加一） int len = 1; while (len &lt;= (m + n)) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) A[i] = B[i] = 0; for (int i = 0; i &lt;= n; i++) A[i] = x[i]; for (int i = 0; i &lt;= m; i++) B[i] = y[i]; ntt(A, len, 1); ntt(B, len, 1); for (int i = 0; i &lt; len; i++) x[i] = 1LL * A[i] * B[i] % mod; ntt(x, len, -1);&#125;// */&#125; // namespace nttconst int TWO = 116195171;int x[maxn], y[maxn];ll work(int n) &#123; for (ll i = 0; i &lt; n; i++) x[i] = (i + 1) * f[i + 1] % mod * Pow(TWO, (i + 1) * (i + 1)) % mod; for (ll i = 0; i &lt; n; i++) y[i] = Pow(Pow(TWO, i * i), mod - 2); ntt::multiply(x, y, n - 1, n - 1); ll ret = 0; for (ll i = 1; i &lt;= n; i++) ret = ret + i * f[i] % mod * Pow(TWO, i * i) % mod * x[i - 1] % mod; return ret;&#125;int main() &#123; ntt::getwn(); int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); CalPhi(n); ll ans = 2LL * work(n) % mod; for (ll i = 1; i &lt;= n; i++) ans = (ans - i * i % mod * f[i] % mod * f[i] % mod * Pow(2, i * i) % mod + mod) % mod; printf("%lld\n", ans); &#125;&#125; I-Washing clothes题意有 $n$ 个人，每个人都带着一件要洗的衣服在 $t_i$ 的时刻到达洗衣房。洗衣房内只有一个洗衣机，一次只能洗一件衣服。每个人都可以选择机洗或手洗，机洗所用时间为 $x$，手洗所用时间为 $y$。请输出当 $x \in [1,y]$ 时，所对应洗完所有衣服的最短时间。 $1 \leq N,y \leq 10^6$ $0 \leq t_i \leq 10^9$ 分析对于每个确定的 $x$，一定存在一个位置 $p$，使得小于 $p$ 位置的都手洗，大于等于 $p$ 位置的都机洗。 用数学语言表示： $f(i) = t_i + y$：表示第 $i$ 个人手洗结束的时间 $g(i) = t_i + (n - i + 1) \times x$：表示从第 $i$ 个人开始机洗所用的最短时间。 $h(i) = max(h(i+1), g(i))$：表示 $g$ 的后缀最大值。 那么答案为 $ans = min{max(f(i-1), h(i))}$。 观察发现： $f$ 是单调递增的，$h$ 是单调递减的，那么 $ans$ 实际上就是下凸壳的最小值。并且随着 $x$ 的增大，最值的位置逐渐右移。 考虑位置 $p$： 如果有 $t_p + (n - p + 1) \times x &gt; t_p + y$，那么极值点一定在 $p$ 的左边。 那么我们可以算出满足 $t_p + (n - p + 1) \times x \leq t_p + y$ 的位置 $p$。 $p = n + 1 - \frac{y}{x}$ 那么极值点一定是在 $p$ 之后取。我们发现 $\frac{y}{x}$ 这部分实际上是个调和级数，因此可以暴力计算。总的复杂度为 $n\log(n)$。 代码12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 6;using ll = long long;const ll INF = 1e18;int t[maxn];ll h[maxn];int main() &#123; int n, y; while (~scanf("%d%d", &amp;n, &amp;y)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", t + i); sort(t + 1, t + 1 + n); t[0] = -y; h[n + 1] = -INF; for (int x = 1; x &lt;= y; x++) &#123; int p = max(1, n + 1 - y / x); ll ans = INF; for (int j = n; j &gt;= p; j--) h[j] = max(h[j + 1], t[j] + 1LL * (n - j + 1) * x); for (int j = n; j &gt;= p; j--) ans = min(ans, max(h[j], (ll)t[j - 1] + y)); printf("%lld%c", ans, x == y ? '\n' : ' '); &#125; &#125;&#125;/*y &lt; (n - p + 1) * x;p &lt; n + 1 - y / x*/]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的匹配算法]]></title>
    <url>%2F2019%2F10%2F27%2F%E5%9B%BE%E7%9A%84%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[参考文献：IOI国家集训队2015年论文——《浅谈图的匹配算法及其应用》。 增广路设 $P$ 为图中一条简单路径，如果满足： $P$ 的起点和重点都是未盖点 $P$ 中的边中匹配边和非匹配边交错出现。 则称 $P$ 是一条增广路。 特别地，我们把满足条件 $2$ 的简单路径称为交替路。 增广：增广路上非匹配边数量比匹配边数量多 $1$，如果把这条路径取反，则当前匹配大小会增加 $1$。这个过程称为增广。 定理：一个匹配 $M$ 是图 $G$ 的最大匹配，充要条件是 $G$ 中不存在增广路。 二分图最大匹配Dinic你肯定会的 时间复杂度 $O(E \sqrt{V})$ 增广路算法（匈牙利）因为增广路的长度为奇数，所以路径的起点和终点一定分居在二分图左右两侧，不妨从左边的每个未盖点找增广路。 注意到增广路上第奇数次走的是非匹配边，第偶数次走的是匹配边。这说明从左到右走的都是非匹配边，从右到左走的都是匹配边。 枚举左边每一个未盖点 $u$ ，从 $u$ 开始 $DFS$，每个点记录一个访问标记，以保证至多访问一次，当找到右侧某个未盖点时结束遍历。 找一次增广路的复杂度为 $O(E)$，枚举未盖点的复杂度是 $O(V)$，因此总复杂度为 $O(VE)$。 1234567891011121314151617181920212223242526272829303132// O(VE)struct MaxMatch &#123; int n, clk; vector&lt;int&gt; G[maxn]; int vis[maxn], ls[maxn], rs[maxn]; void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt; n; i++) G[i].clear(); memset(rs, -1, sizeof(rs)); memset(ls, -1, sizeof(ls)); memset(vis, -1, sizeof(vis)); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); &#125; bool dfs(int u) &#123; for (auto &amp;v : G[u]) &#123; if (vis[v] == clk) continue; vis[v] = clk; if (rs[v] == -1 || dfs(rs[v])) &#123; ls[u] = v; rs[v] = u; return true; &#125; &#125; return false; &#125; int match() &#123; int ret = 0; for (clk = 0; clk &lt; n; clk++) if (dfs(clk)) ++ret; return ret; &#125;&#125;; 二分图最大匹配关键点关键点：一定在最大匹配中的点。 先求任意一个最大匹配 $M$，要找的关键点此时一定都是匹配点。考虑 $M$ 中的一个匹配点 $p$，设 $M’$ 为某个不包含 $p$ 的最大匹配。设对称差 $D = M \bigoplus M’$ ，则 $D$ 中一定存在一条以 $p$ 为端点的偶交替链，且这条链的另一端不在 $M$ 中。 所以我们给二分图定向：匹配边从右到左，非匹配边从左到右。从左侧每个未盖点出发 $DFS$，给所到达的左侧点打上标记。最终左侧每个没有标记的匹配点即为关键点。 因为每个点最多访问一次，因此复杂度为 $O(V + E)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct MaxMatch &#123; int n, m, clk; vector&lt;int&gt; G[maxn], rG[maxn]; int vis[maxn], ls[maxn], rs[maxn]; void init(int n, int m) &#123; this-&gt;n = n, this-&gt;m = m; for (int i = 0; i &lt; n; i++) G[i].clear(); for (int i = 0; i &lt; m; i++) rG[i].clear(); memset(rs, -1, sizeof(rs)); memset(ls, -1, sizeof(ls)); memset(vis, -1, sizeof(vis)); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); rG[v].push_back(u); &#125; bool dfs(int u) &#123; for (auto &amp;v : G[u]) &#123; if (vis[v] == clk) continue; vis[v] = clk; if (rs[v] == -1 || dfs(rs[v])) &#123; ls[u] = v; rs[v] = u; return true; &#125; &#125; return false; &#125; int match() &#123; int ret = 0; for (clk = 0; clk &lt; n; clk++) if (dfs(clk)) ++ret; return ret; &#125; // --------------------------------------- bool lskp[maxn], rskp[maxn]; void dfs_kp_ls(int u) &#123; vis[u] = 1; for (auto &amp;v : G[u]) &#123; if (rs[v] == -1 || vis[rs[v]]) continue; dfs_kp_ls(rs[v]); &#125; &#125; void dfs_kp_rs(int u) &#123; vis[u] = 1; for (auto &amp;v : rG[u]) &#123; if (ls[v] == -1 || vis[ls[v]]) continue; dfs_kp_rs(ls[v]); &#125; &#125; int findKeyPoint() &#123; // match(); memset(lskp, 0, sizeof(lskp)); memset(rskp, 0, sizeof(rskp)); memset(vis, 0, sizeof(vis)); int ret = 0; for (int i = 0; i &lt; n; i++) if (ls[i] == -1) dfs_kp_ls(i); for (int i = 0; i &lt; n; i++) if (!vis[i]) lskp[i] = 1, ret++; memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; m; i++) if (rs[i] == -1) dfs_kp_rs(i); for (int i = 0; i &lt; m; i++) if (!vis[i]) rskp[i] = 1, ret++; return ret; &#125;&#125;; 二分图最大匹配关键边关键边：一定在最大匹配中的边 先求任意一个最大匹配 $M$，要找的关键边此时一定都是匹配边。考虑 $M$ 中的一个匹配边 $e$，设 $M’$ 为某个不包含 $e$ 的最大匹配。设对称差 $D = M \bigoplus M’$ ，则 $e$ 在 $D$ 中一定属于一个偶交替链或偶交替环。 对于 $e$ 属于一个偶交替链的情况：那么这条链的某一端一定是未盖点。说明 $e$ 的某个端点能通过交替路走到未盖点，即某个端点是非关键点。因此只需判断 $e$ 的两个端点是否存在非关键点。若存在，则 $e$ 为非关键边。 对于 $e$ 属于一个偶交替环的情况：我们给二分图定向：匹配边从左到右，非匹配边从右到左，再检测 $e$ 是否存在于某个环中（二分图不存在奇环）。这用 $Tarjan$ 求强连通分量即可。 所以时间复杂度为 $O(V + E)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142struct Tarjan &#123; vector&lt;int&gt; G[maxn]; int scc, dfs_clock, top; // scc: 强连通分量的数量 bool instack[maxn]; int dfn[maxn], low[maxn], belong[maxn], Stack[maxn]; void tarjan(int u) &#123; dfn[u] = low[u] = ++dfs_clock; instack[u] = true; Stack[top++] = u; for (auto &amp;v : G[u]) &#123; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (instack[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; ++scc; int cnt = 0; int now; while (top &gt; 0) &#123; now = Stack[--top]; instack[now] = false; belong[now] = u; ++cnt; if (now == u) break; &#125; &#125; &#125; void solve(int n) &#123; memset(instack, 0, sizeof(instack)); memset(dfn, 0, sizeof(dfn)); scc = dfs_clock = top = 0; for (int i = 0; i &lt; n; i++) &#123; if (!dfn[i]) tarjan(i); &#125; &#125;&#125; tarjan;// n+mstruct MaxMatch &#123; int n, m, clk; vector&lt;int&gt; G[maxn], rG[maxn]; int vis[maxn], ls[maxn], rs[maxn]; void init(int n, int m) &#123; this-&gt;n = n, this-&gt;m = m; for (int i = 0; i &lt; n; i++) G[i].clear(); for (int i = 0; i &lt; m; i++) rG[i].clear(); memset(rs, -1, sizeof(rs)); memset(ls, -1, sizeof(ls)); memset(vis, -1, sizeof(vis)); edges.clear(); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); rG[v].push_back(u); edges.push_back(&#123;u, v&#125;); &#125; bool dfs(int u) &#123; for (auto &amp;v : G[u]) &#123; if (vis[v] == clk) continue; vis[v] = clk; if (rs[v] == -1 || dfs(rs[v])) &#123; ls[u] = v; rs[v] = u; return true; &#125; &#125; return false; &#125; int match() &#123; int ret = 0; for (clk = 0; clk &lt; n; clk++) if (dfs(clk)) ++ret; return ret; &#125; // --------------------------------------- bool lskp[maxn], rskp[maxn]; void dfs_kp_ls(int u) &#123; vis[u] = 1; for (auto &amp;v : G[u]) &#123; if (rs[v] == -1 || vis[rs[v]]) continue; dfs_kp_ls(rs[v]); &#125; &#125; void dfs_kp_rs(int u) &#123; vis[u] = 1; for (auto &amp;v : rG[u]) &#123; if (ls[v] == -1 || vis[ls[v]]) continue; dfs_kp_rs(ls[v]); &#125; &#125; // O(n+m) int findKeyPoint() &#123; // match(); memset(lskp, 0, sizeof(lskp)); memset(rskp, 0, sizeof(rskp)); memset(vis, 0, sizeof(vis)); int ret = 0; for (int i = 0; i &lt; n; i++) if (ls[i] == -1) dfs_kp_ls(i); for (int i = 0; i &lt; n; i++) if (!vis[i]) lskp[i] = 1, ret++; memset(vis, 0, sizeof(vis)); for (int i = 0; i &lt; m; i++) if (rs[i] == -1) dfs_kp_rs(i); for (int i = 0; i &lt; m; i++) if (!vis[i]) rskp[i] = 1, ret++; return ret; &#125; // ----------------------------------------- vector&lt;pair&lt;int, int&gt;&gt; edges; bool ke[maxn]; int findKeyEdge() &#123; findKeyPoint(); memset(ke, 0, sizeof(ke)); for (int i = 0; i &lt; n + m; i++) tarjan.G[i].clear(); for (auto &amp;e : edges) &#123; if (ls[e.first] == e.second) &#123; tarjan.G[e.first].push_back(e.second + n); &#125; else &#123; tarjan.G[e.second + n].push_back(e.first); &#125; &#125; tarjan.solve(n + m); int ret = 0; for (int i = 0; i &lt; edges.size(); i++) &#123; auto e = edges[i]; if (ls[e.first] != e.second) continue; if (!lskp[e.first] || !rskp[e.second]) continue; if (tarjan.belong[e.first] != tarjan.belong[e.second + n]) &#123; ke[i] = 1; ret++; continue; &#125; &#125; return ret; &#125;&#125;; 二分图最大独立集独立集： 给定图 $G=(V,E)$，$V’$ 是 $V$ 的一个非空子集。若 $V’$ 的任何两个顶点 $u,v$ 都不是同一条边的两个端点，则称 $V’$ 是 $G$ 的一个空子图。设 $V’$ 是 $G$ 的空子图，若 $V’$ 任意增加一个 $G$ 中不在 $V’$ 中的点后都不是空子图，则称 $V’$ 是 $G$ 的独立集。$G$ 中所含顶点数最多的独立集 $V’$ 称为 $G$ 的最大独立集。 做法： 设最大独立集为 $V’$。 首先求一个图的最大匹配 $M$，那么所有的未盖点必定都在 $V’$ 中（不然匹配数就会增加）。 然后考虑从每个匹配边中选一个点放到 $V’$ 中，这样 $V’$ 中的点数就是 $|V| - |M|$。 做法很显然：就是从每一个未盖点出发，依次决定路上点是否可以放到 $V’$ 中。 但是这么做可能会遇到矛盾，就是一条边的两个点中一个是未盖点一个是匹配点，但经过上述做法后，这两个点可能都被放入 $V’$ 中。实际上这是不可能的，因为我们发现如果有这种情况存在，那么必定存在一条奇数长度增广路，使得当前匹配并不是最大匹配，这与 $M$ 是最大匹配矛盾。 因此 $|V’| = |V| - |M|$。 若要输出方案，则从每个未盖点出发，依次决定路上每个点是否可以放入 $V’$ 即可。复杂度 $O(|V| + |E|)$ 二分图最小点覆盖最小点覆盖是说：选最少的点，满足每条边都至少有一个端点被选。 任意点覆盖的补集都是独立集，任意独立集的补集都是点覆盖。 最小点覆盖 = $V$ - 最大独立集 = 最大匹配 $M$ 一般图最大匹配带花树算法一般图和二分图的唯一区别在于可能存在奇环，这就导致如果我们对奇环进行增广，就会出现某个点同时在两条匹配边上的情况。 观察发现，可以通过把奇环缩点，所得到的新图 $G’$。则 $G$ 中存在增广路 $\Leftrightarrow$ $G’$ 中存在增广路。 所以还是运用增广路算法，在找到奇环时只要进行缩点即可。 时间复杂度 $O(V^3)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879struct MaxMatch &#123; vector&lt;int&gt; G[maxn]; queue&lt;int&gt; Q; int n, clk; int match[maxn], par[maxn]; int Type[maxn], pre[maxn], vis[maxn]; void init(int n) &#123; this-&gt;n = n; clk = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), vis[i] = 0, match[i] = 0; &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int LCA(int x, int y) &#123; clk++; x = par[x], y = par[y]; while (vis[x] != clk) &#123; if (x) &#123; vis[x] = clk; x = par[pre[match[x]]]; &#125; swap(x, y); &#125; return x; &#125; void blossom(int x, int y, int lca) &#123; while (par[x] != lca) &#123; pre[x] = y; y = match[x]; if (Type[y] == 1) &#123; Type[y] = 0; Q.push(y); &#125; par[x] = par[y] = par[lca]; x = pre[y]; &#125; &#125; int Augument(int s) &#123; for (int i = 1; i &lt;= n; i++) par[i] = i, Type[i] = -1; Q = queue&lt;int&gt;(); Type[s] = 0; Q.push(s); while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (auto &amp;v : G[u]) &#123; if (Type[v] == -1) &#123; pre[v] = u; Type[v] = 1; if (!match[v]) &#123; for (int to = v, from = u; to; from = pre[to]) &#123; match[to] = from; swap(match[from], to); &#125; return true; &#125; Type[match[v]] = 0; Q.push(match[v]); &#125; else if (Type[v] == 0 &amp;&amp; par[u] != par[v]) &#123; int lca = LCA(u, v); blossom(u, v, lca); blossom(v, u, lca); &#125; &#125; &#125; return false; &#125; int work() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) // 注意匹配顺序 if (!match[i]) ans += Augument(i); return ans; &#125;&#125; match; 匹配顺序带花树在匹配数不增加时不会丢弃之前已经匹配的边。因此对于某些题目在匹配时要注意匹配顺序。 建图技巧一般图匹配最大的特点在于存在奇环。且奇环中未匹配的边数一定比匹配的边数大 $1$。 例题奇环性质挑战NPC 棋盘模型（交替路的理解）zoj3316hdu3446 生成指定度数的子图hdu3551 二分图最大权匹配一般图最大权匹配]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图的匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的绝对中心]]></title>
    <url>%2F2019%2F10%2F25%2F%E5%9B%BE%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[图的绝对中心图的绝对中心指的是到图中所有结点最远距离最小的点。这个点可能是图中的某个结点或在某边上。 根据定义可以看出，到绝对中心距离最远的结点至少有两个。 设 $d[i][j]$ 为结点 $i$ 到结点 $j$ 的最短距离（预处理）。 考虑绝对中心 $center$ 在边 $(u,v)$ 上 （$u = v$ 时即为结点）。 那么结点 $i$ 到 $center$ 的距离函数图像即为： 那么对于所有结点到 $center$ 的距离函数图像即为： 可以发现，实线部分的最低点就是我们要求的绝对中心。因此我们只需要枚举所有边和点，然后计算相应答案的最小值即可。 接下来就是如何计算上图中的最低点了。 首先我们发现对于 $d[u][i] \leq d[u][j], d[v][i] \leq d[v][j]$，$i$ 点是不会对答案有贡献的，因此可以去掉。 将所有没有贡献的点去掉后，因为所有折线的斜率的绝对值相同，所以如果我们按照 $d[u][i]$ 进行从小到大排序的话，$d[v][i]$ 的值一定是递减的。然后我们就可以通过顺序枚举两折线交点找到答案。 总的时间复杂度为 $O(n^3 + n(m+n))$ 或 $O(nm\log n + n(m + n))$。区别在于预处理 $d[i][j]$ 的方式。 应用最小直径生成树只要求出图的绝对中心即可，最小直径即为到图的绝对中心的最远距离乘二。因为到绝对中心距离最远的结点至少有两个。 至于生成树只要记录一下绝对中心的位置，然后跑一个最短路树即可。 例题spoj1479 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205;const int INF = 0x3f3f3f3f;int n, m;int d[maxn][maxn], w[maxn][maxn];int rk[maxn][maxn];int ans, cu, cv;double dis[maxn];void floyd() &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) d[j][k] = min(d[j][k], d[j][i] + d[i][k]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) rk[i][j] = j; sort(rk[i] + 1, rk[i] + 1 + n, [&amp;](const int &amp;a, const int &amp;b) &#123; return d[i][a] &lt; d[i][b]; &#125;); &#125;&#125;void solve(int u, int v) &#123; vector&lt;pair&lt;int, int&gt;&gt; tmp, vec; for (int i = 1; i &lt;= n; i++) tmp.push_back(&#123;d[u][rk[u][i]], d[v][rk[u][i]]&#125;); for (int i = 0; i &lt; tmp.size(); i++) &#123; while (!vec.empty() &amp;&amp; vec.back().second &lt;= tmp[i].second) vec.pop_back(); vec.push_back(tmp[i]); &#125; int D = INF; // 直径 double a; // 绝对中心距离u点的偏移 if (vec.size() == 1) &#123; if (vec[0].first &lt; vec[0].second) &#123; a = 0; D = 2 * vec[0].first; &#125; else &#123; a = w[u][v]; D = 2 * vec[0].second; &#125; &#125; else &#123; for (int i = 1; i &lt; vec.size(); i++) &#123; if (D &gt; w[u][v] + vec[i - 1].first + vec[i].second) &#123; a = (w[u][v] + vec[i].second - vec[i - 1].first) / 2.0; D = w[u][v] + vec[i - 1].first + vec[i].second; &#125; &#125; &#125; if (D &lt; ans) &#123; ans = D; cu = u, cv = v; dis[u] = a; dis[v] = w[u][v] - a; &#125;&#125;int path[maxn];void dij() &#123; for (int i = 1; i &lt;= n; i++) if (i != cu &amp;&amp; i != cv) dis[i] = 1e9; priority_queue&lt;pair&lt;double, int&gt;, vector&lt;pair&lt;double, int&gt;&gt;, greater&lt;pair&lt;double, int&gt;&gt;&gt; pq; pq.push(&#123;dis[cu], cu&#125;); pq.push(&#123;dis[cv], cv&#125;); path[cu] = path[cv] = -1; while (!pq.empty()) &#123; auto it = pq.top(); pq.pop(); int u = it.second; if (it.first &gt; dis[u]) continue; for (int v = 1; v &lt;= n; v++) &#123; if (v != u &amp;&amp; w[u][v] &lt; INF &amp;&amp; dis[u] + w[u][v] &lt; dis[v]) &#123; dis[v] = dis[u] + w[u][v]; path[v] = u; pq.push(&#123;dis[v], v&#125;); &#125; &#125; &#125; if (cu != cv) &#123; if (cu &gt; cv) swap(cu, cv); printf("%d %d\n", cu, cv); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (path[i] != -1) &#123; int u = i, v = path[i]; if (u &gt; v) swap(u, v); printf("%d %d\n", u, v); &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); memset(d, 0x3f, sizeof(d)); memset(w, 0x3f, sizeof(w)); for (int i = 1; i &lt;= n; i++) d[i][i] = 0, w[i][i] = 0; for (int i = 0, u, v, x; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;x); d[u][v] = d[v][u] = min(d[u][v], x); w[u][v] = w[v][u] = min(w[u][v], x); &#125; floyd(); ans = INF; for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) &#123; if (w[i][j] &lt; INF) solve(i, j); &#125; printf("%d\n", ans); dij();&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图的绝对中心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Mid-Central Regional]]></title>
    <url>%2F2019%2F10%2F23%2F2018-ICPC-Mid-Central-Regional%2F</url>
    <content type="text"><![CDATA[I - Random Manhattan Distance题意给定 $n$ 个点的凸包，问从凸包内任选两点，其曼哈顿距离的期望是多少。 $3 \leq n \leq 100000$ 分析首先两维是独立的，对于任意一维来说： 设凸包面积为 $S$。 设 $weight(x) = leftHeight + x \times \frac{(rightHeight - leftHeight)}{width}$，表示所选点落在 $x$ 位置的概率乘 $S$（这里是为了减小误差，最后再除掉即可。先当作概率来理解）。 因为这个概率密度函数 $weight(x)$ 是个分段函数，每一段对应一个梯形（扫描线从左到右扫过去）。因此我们将答案分为两部分来算，第一部分是当前梯形所对应的区间内任选两点的贡献；第二部分是当前梯形所对应的区间内选一点，之前计算过的区间内选一点，这两个点的贡献。 第一部分的答案就是 $2\times \int_{x=0}^{w} \int_{y=0}^{x} weight(x) \times weight(y) \times (x - y) dydx$ 积分全靠 $wolframalpha$… 第二部分的答案是当前梯形所对应区间的期望位置和之前区域的期望位置之差。 当前期望位置的计算：$current_x + E(x) =current_x + \int_0^w x \times (\frac{weight(x)}{area})$ 之前区域期望位置的计算：$\frac{E_0 \times area_0+ E_1 \times area_1 + …}{area_0 + area_1 + …}$ 期望计算公式：$E(g(X)) = \int g(x)f(x) dx$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100000;const long long INF = 1000000000;struct Point &#123; long long x, y; Point() &#123;&#125; Point(long long x, long long y) : x(x), y(y) &#123;&#125;&#125;;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y;&#125;Point operator-(const Point&amp; a, const Point&amp; b) &#123; return Point(a.x - b.x, a.y - b.y);&#125;long long det(const Point&amp; a, const Point&amp; b) &#123; return a.x * b.y - a.y * b.x; &#125;struct Zone &#123; double width, leftHeight, rightHeight; Zone() &#123;&#125; Zone(double width, double leftHeight, double rightHeight) : width(width), leftHeight(leftHeight), rightHeight(rightHeight) &#123;&#125;&#125;;double getHeight(const vector&lt;Point&gt;&amp; a, long long x, int i, int j) &#123; if (a[i].x == x) &#123; return a[i].y; &#125; if (a[j].x == x) &#123; return a[j].y; &#125; double slope = (a[j].y - a[i].y) / (double)(a[j].x - a[i].x); return a[i].y + slope * (x - a[i].x);&#125;double solve(vector&lt;Point&gt;&amp; a) &#123; int n = a.size(); for (int i = 0; i &lt; n; ++i) &#123; const Point&amp; x = a[i]; const Point&amp; y = a[(i + 1) % n]; const Point&amp; z = a[(i + 2) % n]; assert(det(z - y, y - x) &gt; 0); &#125; int upper_ptr = min_element(a.begin(), a.end()) - a.begin(); // in the +1 direction int lower_ptr = upper_ptr; // in the -1 direction vector&lt;Zone&gt; zones; while (true) &#123; int upper_next = (upper_ptr + 1) % n; int lower_next = (lower_ptr - 1 + n) % n; long long current_x = max(a[upper_ptr].x, a[lower_ptr].x); if (current_x == a[upper_next].x) &#123; upper_ptr = upper_next; continue; &#125; if (current_x == a[lower_next].x) &#123; lower_ptr = lower_next; continue; &#125; long long next_x = min(a[upper_next].x, a[lower_next].x); if (next_x &lt; current_x) &#123; break; &#125; double leftHeight = getHeight(a, current_x, upper_ptr, upper_next) - getHeight(a, current_x, lower_ptr, lower_next); double rightHeight = getHeight(a, next_x, upper_ptr, upper_next) - getHeight(a, next_x, lower_ptr, lower_next); zones.push_back(Zone(next_x - current_x, leftHeight, rightHeight)); // fprintf(stderr, "%lld -&gt; %lld\n", current_x, next_x); if (next_x == a[upper_next].x) &#123; upper_ptr = upper_next; &#125; if (next_x == a[lower_next].x) &#123; lower_ptr = lower_next; &#125; &#125; double s = 0, a2 = 0, current_x = 0; double sum_area_x = 0, sum_area = 0; for (Zone zone : zones) &#123; // Within the zone // x from 0..width // weight(x) = leftHeight + x * (rightHeight - leftHeight) / width // \int_&#123;x=0&#125;^&#123;w&#125; \int_&#123;y=0&#125;^&#123;x&#125; weight(x) * weight(y) * (x - y) dx, dy s += (zone.leftHeight * zone.leftHeight + 3 * zone.leftHeight * zone.rightHeight + zone.rightHeight * zone.rightHeight) * zone.width * zone.width * zone.width / 15; double area = (zone.leftHeight + zone.rightHeight) * zone.width / 2; // E[x] with in this zone double expected_x = current_x + (zone.leftHeight + 2 * zone.rightHeight) / (3 * (zone.leftHeight + zone.rightHeight)) * zone.width; if (sum_area &gt; 0) &#123; // for the left zones s += 2 * (expected_x - sum_area_x / sum_area) * sum_area * area; &#125; a2 += area * (2 * sum_area + area); // S^2 sum_area += area; sum_area_x += expected_x * area; current_x += zone.width; &#125; return s / a2;&#125;int main() &#123; int n; assert(scanf("%d", &amp;n) == 1); assert(3 &lt;= n &amp;&amp; n &lt;= MAXN); vector&lt;Point&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; assert(scanf("%lld%lld", &amp;a[i].x, &amp;a[i].y) == 2); assert(abs(a[i].x) &lt;= INF); assert(abs(a[i].y) &lt;= INF); &#125; double ret = solve(a); for (int i = 0; i &lt; a.size(); ++i) &#123; swap(a[i].x, a[i].y); &#125; reverse(a.begin(), a.end()); // make sure it's in the counter-clockwise order ret += solve(a); printf("%.10f\n", ret); return 0;&#125; J - Mobilization题意给定 $n$ 种物品，每种物品都有两个属性$h_i,p_i$和一个价格$c_i$，每种物品都有无限个。你现在拥有 $b$ 元钱。定义最终的价值为所购买所有物品 $h$ 的总和乘以 $p$ 的总和。 求最大价值。每种物品可以买分数个。 $1 \leq n \leq 30000, 1 \leq b \leq 100000$ 分析先求出对于每种物品，每花一元钱可以获得的 $(h,p)$。这可以看成二维平面上的若干点。 这些点的任意组合：$f = k_1 \times (h_1,p_1) + k_2 \times (h_2,p_2) + k_3 \times (h_3,p_3)… $。 因为有限制 $k_1 + k_2 + … + k_n = 1$。所以 $f$ 一定在这些点组成的凸包内。 而我们最终的价值实际上可以看作是 $f$ 与原点围成的矩形面积，因此得到答案必在凸包的边界上。 然后我们只要枚举凸包的边界，计算最值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using db = long double;struct Point &#123; db x, y; Point(db x = 0, db y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vector;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;Vector operator+(Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator-(Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;Vector operator*(Point A, db p) &#123; return Vector(A.x * p, A.y * p); &#125;const db eps = 1e-12;db dcmp(db x) &#123; if (fabs(x) &lt; eps) &#123; return 0; &#125; return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;db Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;typedef std::vector&lt;Point&gt; Polygon;Polygon ConvexHull(std::vector&lt;Point&gt; p) &#123; std::sort(p.begin(), p.end()); p.erase(std::unique(p.begin(), p.end()), p.end()); int n = p.size(), m = 0; Polygon res(n + 1); for (int i = 0; i &lt; n; i++) &#123; while (m &gt; 1 &amp;&amp; Cross(res[m - 1] - res[m - 2], p[i] - res[m - 2]) &lt;= 0) m--; res[m++] = p[i]; &#125; int k = m; for (int i = n - 2; i &gt;= 0; i--) &#123; while (m &gt; k &amp;&amp; Cross(res[m - 1] - res[m - 2], p[i] - res[m - 2]) &lt;= 0) m--; res[m++] = p[i]; &#125; m -= n &gt; 1; res.resize(m); return res;&#125;Point GetLineInterSection(Point P, Vector v, Point Q, Vector w) &#123; Vector u = P - Q; db t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;bool checkLL(Vector v, Vector w) &#123; return dcmp(Cross(v, w)) == 0; &#125;db cal(Point x)&#123; return x.x * x.y;&#125;int main() &#123; int n, b; scanf("%d%d", &amp;n, &amp;b); db x, y; std::vector&lt;Point&gt; points; for (int i = 0, c; i &lt; n; i++) &#123; scanf("%d%Lf%Lf", &amp;c, &amp;x, &amp;y); points.emplace_back(x * b / c, y * b / c); &#125; auto poly = ConvexHull(points); db ans = -1; int sz = poly.size(); for(int i=0;i&lt;sz;i++)&#123; auto p1 = poly[i]; auto p2 = poly[(i + 1) % sz]; ans = std::max(ans, cal(p1)); ans = std::max(ans, cal(p2)); if(dcmp(p1.x - p2.x) != 0 &amp;&amp; dcmp(p1.y - p2.y) != 0) &#123; db tmpx = p1.x / 2 - p1.y * (p2.x - p1.x) / (2 * (p2.y - p1.y)); db tmpy = p1.y / 2 - p1.x * (p2.y - p1.y) / (2 * (p2.x - p1.x)); if(tmpx &gt;= std::min(p1.x,p2.x) &amp;&amp; tmpx &lt;= std::max(p1.x, p2.x))&#123; ans = std::max(ans, tmpx * tmpy); &#125; &#125; &#125; printf("%.10Lf\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 China Collegiate Programming Contest Qinhuangdao Onsite]]></title>
    <url>%2F2019%2F10%2F15%2F2019-China-Collegiate-Programming-Contest-Qinhuangdao-Onsite%2F</url>
    <content type="text"><![CDATA[比赛链接 G. Game on Chessboard题意给定一个 $n\times n$ 的棋盘，每个格子上有三种取值 W，B，.。每个格子都有一个对应权值 $a_{ij}$。且 . 的权值一定为 $0$。从格子上拿走对应元素需要付出对应权值的代价。问将所有格子都拿走需要付出的最小代价。 有一种特殊的操作是：可以同时拿一个W，和一个B。前提是这两个棋子左下部分都不存在棋子。这样做的花费是其权值差的绝对值。 $1 \leq n \leq 12$ 分析 观察发现，只有图中涂绿色的块可以消消乐。而只拿一个块的也话也只会拿绿色的块，因为只有拿了绿色的块，才会有更多的块可以消消乐。因此决策点就是是否拿绿色的块（角块）。 状态表示可以用红色的轮廓线来表示，比如竖直的是 $0$，水平的是 $1$。图中的状态就可以表示为 $01001011$。 每次的决策就是枚举消消乐，再枚举单独拿一个块的转移。 最后快乐 $dp$ 即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1 &lt;&lt; 24) + 5;char maze[15][15];int a[15][15];int dp[maxn];int n;struct Node &#123; int r, c, pos;&#125;;int dfs(int stat) &#123; if (dp[stat] != -1) return dp[stat]; int r = 0, c = 0, szb = 0, szw = 0; int &amp;ret = dp[stat]; ret = 1e9; Node B[25], W[25]; for (int i = 2 * n - 1; i &gt; 0; i--) &#123; if (!(stat &gt;&gt; i &amp; 1) &amp;&amp; (stat &gt;&gt; (i - 1) &amp; 1)) &#123; int nxt = stat ^ (3 &lt;&lt; (i - 1)); ret = min(ret, dfs(nxt) + a[r][c]); if (maze[r][c] == 'B') B[szb++] = &#123;r, c, i&#125;; if (maze[r][c] == 'W') W[szw++] = &#123;r, c, i&#125;; &#125; if (stat &gt;&gt; i &amp; 1) c++; else r++; &#125; for (int i = 0; i &lt; szb; i++) &#123; int ip = B[i].pos, ir = B[i].r, ic = B[i].c; int tmp = stat ^ (3 &lt;&lt; (ip - 1)); for (int j = 0; j &lt; szw; j++) &#123; int jp = W[j].pos, jr = W[j].r, jc = W[j].c; int nxt = tmp ^ (3 &lt;&lt; (jp - 1)); ret = min(ret, dfs(nxt) + abs(a[jr][jc] - a[ir][ic])); &#125; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%s", maze[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%d", &amp;a[i][j]); memset(dp, -1, sizeof(dp)); int s = (1 &lt;&lt; n) - 1; int t = s &lt;&lt; n; dp[t] = 0; int ans = dfs(s); printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 German Collegiate Programming Contest (GCPC 19)]]></title>
    <url>%2F2019%2F10%2F14%2F2019-German-Collegiate-Programming-Contest-GCPC-19%2F</url>
    <content type="text"><![CDATA[K - Keeping the Dogs Out题意给定若干边长为 $2$ 的幂次的小正方形，问是否能拼成一个矩形，如果可以的话输出其长和宽。保证矩形面积小于 $10^15$。 分析因为保证了矩形面积，因此可以枚举长和宽（因子个数的数量级为 $\log$）。 设枚举的长和宽分别为 $a,b (a &lt; b)$。 设所有边长 $\geq 2^i$ 的小正方形的面积和 $sum_i$。 如果矩形只用 $\geq 2^i$ 的小正方形，那么其面积为 $area_i = \lfloor \frac{a}{2^i} \rfloor \times 2^i \times \lfloor \frac{b}{2^i} \rfloor \times 2^i$ 如果 $a,b$ 合法，那么对于每个 $i$，必须有 $sum_i \leq area_i$。（如果 $sum_i &lt; area_i$，那么空余的面积可以用边长小于 $2^i$ 的小正方形来填充。） 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll m[30], suf[30], pow2[30];int main() &#123; int n; cin &gt;&gt; n; ll area = 0, tmp = 1; for (int i = 0; i &lt;= n; i++) cin &gt;&gt; m[i], area += m[i] * tmp, tmp *= 4; for (int i = n; i &gt;= 0; i--) tmp /= 4, suf[i] = suf[i + 1] + m[i] * tmp; pow2[0] = 1; for (int i = 1; i &lt;= n; i++) pow2[i] = pow2[i - 1] * 2; ll sqa = sqrt(area); for (ll i = 1; i &lt;= sqa; i++) &#123; if (area % i) continue; ll a = i, b = area / i; bool ok = true; for (int j = 0; j &lt;= n; j++) &#123; if (!m[j]) continue; if (a &lt; pow2[j] || b &lt; pow2[j]) &#123; ok = false; break; &#125; ll tmpa = a / pow2[j] * pow2[j], tmpb = b / pow2[j] * pow2[j]; if (tmpa * tmpb &lt; suf[j]) &#123; ok = false; break; &#125; &#125; if (ok) &#123; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; "impossible" &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>GCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Asia Yokohama Regional Contest]]></title>
    <url>%2F2019%2F10%2F09%2F2018-ICPC-Asia-Yokohama-Regional-Contest%2F</url>
    <content type="text"><![CDATA[比赛链接 to be continued.]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凸包]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[凸包凸包具体的性质还没来得及好好研究，希望日后可以补上。 模板 from dls. 12345678910111213141516171819202122232425262728293031323334353637struct Point &#123; int x, y; bool operator&lt;(const Point&amp; a) const &#123; if (x == a.x) return y &lt; a.y; return x &lt; a.x; &#125;&#125;;Point operator-(Point a, Point b) &#123; return Point&#123;a.x - b.x, a.y - b.y&#125;; &#125;int Cross(Point A, Point B) &#123; return A.x * B.y - A.y * B.x; &#125;int Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt; ps) &#123; int n = ps.size(), k = 0; if (n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;Point&gt; ret(n * 2); for (int i = 0; i &lt; n; ret[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt;= 0) --k; for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--]) while (k &gt; t &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt;= 0) --k; ret.resize(k - 1); return ret;&#125;vector&lt;Point&gt; ConvexHullNonStrict(vector&lt;Point&gt; ps) &#123; // caution: need to unique the ps first. int n = ps.size(), k = 0; if (n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;Point&gt; ret(n * 2); for (int i = 0; i &lt; n; ret[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt; 0) --k; for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--]) while (k &gt; t &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt; 0) --k; ret.resize(k - 1); return ret;&#125; 旋转卡壳基于凸包的一种算法，具体思想见下图。 平面最远点对参考链接 点对一定在凸包（严格）上。 枚举边，然后找到这条边距离最远的点（叉积最大），那么这个点和当前枚举边的端点就可能是答案。 例题：洛谷1452 123456789101112131415161718Point operator-(Point a, Point b) &#123; return Point&#123;a.x - b.x, a.y - b.y&#125;; &#125;int Cross(Point A, Point B) &#123; return A.x * B.y - A.y * B.x; &#125;int Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;int sqr(int x) &#123; return x * x; &#125;int dis(Point A, Point B) &#123; return sqr(A.x - B.x) + sqr(A.y - B.y); &#125;int work(vector&lt;Point&gt; ps) &#123; if (ps.size() &lt;= 1) return 0; if (ps.size() == 2) return dis(ps[0], ps[1]); ps.push_back(ps[0]); int n = ps.size(), ret = 0; for (int i = 0, j = 2; i &lt; n - 1; i++) &#123; while (Cross(ps[i], ps[i + 1], ps[j]) &lt;= Cross(ps[i], ps[i + 1], ps[j + 1])) (++j) %= (n - 1); ret = max(&#123;ret, dis(ps[i], ps[j]), dis(ps[i + 1], ps[j])&#125;); &#125; return ret;&#125; 平面最大三角形三个顶点一定在凸包（严格）上。但三角形的边不一定是凸包的边！ 例题：hdu2202 123456789101112131415161718192021Point operator-(Point a, Point b) &#123; return Point&#123;a.x - b.x, a.y - b.y&#125;; &#125;ll Cross(Point A, Point B) &#123; return 1LL * A.x * B.y - 1LL * A.y * B.x; &#125;ll Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;double area(Point A, Point B, Point C) &#123; return Cross(A, B, C) * 0.5; &#125;double work(vector&lt;Point&gt; ps) &#123; if (ps.size() &lt;= 2) return 0; ps.push_back(ps[0]); int n = ps.size(); double ret = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int p = i; for (int j = i + 1; j &lt; n - 1; j++) &#123; while (abs(Cross(ps[i], ps[j], ps[p])) &lt;= abs(Cross(ps[i], ps[j], ps[p + 1]))) (++p) %= (n - 1); ret = max(ret, area(ps[i], ps[j], ps[p])); &#125; &#125; return ret;&#125; 最小矩形覆盖参考链接 如图，最小矩形一定有一条边在凸包上。 设 $AB$ 是当前枚举的边，那么 $C$ 一定是点积最大的点，$D$ 一定是叉积最大的点，$E$ 一定是点积最小的点。然后就快乐旋转即可。 例题：洛谷3187。因为输出-0，调了好久。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-12;struct Point &#123; double x, y; bool operator&lt;(const Point&amp; a) const &#123; if (x == a.x) return y &lt; a.y; return x &lt; a.x; &#125;&#125;;Point operator-(Point a, Point b) &#123; return Point&#123;a.x - b.x, a.y - b.y&#125;; &#125;Point operator+(Point a, Point b) &#123; return Point&#123;a.x + b.x, a.y + b.y&#125;; &#125;Point operator*(Point a, double b) &#123; return Point&#123;a.x * b, a.y * b&#125;; &#125;double Cross(Point A, Point B) &#123; return A.x * B.y - A.y * B.x; &#125;double Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;double Dot(Point A, Point B) &#123; return A.x * B.x + A.y * B.y; &#125;double Dot(Point A, Point B, Point C) &#123; return Dot(B - A, C - A); &#125;double sqr(double x) &#123; return x * x; &#125;double dis(Point A, Point B) &#123; return sqrt(sqr(A.x - B.x) + sqr(A.y - B.y)); &#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &gt; 0 ? 1 : -1;&#125;vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt; ps) &#123; int n = ps.size(), k = 0; if (n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;Point&gt; ret(n * 2); for (int i = 0; i &lt; n; ret[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; dcmp(Cross(ret[k - 2], ret[k - 1], ps[i])) &lt;= 0) --k; for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--]) while (k &gt; t &amp;&amp; dcmp(Cross(ret[k - 2], ret[k - 1], ps[i])) &lt;= 0) --k; ret.resize(k - 1); return ret;&#125;vector&lt;Point&gt; work(vector&lt;Point&gt; ps) &#123; ps.push_back(ps[0]); int n = ps.size(); vector&lt;Point&gt; ret(4); double res = 1e18; for (int i = 0, j = 2, k = 2, t = 2; i &lt; n - 1; i++) &#123; while (dcmp(Dot(ps[i], ps[i + 1], ps[j]) - Dot(ps[i], ps[i + 1], ps[j + 1])) &lt;= 0) (++j) %= (n - 1); while (dcmp(Cross(ps[i], ps[i + 1], ps[k]) - Cross(ps[i], ps[i + 1], ps[k + 1])) &lt;= 0) (++k) %= (n - 1); while (dcmp(Dot(ps[i], ps[i + 1], ps[t]) - Dot(ps[i], ps[i + 1], ps[t + 1])) &gt;= 0) (++t) %= (n - 1); double ab = dis(ps[i], ps[i + 1]); double hei = Cross(ps[i], ps[i + 1], ps[k]) / ab; double l = fabs(Dot(ps[i], ps[i + 1], ps[j])) / ab; double r = fabs(Dot(ps[i], ps[i + 1], ps[t])) / ab; double wide = l + r; if (hei * wide &lt; res) &#123; res = hei * wide; ret[0] = ps[i] + (ps[i + 1] - ps[i]) * (l / ab); ret[1] = ret[0] + (ps[j] - ret[0]) * (hei / dis(ret[0], ps[j])); ret[2] = ret[1] + (ps[k] - ret[1]) * (wide / dis(ret[1], ps[k])); ret[3] = ret[2] + (ps[t] - ret[2]) * (hei / dis(ret[2], ps[t])); &#125; &#125; if (dcmp(res) &lt;= 0) res = 0; printf("%.5f\n", res); return ret;&#125;int main() &#123; int n; scanf("%d", &amp;n); double x, y; vector&lt;Point&gt; ps; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;x, &amp;y); ps.push_back(&#123;x, y&#125;); &#125; auto ch = ConvexHull(ps); auto ans = work(ch); int k = 0; for (int i = 1; i &lt; ans.size(); i++) &#123; if (dcmp(ans[k].y - ans[i].y) == 0 &amp;&amp; ans[k].x &gt; ans[i].x) k = i; else if (ans[k].y &gt; ans[i].y) k = i; &#125; for (int i = 0; i &lt; 4; i++) &#123; if (dcmp(ans[(i + k) % 4].x) &lt;= 0) ans[(i + k) % 4].x = 0; if (dcmp(ans[(i + k) % 4].y) &lt;= 0) ans[(i + k) % 4].y = 0; printf("%.5f %.5f\n", ans[(i + k) % 4].x, ans[(i + k) % 4].y); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Asia Singapore Regional Contest]]></title>
    <url>%2F2019%2F10%2F08%2F2018-ICPC-Asia-Singapore-Regional-Contest%2F</url>
    <content type="text"><![CDATA[比赛链接 A - Largest Triangle题意二维平面上有 $n$ 个点，从中选择三个点，问最大的三角形面积。 $1 \leq n \leq 5000$ 分析旋转卡壳快乐旋转 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;struct Point &#123; int x, y; bool operator&lt;(const Point &amp;rhs) const &#123; if (x == rhs.x) return y &lt; rhs.y; return x &lt; rhs.x; &#125;&#125;;Point operator-(Point a, Point b) &#123; return Point&#123;a.x - b.x, a.y - b.y&#125;; &#125;ll Cross(Point A, Point B) &#123; return 1LL * A.x * B.y - 1LL * A.y * B.x; &#125;ll Cross(Point A, Point B, Point C) &#123; return Cross(B - A, C - A); &#125;double area(Point A, Point B, Point C) &#123; return Cross(A, B, C) * 0.5; &#125;vector&lt;Point&gt; ConvexHull(vector&lt;Point&gt; ps) &#123; int n = ps.size(), k = 0; if (n &lt;= 1) return ps; sort(ps.begin(), ps.end()); vector&lt;Point&gt; ret(n * 2); for (int i = 0; i &lt; n; ret[k++] = ps[i++]) while (k &gt; 1 &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt;= 0) --k; for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--]) while (k &gt; t &amp;&amp; Cross(ret[k - 2], ret[k - 1], ps[i]) &lt;= 0) --k; ret.resize(k - 1); return ret;&#125;double work(vector&lt;Point&gt; ps) &#123; if (ps.size() &lt;= 2) return 0; ps.push_back(ps[0]); int n = ps.size(); double ret = 0; for (int i = 0; i &lt; n - 1; i++) &#123; int p = i; for (int j = i + 1; j &lt; n - 1; j++) &#123; while (abs(Cross(ps[i], ps[j], ps[p])) &lt;= abs(Cross(ps[i], ps[j], ps[p + 1]))) (++p) %= (n - 1); ret = max(ret, area(ps[i], ps[j], ps[p])); &#125; &#125; return ret;&#125;int main() &#123; int n; // while (~scanf("%d", &amp;n)) &#123; scanf("%d", &amp;n); vector&lt;Point&gt; ps; for (int i = 0, x, y; i &lt; n; i++) &#123; scanf("%d%d", &amp;x, &amp;y); ps.push_back(&#123;x, y&#125;); &#125; auto ch = ConvexHull(ps); double ans = work(ch); printf("%.5f\n", ans); // &#125;&#125; F - Wi Know题意给定一个长度为 $n$ 的序列，找一个字典序最小的子序列 [A,B,A,B]，要求 $A$ 不等于 $B$。若没有找到输出 $-1$。 $1 \leq n \leq 4e5, 1 \leq a[i] \leq n$ 分析从左到右枚举 $a[i]$ 为第一个 $B$。记下一个 $B$ 出现的位置为 $p$。那么我们需要在 $(i,p)$ 这个区间内找到一个值最小的 $A$（线段树维护）。 问题是如何知道这个 $A$ 在 $[1,i)$ 是否出现过？我们只要保证任何时刻在线段树中的元素都是合法的即可。即枚举完当前元素后，将其下一次出现的位置的值更新为 $a[i]$。这样每次只要在线段树中查询最小值即可，如果查到正无穷表示不合法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define Lson l, m , lson#define Rson m + 1, r , rsonconst int maxn = 4e5+5;int a[maxn], nxt[maxn], pos[maxn];const int INF = 0x3f3f3f3f;int seg[maxn &lt;&lt; 2];void update(int l,int r,int rt,int p,int x)&#123; if(l == r) &#123; seg[rt] = x; return ; &#125; int m = l + r &gt;&gt; 1; if(p &lt;= m) update(Lson, p, x); else update(Rson, p, x); seg[rt] = min(seg[lson], seg[rson]);&#125;int query(int l,int r,int rt,int L,int R)&#123; if(L &gt; R) return INF; if(L &lt;= l &amp;&amp; R &gt;= r) return seg[rt]; int m = l + r &gt;&gt;1 , ret = INF; if(L &lt;= m) ret = min(ret, query(Lson,L,R)); if(m+1 &lt;= R) ret = min(ret, query(Rson, L,R)); return ret;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i), pos[i] = -1; for(int i=n;i&gt;0;i--)&#123; nxt[i] = pos[a[i]]; pos[a[i]] = i; &#125; memset(seg,0x3f,sizeof(seg)); pair&lt;int,int&gt; ans = &#123;INF,INF&#125;; for(int i=1;i&lt;=n;i++)&#123; if(nxt[i] != -1)&#123; int tmp = query(1,n,1,i+1,nxt[i]-1); if(tmp != INF) ans = min(ans, &#123;tmp, a[i]&#125;); update(1,n,1,nxt[i],a[i]); &#125; &#125; if(ans.first == INF) puts("-1"); else printf("%d %d\n",ans.first, ans.second);&#125; G - Rectangular City题意一个 $R \times C$，要求依次选 $n$ 个矩形（可以相同），使得这些矩形的交的面积不小于 $k$ 。求方案数，结果取模。 $1 \leq R,C \leq 5000$ 分析选矩形的操作可以简化为在两个一维空间中分别选一段区间，其区间长度乘积不小于 $k$。 设 $dp[len]$ 表示在长度为 $r$ 的一维空间中，选 $n$ 个区间，使得这些区间交的长度为 $len$。 那么只要通过枚举起点即可计算 $dp[len]$。 公式为：若区间左边有 $a$ 个位置可以选，右边有 $b$ 个元素可以选，那么 $dp[len] += (a^n - (a-1)^n) \times (b^n - (b-1)^n)$。 最后只要枚举行和列各自所选的长度求和即可。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 1e9 + 7;const int maxn = 5e3 + 5;int dp[2][maxn];int npow[maxn];int Pow(int a, int b) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;inline int cal(int x) &#123; return (npow[x] - npow[x - 1] + mod) % mod; &#125;int main() &#123; int n, sz[2], k; cin &gt;&gt; n &gt;&gt; sz[0] &gt;&gt; sz[1] &gt;&gt; k; for (int i = 0; i &lt; maxn; i++) npow[i] = Pow(i, n); for (int i = 0; i &lt; 2; i++) &#123; for (int len = 1; len &lt;= sz[i]; len++) &#123; for (int j = 0; j &lt;= sz[i] - len; j++) &#123; int a = j + 1, b = sz[i] - j - len + 1; int tmp = 1LL * cal(a) * cal(b) % mod; dp[i][len] = (dp[i][len] + tmp) % mod; &#125; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= sz[0]; i++) &#123; for (int j = 1; j &lt;= sz[1]; j++) &#123; if (i * j &gt;= k) ans = (ans + 1LL * dp[0][i] * dp[1][j] % mod) % mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf1234F Yet Another Substring Reverse]]></title>
    <url>%2F2019%2F10%2F05%2Fcf1234F-Yet-Another-Substring-Reverse%2F</url>
    <content type="text"><![CDATA[题目链接 题目给一个长度为 $n$ 的只包含 $20$ 个小写字母的字符串，现在最多可进行一次区间反转。问最长的子串的长度？ 要求这个子串中所有字母都是不同的。 $1 \leq n \leq 10^6$ 分析一直在考虑会不会有重叠的问题，后来发现不会出现重叠的情况。 $dp[i]$ 表示 $i$ 所表示的二进制中，那些位为 $1$ 的元素 最多有多少个存在。 转移可以通过枚举所有为 $1$ 的位，来进行转移。 代码1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1 &lt;&lt; 20) + 5;bool bit[maxn];int dp[maxn];int main() &#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i++) &#123; int mask = 0; for (int j = i; j &lt; s.size(); j++) &#123; if (mask &amp; (1 &lt;&lt; (s[j] - 'a'))) break; mask |= 1 &lt;&lt; (s[j] - 'a'); bit[mask] = 1; &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; 20); i++) if (bit[i]) dp[i] = __builtin_popcount(i); for (int i = 0; i &lt; (1 &lt;&lt; 20); i++) &#123; for (int j = 0; j &lt; 20; j++) &#123; if (i &amp; (1 &lt;&lt; j)) dp[i] = max(dp[i], dp[i ^ (1 &lt;&lt; j)]); &#125; &#125; int ans = 0; for (int i = 0; i &lt; (1 &lt;&lt; 20); i++) if (bit[i]) ans = max(ans, __builtin_popcount(i) + dp[i ^ ((1 &lt;&lt; 20) - 1)]); cout &lt;&lt; ans &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>子集dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu4219 大融合]]></title>
    <url>%2F2019%2F10%2F05%2FLuogu4219-%E5%A4%A7%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目链接 题目$n$ 个点，$m$ 个操作： $(u,v)$ 连一条边 $(u,v)$ 查询经过这条边的简单路径数 $1 \leq n,m \leq 10^5$ 分析$LCT$ 维护子树大小。 对于操作 $2$，答案是 $u$ 的虚子树和 $v$ 的虚子树 的乘积。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;// 1-indexstruct LCT &#123; int val[maxn], sum[maxn], si[maxn]; // 基于点权 int rev[maxn], ch[maxn][2], fa[maxn]; int stk[maxn]; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline bool get(int x) &#123; return ch[fa[x]][1] == x; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; &#125; inline void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); rev[x] ^= 1; &#125; &#125; // 因为儿子可能会改变，因此每次必须重新计算 inline void pushup(int x) &#123; sum[x] = 1 + sum[ch[x][0]] + sum[ch[x][1]] + si[x]; &#125; // 避免单独使用：不能直接旋转根 void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (!isroot(y)) ch[z][get(y)] = x; fa[x] = z; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y, fa[y] = x; pushup(y), pushup(x); &#125; // 将x旋转到Splay的根 void splay(int x) &#123; int top = 0; stk[++top] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f; !isroot(x); rotate(x)) if (!isroot(f = fa[x])) rotate(get(x) == get(f) ? f : x); &#125; // 将根到x的路径拉到一棵Splay中 void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) &#123; splay(x); si[x] += sum[ch[x][1]]; ch[x][1] = y; si[x] -= sum[y]; pushup(x); &#125; &#125; // 让x成为原树的根，x为深度最低的点，其左子树为空 void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125; // 找x所在原树的根。主要用来判联通性，如果find(x) = find(y) // 则x,y在同一棵树中。 int find(int x) &#123; access(x), splay(x); while (ch[x][0]) pushdown(x), x = ch[x][0]; splay(x); return x; &#125; // 加边，y为深度最低的点（顺序无所谓） void link(int x, int y) &#123; split(x, y); si[fa[x] = y] += sum[x]; pushup(y); &#125; // 删边 void cut(int x, int y) &#123; split(x, y), fa[x] = ch[y][0] = 0, pushup(y); &#125; // 将x到y的路径拉到一棵Splay中，y为Splay的根 void split(int x, int y) &#123; makeroot(x), access(y), splay(y); &#125; long long query(int x, int y) &#123; split(x, y); return 1LL * (si[x] + 1) * (si[y] + 1); &#125;&#125; lct;int main() &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); char op[5]; int x, y; while (q--) &#123; scanf("%s%d%d", op, &amp;x, &amp;y); if (op[0] == 'A') lct.link(x, y); else printf("%lld\n", lct.query(x, y)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu2542 航线规划]]></title>
    <url>%2F2019%2F10%2F05%2FLuogu2542-%E8%88%AA%E7%BA%BF%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[题目链接 题目$n$ 个点无向图中，有 $m$ 个操作： $(u,v)$ 破坏这条边 $(u,v)$ 查询这条路径上的必经边（支配边） $1 \leq n \leq 30000, 1 \leq m \leq 10^5$ 分析对于这种只有删边的题目，我们可以考虑离线之后倒过来做，这样删边就变成了加边。 考虑两点之间的必经边计数。如果加边之前两个连通块不连通，那么这条边就是必经边。 不然的话 $(u,v)$ 这条链上就都不是必经边。 我们可以通过一个区间置零的操作来实现。 因为是边权模型，所以我们可以把每条边看作一个新的点。如果是必经边则点权为 $1$，否则为 $0$. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5 + 5;struct Edge &#123; int u, v, c;&#125;;vector&lt;Edge&gt; edges;// 1-indexstruct LCT &#123; int val[maxn], sum[maxn]; // 基于点权 int rev[maxn], ch[maxn][2], fa[maxn]; int stk[maxn]; bool zero[maxn]; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline bool get(int x) &#123; return ch[fa[x]][1] == x; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; &#125; inline void set(int x) &#123; sum[x] = 0; val[x] = 0; zero[x] = 1; &#125; inline void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); rev[x] ^= 1; &#125; if (zero[x]) &#123; if (ch[x][0]) set(ch[x][0]); if (ch[x][1]) set(ch[x][1]); zero[x] = 0; &#125; &#125; // 因为儿子可能会改变，因此每次必须重新计算 inline void pushup(int x) &#123; sum[x] = val[x] + sum[ch[x][0]] + sum[ch[x][1]]; &#125; // 避免单独使用：不能直接旋转根 void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (!isroot(y)) ch[z][get(y)] = x; fa[x] = z; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y, fa[y] = x; pushup(y), pushup(x); &#125; // 将x旋转到Splay的根 void splay(int x) &#123; int top = 0; stk[++top] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f; !isroot(x); rotate(x)) if (!isroot(f = fa[x])) rotate(get(x) == get(f) ? f : x); &#125; // 将根到x的路径拉到一棵Splay中 void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x); &#125; // 让x成为原树的根，x为深度最低的点，其左子树为空 void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125; // 找x所在原树的根。主要用来判联通性，如果find(x) = find(y) // 则x,y在同一棵树中。 int find(int x) &#123; access(x), splay(x); while (ch[x][0]) pushdown(x), x = ch[x][0]; splay(x); return x; &#125; // 加边，y为深度最低的点（顺序无所谓） void link(int x, int y) &#123; makeroot(x); fa[x] = y, splay(x); &#125; // 删边 void cut(int x, int y) &#123; split(x, y), fa[x] = ch[y][0] = 0, pushup(y); &#125; // 将x到y的路径拉到一棵Splay中，y为Splay的根 void split(int x, int y) &#123; makeroot(x), access(y), splay(y); &#125; // 单点修改 void update(int x, int v) &#123; access(x), splay(x); val[x] = v; pushup(x); &#125; // 区间修改 void update_seg(int u, int v) &#123; split(u, v); set(v); &#125; int query(int u, int v) &#123; split(u, v); return sum[v]; &#125;&#125; lct;using pii = pair&lt;int, int&gt;;map&lt;pii, int&gt; edge;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v, c; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); if (u &gt; v) swap(u, v); edge[&#123;u, v&#125;]++; &#125; for (int u, v, c;;) &#123; scanf("%d", &amp;c); if (c == -1) break; scanf("%d%d", &amp;u, &amp;v); if (u &gt; v) swap(u, v); if (c == 0) edge[&#123;u, v&#125;]--; edges.push_back(&#123;u, v, c&#125;); &#125; int tot = n + 1; for (auto &amp;V : edge) &#123; if (V.second == 0) continue; int u = V.first.first, v = V.first.second; while (V.second--) &#123; if (lct.find(u) == lct.find(v)) &#123; lct.val[tot] = 0; lct.update_seg(u, v); &#125; else &#123; lct.val[tot] = 1; lct.link(u, tot); lct.link(v, tot); &#125; tot++; &#125; &#125; reverse(edges.begin(), edges.end()); vector&lt;int&gt; ans; for (auto &amp;e : edges) &#123; if (e.c == 0) &#123; if (lct.find(e.u) == lct.find(e.v)) &#123; lct.val[tot] = 0; lct.update_seg(e.u, e.v); &#125; else &#123; lct.val[tot] = 1; lct.link(e.u, tot); lct.link(e.v, tot); &#125; tot++; &#125; else &#123; ans.push_back(lct.query(e.u, e.v)); &#125; &#125; reverse(ans.begin(), ans.end()); for (auto &amp;v : ans) printf("%d\n", v);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu2486 染色]]></title>
    <url>%2F2019%2F10%2F05%2FLuogu2486-%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接 题目$n$ 个结点的无根树，有 $m$ 个操作。 将 $(a,b)$ 路径上的点染成颜色 $c$ 询问 $(a,b)$ 路径上颜色段的数量 $1 \leq n,m \leq 10^5$ 分析$1$ 操作对应 $LCT$ 中的区间赋值。 $2$ 操作只要维护一棵 $Splay$ 中深度最低点的颜色和深度最高的点的颜色。注意在反转区间的时候颜色也要反转！！！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 4;struct LCT &#123; int val[maxn], sum[maxn]; // 基于点权 int rev[maxn], ch[maxn][2], fa[maxn]; int stk[maxn]; int col[maxn]; int lc[maxn], rc[maxn]; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline bool get(int x) &#123; return ch[fa[x]][1] == x; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]); swap(lc[x], rc[x]); // !!!!!!!!!!!!!!!!!!!!! rev[x] ^= 1; &#125; inline void color(int x, int v) &#123; val[x] = v; col[x] = v; lc[x] = rc[x] = v; sum[x] = 1; &#125; inline void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); rev[x] ^= 1; &#125; if (col[x]) &#123; if (ch[x][0]) color(ch[x][0], col[x]); if (ch[x][1]) color(ch[x][1], col[x]); col[x] = 0; &#125; &#125; // 因为儿子可能会改变，因此每次必须重新计算 inline void pushup(int x) &#123; sum[x] = 1; lc[x] = val[x], rc[x] = val[x]; if (ch[x][0]) &#123; sum[x] += sum[ch[x][0]]; if (val[x] == rc[ch[x][0]]) sum[x]--; lc[x] = lc[ch[x][0]]; &#125; if (ch[x][1]) &#123; sum[x] += sum[ch[x][1]]; if (val[x] == lc[ch[x][1]]) sum[x]--; rc[x] = rc[ch[x][1]]; &#125; &#125; // 避免单独使用：不能直接旋转根 void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (!isroot(y)) ch[z][get(y)] = x; fa[x] = z; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y, fa[y] = x; pushup(y), pushup(x); &#125; // 将x旋转到Splay的根 void splay(int x) &#123; int top = 0; stk[++top] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f; !isroot(x); rotate(x)) if (!isroot(f = fa[x])) rotate(get(x) == get(f) ? f : x); &#125; // 将根到x的路径拉到一棵Splay中 void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x); &#125; // 让x成为原树的根，x为深度最低的点，其左子树为空 void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125; // 找x所在原树的根。主要用来判联通性，如果find(x) = find(y) // 则x,y在同一棵树中。 int find(int x) &#123; access(x), splay(x); while (ch[x][0]) pushdown(x), x = ch[x][0]; splay(x); return x; &#125; // 加边，y为深度最低的点（顺序无所谓） void link(int x, int y) &#123; makeroot(x); fa[x] = y, splay(x); &#125; // 将x到y的路径拉到一棵Splay中，y为Splay的根 void split(int x, int y) &#123; makeroot(x), access(y), splay(y); &#125; // 区间修改 void update_seg(int u, int v, int c) &#123; split(u, v); color(v, c); &#125; int query(int u, int v) &#123; split(u, v); return sum[v]; &#125;&#125; lct;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, c; i &lt;= n; i++) &#123; scanf("%d", &amp;c); lct.val[i] = c; lct.lc[i] = c; lct.rc[i] = c; &#125; for (int i = 0, u, v; i &lt; n - 1; i++) &#123; scanf("%d%d", &amp;u, &amp;v); lct.link(u, v); &#125; int a, b, c; char op[5]; while (m--) &#123; scanf("%s%d%d", op, &amp;a, &amp;b); if (op[0] == 'C') &#123; scanf("%d", &amp;c); lct.update_seg(a, b, c); &#125; else &#123; printf("%d\n", lct.query(a, b)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu4180 严格次小生成树]]></title>
    <url>%2F2019%2F10%2F05%2FLuogu4180-%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接 题目求严格次小生成树的权值。 $1 \leq n \leq 100000, 1 \leq m \leq 300000$ 分析次小生成树可以通过替换掉最小生成树上的一条边得到。 $LCT$ 维护最小生成树，维护一个最大值和次大值。枚举不在最小生成树上的边，用环中最大或次大的边替换。 由于 $LCT$ 常数血大，所以判连通的时候可以用并查集。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e5 + 5;using ll = long long;struct Edge &#123; int u, v, w; bool operator&lt;(const Edge &amp;rhs) const &#123; return w &lt; rhs.w; &#125;&#125;;vector&lt;Edge&gt; edges;int n, m;struct LCT &#123; int val[maxn], max[maxn], smax[maxn]; // 基于点权 int rev[maxn], ch[maxn][2], fa[maxn]; int stk[maxn]; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline bool get(int x) &#123; return ch[fa[x]][1] == x; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; &#125; inline void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); rev[x] ^= 1; &#125; &#125; // 因为儿子可能会改变，因此每次必须重新计算 int tmp[10]; inline void pushup(int x) &#123; int tot = 0; tmp[tot++] = val[x]; max[x] = val[x]; if (ch[x][0]) &#123; tmp[tot++] = max[ch[x][0]]; tmp[tot++] = smax[ch[x][0]]; max[x] = std::max(max[x], max[ch[x][0]]); &#125; if (ch[x][1]) &#123; tmp[tot++] = max[ch[x][1]]; tmp[tot++] = smax[ch[x][1]]; max[x] = std::max(max[x], max[ch[x][1]]); &#125; smax[x] = -1; for (int i = 0; i &lt; tot; i++) if (tmp[i] &lt; max[x] &amp;&amp; tmp[i] &gt; smax[x]) smax[x] = tmp[i]; &#125; // 避免单独使用：不能直接旋转根 void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (!isroot(y)) ch[z][get(y)] = x; fa[x] = z; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y, fa[y] = x; pushup(y), pushup(x); &#125; // 将x旋转到Splay的根 void splay(int x) &#123; int top = 0; stk[++top] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f; !isroot(x); rotate(x)) if (!isroot(f = fa[x])) rotate(get(x) == get(f) ? f : x); &#125; // 将根到x的路径拉到一棵Splay中 void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x); &#125; // 让x成为原树的根，x为深度最低的点，其左子树为空 void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125; // 找x所在原树的根。主要用来判联通性，如果find(x) = find(y) // 则x,y在同一棵树中。 int find(int x) &#123; access(x), splay(x); while (ch[x][0]) pushdown(x), x = ch[x][0]; splay(x); return x; &#125; // 加边，y为深度最低的点（顺序无所谓） void link(int x, int y) &#123; makeroot(x); fa[x] = y, splay(x); &#125; // 将x到y的路径拉到一棵Splay中，y为Splay的根 void split(int x, int y) &#123; makeroot(x), access(y), splay(y); &#125;&#125; lct;bool vis[maxn];int par[maxn];int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;inline void merge(int x, int y) &#123; x = find(x); y = find(y); par[x] = y;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) par[i] = i; for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edges.push_back(&#123;u, v, w&#125;); &#125; sort(edges.begin(), edges.end()); int cnt = 0; ll tot = 0; for (int i = 0, u, v, w; i &lt; m; i++) &#123; u = edges[i].u; v = edges[i].v; w = edges[i].w; if (find(u) == find(v)) continue; merge(u, v); lct.link(u, i + 1 + n); lct.link(v, i + 1 + n); lct.val[i + 1 + n] = w; cnt++; tot += w; vis[i] = true; if (cnt == n - 1) break; &#125; ll ans = 1e18; for (int i = 0, u, v, w; i &lt; m; i++) &#123; u = edges[i].u; v = edges[i].v; w = edges[i].w; if (vis[i]) continue; lct.split(u, v); ll tmp = tot - lct.max[v] + w; if (tmp != tot) ans = min(ans, tmp); tmp = tot - lct.smax[v] + w; if (tmp != tot) ans = min(ans, tmp); &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf1228E Another Filling the Grid]]></title>
    <url>%2F2019%2F10%2F01%2Fcf1228E-Another-Filling-the-Grid%2F</url>
    <content type="text"><![CDATA[题目链接 题目给定一个 $n \times n$ 的矩阵，每个格子可以填一个 $[1,k]$ 的数字。要求每行最小的数字和每列最小的数字都是 $1$ 。 问满足条件的填法一共有几种？ $1 \leq n \leq 250, 1 \leq k \leq 19^9$ 分析不难发现每一行和每一列都是等价的，因此我们 $dp$ 的状态表示应该只与已经填好的行数和列数有关。 设 $dp[i][j]$ 表示 $i$ 行中，有 $j$ 行不满足条件， $n-j$ 行满足条件。使得这个状态满足条件的填法。 $dp[i][0] = (k^n - (k-1)^n)^i$ 所有列都满足条件，每一行至少有一个 $1$。 $dp[1][j] = k^{n-j}$ 有 $j$ 行不满足条件，那么这 $j$ 行就要填 $1$，其他随便填。 $dp[i][j] = dp[i-1][j] \times (k-1)^{j} \times (k^{n-j} - (k-1)^{n-j}) + \sum_{t=1}^{j} \tbinom{j}{t} \times (k-1)^{j-t} \times k^{n-j} \times dp[i-1][j-t]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int mod = 1e9 + 7;const int maxn = 255;int C[maxn][maxn];int powk[maxn], powkMinusOne[maxn];int n, k; ll Pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;int dp[maxn][maxn]; int main() &#123; C[0][0] = 1; for (int i = 1; i &lt; maxn; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) &#123; C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; &#125; &#125; cin &gt;&gt; n &gt;&gt; k; powk[0] = powkMinusOne[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; powk[i] = 1LL * powk[i - 1] * k % mod; powkMinusOne[i] = 1LL * powkMinusOne[i - 1] * (k - 1) % mod; &#125; int var1 = (Pow(k, n) - Pow(k - 1, n) + mod) % mod; for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = Pow(var1, i); dp[1][i] = powk[n - i]; &#125; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int var2 = (1LL * powk[n - j] - powkMinusOne[n - j] + mod) % mod; dp[i][j] = 1LL * powkMinusOne[j] * var2 % mod * dp[i - 1][j] % mod; for (int t = 1; t &lt;= j; t++) dp[i][j] += 1LL * C[j][t] * powkMinusOne[j - t] % mod * powk[n - j] % mod * dp[i - 1][j - t] % mod, dp[i][j] %= mod; &#125; &#125; cout &lt;&lt; dp[n][n] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link Cut Tree]]></title>
    <url>%2F2019%2F09%2F30%2FLink-Cut-Tree%2F</url>
    <content type="text"><![CDATA[参考博客 LCT$LCT$ 通过维护一个 $Splay$ 森林，以起到维护一棵树的信息的作用。 能够动态地维护（加边删边）应该是它最大的特点了（毕竟名字就是 $Link-Cut$。 在 $LCT$ 中，一棵树的边被分为实边（偏爱边）和虚边，每个实边连接的连通块（子树）用一个 $Splay$ 来维护。这个 $Splay$ 中的信息仅仅是这个由实边组成的子树的信息，不会包含子树外的点。 注意：原树中的边并不会因为LCT的旋转或者换根等操作而发生改变（只会影响边的虚实）。 实边和虚边的定义因为实边和 $Splay$ 是紧密相关的，所以我们不妨先看看这些 $Splay$ 的特点。 每个 $Splay$ 中的偏序关系是点在原树中的深度，且每个 $Splay$ 中无深度相同的两个点。每个 $Spaly$ 的中序遍历，在原树上是一条深度递增的树链（非常重要）。 那也就要求了每个父结点和它的儿子结点之间最多只有一条实边，其余都是虚边。 每条实边都只属于一个 $Splay$。 如何用 $Splay$ 森林维护一棵树的信息（不同 $Splay$ 之间是如何联系的？）所有的虚边实际上都是一棵 $Splay$ 中 深度最低的结点 的父亲，指向另一颗（深度更低）$Splay$ 的某个结点。 但对于一棵 $Splay$ 来说，它不可能通过查找儿子而进入到另一颗 $Splay$ 中。换句话说，只能通过向祖先寻找的方式，进入到另一棵（深度更低）$Splay$ 中。这就是为什么可以做到每棵 $Splay$ 只维护了当前子树的信息，而不涉及其它的结点。 LCT 的灵魂虚边和实边的转换我们可以通过将结点 $x$ 到根的路径的边都设置为实边（偏爱路径），这样这条链的信息就在一棵 $Splay$ 中，我们可以快速地维护这条树链上的信息。 我们可以用 access(x) 来表示这一操作。 具体做法： 先将结点 $x$ 旋转到当前 $Splay$ 的根，然后它的右儿子（深度较大）是不在根到 $x$ 的这条树链上的，因此要置空。但此时其右儿子的祖先还是 $x$ ，这条边也就变成了虚边。 然后寻找祖先 $y = fa[x]$，将 $y$ 旋转到它所在 $Splay$ 的根后，再将右儿子置为 $x$。因为 $y$ 的深度是 $x$ 所在 $Splay$ 的最低深度 减一，所以 $y$ 的右儿子必然不在 $x$ 到根的这条树链上。 不断重复 $2$ 操作，直到 $y$ 的父亲为空。 换根通过之前的操作，我们可以很容易的维护一条根到任意结点的树链信息。但如果我们想维护一条普通的树链（端点可能不为根），这时候就需要换根操作。 我们可以用 makeroot(x) 来表示这一操作。 具体做法： access(x) 将 $x$ 转到 $Splay$ 的根. 将 $x$ 的儿子互换。因为 $x$ 是 $Splay$ 中深度最大的结点，因此此时 $x$ 的右儿子为空。而根结点一定是深度最低的点，所以我们只要将 $x$ 的儿子互换，$x$ 就成为了深度最低的点，即原树的根。 其它操作Splitsplit(u,v) 将树链 $(u,v)$ 放到一个 $Splay$ 中。 具体做法： makeroot(u) access(v) 将 $v$ 转到当前 $Splay$ 的根。这样 $v$ 点的信息就是整棵 $Splay$，即 $(u,v)$ 的信息。 插入插入的顺序其实没有关系，因为树的结构是固定的，想要谁当根只需要做一下换根操作即可。 区间更新对于树链 $(u,v)$，先要通过 split(u,v) 将 $(u,v)$ 链上的点都放到一个 $Splay$ 中。 然后对 $v$ 打上对应的标记即可。 单点更新要注意因为某些区间标记（比如区间取反）会影响点权，因此我们必须在更新之前先把区间标记都做掉。 具体做法： access(x) 将 $x$ 旋转到当前 $Splay$ 的根 更新 $x$ 的值，同时 $pushup(x)$ LCT的作用： 维护树链的信息 动态维护树的连通性：因为LCT本质是个Splay森林，所以可能存在不连通的情况。可以通过找各自原树的根是否相同来判断是否连通。（有些卡常题目可以用并查集来替代 $find$ 判联通性） 时间复杂度：势能分析据说 $O((n + m) \log n)$，常数血大。 边权模型：对于每条边建一个点，这个点的权值即为边权。 维护连通块信息一个点的连通块信息由一个实边组成的 $Splay$ 和多个虚边连接的 $Splay$ 的构成。 所以对于每个点，我们只要再维护一个所有虚边连接的 $Splay$ 的信息之和。 12345678910111213141516171819202122232425262728293031int si[maxn]; 所有虚子树信息inline void pushup(int x) &#123; sum[x] = val[x] + sum[ch[x][0]] + sum[ch[x][1]] + si[x];&#125;void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) &#123; splay(x); si[x] += sum[ch[x][1]]; ch[x][1] = y; si[x] -= sum[y]; pushup(x); &#125;&#125;// 因为 sum[x] 会影响到 y 的祖先，所以先把 y 转到根// 保证连边合法inline void link(int x, int y) &#123; split(x, y); si[fa[x] = y] += sum[x]; pushup(y);&#125;// 不保证inline bool link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return 0; si[fa[x] = y] += sum[x]; pushup(y); return 1;&#125; 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 1-indexstruct LCT &#123; int val[maxn], sum[maxn]; // 基于点权 int rev[maxn], ch[maxn][2], fa[maxn]; int stk[maxn]; inline void init(int n) &#123; // 初始化点权（一般不需要） for (int i = 1; i &lt;= n; i++) scanf("%d", val + i); for (int i = 1; i &lt;= n; i++) fa[i] = ch[i][0] = ch[i][1] = rev[i] = 0; &#125; inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125; inline bool get(int x) &#123; return ch[fa[x]][1] == x; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; &#125; inline void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); rev[x] ^= 1; &#125; &#125; // 因为儿子可能会改变，因此每次必须重新计算 inline void pushup(int x) &#123; sum[x] = val[x] + sum[ch[x][0]] + sum[ch[x][1]]; &#125; // 避免单独使用：不能直接旋转根 void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (!isroot(y)) ch[z][get(y)] = x; fa[x] = z; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y, fa[y] = x; pushup(y), pushup(x); &#125; // 将x旋转到Splay的根 void splay(int x) &#123; int top = 0; stk[++top] = x; for (int i = x; !isroot(i); i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f; !isroot(x); rotate(x)) if (!isroot(f = fa[x])) rotate(get(x) == get(f) ? f : x); &#125; // 将根到x的路径拉到一棵Splay中 void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, pushup(x); &#125; // 让x成为原树的根，x为深度最低的点，其左子树为空 void makeroot(int x) &#123; access(x), splay(x), reverse(x); &#125; // 找x所在原树的根。主要用来判联通性，如果find(x) = find(y) // 则x,y在同一棵树中。 int find(int x) &#123; access(x), splay(x); while (ch[x][0]) pushdown(x), x = ch[x][0]; splay(x); return x; &#125; // 加边，y为深度最低的点（顺序无所谓） void link(int x, int y) &#123; makeroot(x); // if(find(y) != x) fa[x] = y; // 存在不合法加边 fa[x] = y, splay(x); &#125; // 删边 void cut(int x, int y) &#123; split(x, y), fa[x] = ch[y][0] = 0, pushup(y); /* 存在不合法删边 makeroot(x); if(find(y) != x || fa[y] != x || ch[y][0]) return false; fa[y] = ch[x][1] = 0; pushup(x); return true; */ &#125; // 将x到y的路径拉到一棵Splay中，y为Splay的根 void split(int x, int y) &#123; makeroot(x), access(y), splay(y); &#125; // 单点修改 void update(int x, int v) &#123; access(x), splay(x); val[x] = v; pushup(x); &#125; // 区间修改 void update_seg(int u, int v) &#123; split(u, v); // tag(v); 打对应标记，记得更改对sum的影响 &#125;&#125; lct;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小表示法]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最小表示法对于 $s$ 的两个子串 $A,B$。 设 $k$ 满足：$A[i] = B[j], … , A[i+k-1] = B[j+k-1]$。 那么如果 $A[i+k] &gt; B[j+k]$ 那么最小表示的首元素一定不在 $A[i]…A[i+k]$ 中。 代码123456789101112131415161718// 返回最小表示的首元素的下标int work(string s) &#123; int n = s.size(); int i, j, k; for (i = 0, j = 1, k = 0; i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n;) &#123; if (s[(i + k) % n] == s[(j + k) % n]) k++; else &#123; if (s[(i + k) % n] &gt; s[(j + k) % n]) i = i + k + 1; else j = j + k + 1; if (i == j) i++; k = 0; &#125; &#125; return min(i, j);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归下降]]></title>
    <url>%2F2019%2F09%2F17%2F%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXS = 100;using sss = stringstream;char buf[MAXS];int parseOr(sss&amp; ss);int parseInt(sss&amp; ss) &#123; int ret; ss &gt;&gt; ret; return ret;&#125;int parseBracket(sss&amp; ss) &#123; if (ss.peek() == '(') &#123; ss.get(); int x = parseOr(ss); ss.get(); return x; &#125; return parseInt(ss);&#125;int parseSign(sss&amp; ss) &#123; char op = ss.peek(); if (op == '+') &#123; ss.get(); return parseSign(ss); &#125; if (op == '-') &#123; ss.get(); return -parseSign(ss); &#125; if (op == '~') &#123; ss.get(); return ~parseSign(ss); &#125; return parseBracket(ss);&#125;int parseMul(sss&amp; ss) &#123; int ret = parseSign(ss); if (ss.peek() == '*') ss.get(), ret = ret * parseMul(ss); return ret;&#125;int parseAdd(sss&amp; ss) &#123; int ret = parseMul(ss); while (true) &#123; char op = ss.peek(); if (op != '+' &amp;&amp; op != '-') break; ss.get(); int x = parseMul(ss); if (op == '+') ret += x; else ret -= x; &#125; return ret;&#125;int parseAnd(sss&amp; ss) &#123; int ret = parseAdd(ss); if (ss.peek() == '&amp;') ss.get(), ret &amp;= parseAnd(ss); return ret;&#125;int parseXor(sss&amp; ss) &#123; int ret = parseAnd(ss); if (ss.peek() == '^') ss.get(), ret ^= parseXor(ss); return ret;&#125;int parseOr(sss&amp; ss) &#123; int ret = parseXor(ss); if (ss.peek() == '|') ss.get(), ret |= parseOr(ss); return ret;&#125;int main() &#123; string s; cin &gt;&gt; s; sss ss(s); printf("%d\n", parseOr(ss));&#125;]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>递归下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%2F</url>
    <content type="text"><![CDATA[康托展开问题给定某个 $[1,n]$ 的排列，求这是全排列中第几小的排列。 解法考虑某个排列 $[2,3,1,4]$，从第一个元素开始看起。第一个元素是 $2$，说明首位为 $1$ 的那些已经算过了，答案要加 $(n-1)!$。 再看第二位 $3$。比它小的元素有 $1, 2$，但是 $2$ 已经用过了，所以只考虑 $1$，它的贡献是 $(n-2)!$。 如此以往即可求出答案。 所以公示可以抽象为：$rank = a_n \times (n-1)! + a_{n-1} \times (n-2)! + … a_0 \times 0!$ 模板题：洛谷5367 逆康托展开问题对于 $[1,n]$ 的全排列，求其中第 $k$ 小的排列。 解法比如 $n = 4, k = 10$ 的情况。 $\frac{(k-1)}{3!} = 1$ 余数为 $3$，则这一位是所有没有用过的数字中第二（商加一）小的，即 $2$。 $\frac{(3)}{2!} = 1$ 余数为 $1$，则这一位是所有没有用过的数字中第二（商加一）小的，即 $3$。 $\frac{(1)}{1!} = 1$ 余数为 $0$，则这一位是所有没有用过的数字中第二（商加一）小的，即 $4$。 最后一位就是还没用过的那个数字。]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F2019%2F09%2F13%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[长期更新 什么是线性从代数的角度来说：两个变量是线性关系，即两个变量间存在一次函数关系。 从几何的角度来说：以二维空间举例，可以想象二维直角坐标系上的一个向量。我们对这个向量进行拉伸，旋转等操作，最终它的形态还是一条线段。我们施加的这些操作就是线性的。而如果对这个向量的操作会使其发生弯曲，这就不是线性的。 解线性方程组通过对增广矩阵进行高斯消元和回代，来求得线性方程组的解。 矩阵乘法$$ \left[ \begin{matrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{matrix} \right] \times \left[ \begin{matrix} b_1 &amp; b_2 \\ b_3 &amp; b_4 \end{matrix} \right] = \left[ \begin{matrix} c_1 &amp; c_2 \\ c_3 &amp; c_4 \end{matrix} \right]$$ 代数角度理解矩阵 $A$ 中每一行是一个方程，$a_i$ 表示第 $i$ 个未知数的系数。$B$ 中每一列对应 $A$ 中每一行未知数的取值。最后实际上就是 $A$ 中的每一行点乘 ($dot$) $B$ 中的每一列。 几何的角度理解$C$ 中的每一列代表一个向量，它是由 $A$ 中每列的向量线性组合而来。即 $A$ 表示的是一个空间的基向量。 也可以理解为：对于 $C$ 中的每行，都是 $B$ 中每行的一个向量线性组合。 矩阵的逆我们称可逆的矩阵为非奇异矩阵，不可逆的矩阵为奇异矩阵。 如何理解逆？ 可以理解为逆变换。想象方阵 $A$ 表示空间中的一组基，现在我想将 $A$ 变成标准正交基，所需要做一些初等变换 $A^{-1}$ 就称为 $A$ 的逆。 什么情况不可逆？ 当 $A$ 本身并不是基时，即它不能表示其空间所有的向量（存在某两行或两列线性相关）。 如何求解逆矩阵： [A I] -&gt; [I $A^{-1}$] LU分解$A = LU$ $U$ 代表上三角，$L$ 代表下三角。实际上是在将 $A$ 的主元分解出来。 $L$ 的对角线都为 $1$。]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率论基础]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%A6%82%E7%8E%87%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[长期更新 古典概型定义： 试验的样本空间只包含有限个元素。 试验中每个基本事件发生的可能性相同。 条件概率设 $P(A) &gt; 0$，则有 $P(AB) = P(B|A)P(A)$。 全概率公式$P(A) = P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + … + P(A|B_n)P(B_n)$ $B_1,B_2…B_n$ 是样本空间的一个划分。 贝叶斯公式$ P(B_i|A) = \frac{P(A|B_i)P(B_i)}{P(A)} = \frac{P(A|B_i)P(B_i)}{P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + … + P(A|B_n)P(B_n)}$ 先验概率：在事情发生之前，通过数据总结和分析得到的事情发生概率 $P(A|B_i)$。后验概率：当某件事情已经发生，判断事情发生时由哪个原因引起的概率 $P(B_i|A)$。 独立性如果事件 $A,B$ 满足：$P(AB) = P(A)P(B)$，则称 $A,B$ 相互独立。 两事件相互独立的含义是它们中一个的发生，不影响另一个发生的概率。]]></content>
      <categories>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3436 Queue-jumpers]]></title>
    <url>%2F2019%2F09%2F09%2Fhdu3436-Queue-jumpers%2F</url>
    <content type="text"><![CDATA[题意$1$ 到 $n$ 顺序排列的数组，有 $m$ 次操作： 将某个值为 $x$ 的移动到第一个位置 查询值为 $x$ 的位置 查询位置 $x$ 的值 $1 \leq n \leq 1e8, 1 \leq m \leq 1e5$ 分析看到 $n$ 的范围是 $1e8$，就感觉这题需要离线之后离散化区间了。 每个区间记录一个首元素的值和长度。 对于第一个操作：我们需要找到对应元素，然后将他删除，再放到首节点。 对于第二个操作：将值为 $x$ 的节点旋转到根，左子树的大小就是答案。 对于第三个操作：从根开始查询，根据 $sz$ 来判断应该走哪个儿子。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;bits/stdc++.h&gt;using namespace std;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)using pii = pair&lt;int, int&gt;;const int maxn = 2e5 + 5;int query[maxn];vector&lt;pii&gt; a;#define key_value ch[ch[rt][1]][0]struct Splay &#123; int sz[maxn], ch[maxn][2], fa[maxn]; pii key[maxn]; int rt, tot; int stk[maxn], top; int rev[maxn]; // 区间翻转标记 map&lt;int, int&gt; pos; // 1-index void init() &#123; pos.clear(); tot = top = 0; // 首尾插入两个元素！！！ rt = newnode(0, &#123;-1, 0&#125;); ch[rt][1] = newnode(rt, &#123;-1, 0&#125;); key_value = build(0, a.size() - 1, ch[rt][1]); pushup(ch[rt][1]), pushup(rt); &#125; int build(int l, int r, int p) &#123; if (l &gt; r) return 0; int m = l + r &gt;&gt; 1; int x = newnode(p, a[m]); // a[i] ch[x][0] = build(l, m - 1, x); ch[x][1] = build(m + 1, r, x); pushup(x); return x; &#125; int newnode(int p, pii k) &#123; int x = top ? stk[top--] : ++tot; fa[x] = p, sz[x] = 1, key[x] = k; ch[x][0] = ch[x][1] = 0; pos[k.first] = x; return x; &#125; // d = 0 左旋 void rotate(int x, int d) &#123; int y = fa[x]; ch[y][d ^ 1] = ch[x][d]; fa[ch[x][d]] = y; if (fa[y]) ch[fa[y]][ch[fa[y]][1] == y] = x; fa[x] = fa[y]; ch[x][d] = y; fa[y] = x; pushup(y); &#125; void splay(int x, int goal = 0) &#123; // 旋到 goal 的下面 while (fa[x] != goal) &#123; if (fa[fa[x]] == goal) rotate(x, ch[fa[x]][0] == x); else &#123; int y = fa[x]; int d = ch[fa[y]][0] == y; if (ch[y][d] == x) rotate(x, d ^ 1); else rotate(y, d); rotate(x, d); &#125; &#125; pushup(x); if (!goal) rt = x; &#125; void pushup(int x) &#123; sz[x] = key[x].second; if (ch[x][0]) sz[x] += sz[ch[x][0]]; if (ch[x][1]) sz[x] += sz[ch[x][1]]; &#125; int pre() &#123; int p = ch[rt][0]; while (ch[p][1]) p = ch[p][1]; return p; &#125; int nxt() &#123; int p = ch[rt][1]; while (ch[p][0]) p = ch[p][0]; return p; &#125; void remove(int p) &#123; splay(p); stk[++top] = rt; // 内存回收 if (!ch[rt][0] &amp;&amp; !ch[rt][1]) &#123; rt = 0; return; &#125; if (!ch[rt][0]) &#123; rt = ch[rt][1]; fa[rt] = 0; return; &#125; if (!ch[rt][1]) &#123; rt = ch[rt][0]; fa[rt] = 0; return; &#125; int x = pre(); splay(x); fa[ch[p][1]] = x; ch[x][1] = ch[p][1]; pushup(rt); &#125; void Top(int w) &#123; int p = pos[w]; pii tmp = key[p]; remove(p); splay(1); int x = nxt(); ch[x][0] = newnode(x, tmp); pushup(x); splay(ch[x][0]); &#125; void query(int x) &#123; splay(pos[x]); printf("%d\n", sz[ch[rt][0]] + 1); &#125; void rank(int x) &#123; for (int p = rt; p;) &#123; if (x &lt;= sz[ch[p][0]]) p = ch[p][0]; else &#123; x -= sz[ch[p][0]] + key[p].second; if (x &lt;= 0) &#123; printf("%d\n", key[p].first + x + key[p].second - 1); return; &#125; p = ch[p][1]; &#125; &#125; &#125; void debug(int u) &#123; if (ch[u][0]) debug(ch[u][0]); printf("%d ", key[u].first); if (ch[u][1]) debug(ch[u][1]); &#125;&#125; splay;char op[maxn][10];int main() &#123; int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int n, q; scanf("%d%d", &amp;n, &amp;q); vector&lt;int&gt; num; for (int i = 0; i &lt; q; i++) &#123; scanf("%s%d", op[i], &amp;query[i]); if (op[i][0] == 'R') continue; num.push_back(query[i]); &#125; my_sort_unique(num); a.clear(); int l = 1, r = 1e8 + 5; for (auto &amp;v : num) &#123; if (l &lt; v) a.push_back(&#123;l, v - l&#125;); a.push_back(&#123;v, 1&#125;); l = v + 1; &#125; a.push_back(&#123;l, r - l + 1&#125;); printf("Case %d:\n", kase++); splay.init(); for (int i = 0; i &lt; q; i++) &#123; if (op[i][0] == 'T') &#123; splay.Top(query[i]); &#125; else if (op[i][0] == 'Q') &#123; splay.query(query[i]); &#125; else &#123; splay.rank(query[i]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展埃氏筛]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%89%A9%E5%B1%95%E5%9F%83%E6%B0%8F%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[$[1,n]$ 内素数个数设 $f_i$ 为 $[1,i]$ 内素数个数。因为素数个数等于所有数字减去合数个数，那我们不妨设 $f_i = i-1$。 对于每个 $f_i$，考虑小于等于 $i$ 的合数数量。枚举合数的最小质因子 $p$，$f_i = f_i - (f_{\frac{i}{p}} - f_{p-1})$。 1234567891011121314151617const int maxn = 1e6 + 6;ll f1[maxn], f2[maxn];// [1,n] 内素数个数。 n &lt; 1e12// f1[i]: [1,i] 内素数个数// f2[i]: [1,n/i] 内素数个数ll CalPrime(ll n) &#123; ll sn = sqrt(n); for (int i = 1; i &lt;= sn; i++) f1[i] = i - 1, f2[i] = n / i - 1; for (ll i = 2; i &lt;= sn; i++) &#123; if (f1[i] == f1[i - 1]) continue; for (int j = 1; j &lt;= sn / i; j++) f2[j] -= f2[j * i] - f1[i - 1]; for (int j = sn / i + 1; j &lt;= n / (i * i) &amp;&amp; j &lt;= sn; j++) f2[j] -= f1[n / (j * i)] - f1[i - 1]; for (int j = sn; j &gt;= i * i; j--) f1[j] -= f1[j / i] - f1[i - 1]; &#125; return f2[1];&#125; $[1,n]$ 内素数和原理和上面一样，只不过式子变了一下。 $f_i = f_i - (f_{\frac{i}{p}} - f_{p-1}) \times p$ 123456789101112131415161718192021222324252627const int maxn = 1e6 + 6;const int mod;const ll inv2;ll f1[maxn], f2[maxn];inline ll presum(const ll&amp; x) &#123; return (1 + x) * x % mod * inv2 % mod; &#125;// [1,n] 内素数和 + 1。 n &lt; 1e12// f1[i]: [1,i] 内素数和 + 1// f2[i]: [1,n/i] 内素数和 + 1ll CalPrime(ll n) &#123; if (!n) return 0; ll sn = sqrt(n); for (int i = 1; i &lt;= sn; i++) f1[i] = presum(i), f2[i] = presum(n / i); for (ll i = 2; i &lt;= sn; i++) &#123; if (f1[i] == f1[i - 1]) continue; for (int j = 1; j &lt;= sn / i; j++) f2[j] = (f2[j] - (f2[j * i] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; for (int j = sn / i + 1; j &lt;= n / (i * i) &amp;&amp; j &lt;= sn; j++) f2[j] = (f2[j] - (f1[n / (j * i)] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; for (int j = sn; j &gt;= i * i; j--) f1[j] = (f1[j] - (f1[j / i] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; &#125; return f2[1];&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>扩展埃氏筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay]]></title>
    <url>%2F2019%2F09%2F05%2FSplay%2F</url>
    <content type="text"><![CDATA[Splay每次访问一个节点后，将该节点旋转到根。均摊下来每次操作的复杂度是 $O(\log(n))$。 理解是关键，因为很多操作都需要自己实现。 函数说明12345678int sz[u]: 以u为根的子树的大小int ch[u][0/1]: u的左/右儿子，值为0时表示没有该儿子。int fa[u]: u的父亲int key[u]: u点所代表的权值int cnt[u]: u点的数量int top: 栈顶（用于内存回收）int rt: 根结点int tot: 树的大小 注意：fa[u] = 0 表示u为根结点ch[u][0/1] = 0 表示没有相应的孩子任何时候都不应该修改 0 这个结点的值 newnode作用：生成一个新结点并返回其编号。参数：父亲结点编号，新结点的值。如果父亲结点编号为0，则该结点为根。返回值：该结点编号。 内存回收：把删除的结点放到栈中，建立新节点的使用可以利用已经删除结点的编号。 get作用：判断该结点是其父亲的哪个节点。参数：结点编号。返回值：0 表示该结点是父亲的左儿子，1 表示该结点是父亲的右儿子。 单独使用时需要判父亲是否为0。 rotate作用：将该结点向祖先旋转一个高度。参数：结点编号。返回值：无 单独使用时需要判父亲是否为0。对于splay操作来说，pushup(x)是多余的。 查询比某个数大（小）的第一个元素先将val插入后，查询根的后继（前驱），最后删除 val 即可。但是常数比较大。 也可以手动寻找。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175struct Splay &#123; int fa[maxn], ch[maxn][2], stk[maxn]; int sz[maxn], key[maxn], cnt[maxn]; int rt, top, tot; // private int newnode(int p = 0, int k = 0) &#123; int x = top ? stk[top--] : ++tot; if (p) ch[p][key[p] &lt; k] = x; fa[x] = p, sz[x] = 1, key[x] = k, cnt[x] = 1; ch[x][0] = ch[x][1] = 0; return x; &#125; void pushup(int x) &#123; if (!x) return; sz[x] = cnt[x]; if (ch[x][0]) sz[x] += sz[ch[x][0]]; if (ch[x][1]) sz[x] += sz[ch[x][1]]; &#125; int get(int x) &#123; return x == ch[fa[x]][1]; &#125; void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (z) ch[z][get(y)] = x; fa[x] = z, fa[y] = x; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y; pushup(y), pushup(x); &#125; // pubilc void init() &#123; rt = top = tot = 0; ch[rt][0] = ch[rt][1] = 0; cnt[rt] = sz[rt] = fa[rt] = 0; &#125; // 旋到 goal 的下面 void splay(int x, int goal = 0) &#123; for (int f = fa[x]; f = fa[x], f != goal; rotate(x)) &#123; if (fa[f] != goal) rotate(get(x) == get(f) ? f : x); &#125; if (!goal) rt = x; &#125; // 查询第k小的节点。 1-index // [1,2,2,3] kth(3) = 2 int kth(int k) &#123; for (int p = rt; p;) &#123; if (k &lt;= sz[ch[p][0]]) p = ch[p][0]; else &#123; k -= sz[ch[p][0]] + cnt[p]; if (k &lt;= 0) &#123; splay(p); return p; &#125; p = ch[p][1]; &#125; &#125; // k &gt; 树的大小，或者 k &lt; 1 return 0; &#125; // 查询值小于val的结点数量。 1-index // val不一定存在于Splay中 int rank(int val) &#123; int ret = 0; for (int p = rt; p;) &#123; if (val &lt; key[p]) p = ch[p][0]; else &#123; ret += sz[ch[p][0]]; if (val == key[p]) &#123; splay(p); return ret; &#125; ret += cnt[p]; p = ch[p][1]; &#125; &#125; return ret; &#125; // 插入值为val的节点 void insert(int val) &#123; for (int p = rt, f = 0;; f = p, p = ch[p][key[p] &lt; val]) &#123; if (!p) &#123; int x = newnode(f, val); pushup(x), pushup(f), splay(x); break; &#125; if (key[p] == val) &#123; cnt[p]++; pushup(p), pushup(f), splay(p); break; &#125; &#125; &#125; // 前驱节点，若返回0，则表示无前驱 int pre() &#123; int p = ch[rt][0]; while (ch[p][1]) p = ch[p][1]; return p; &#125; // 后继节点，若返回0，则表示无后继 int nxt() &#123; int p = ch[rt][1]; while (ch[p][0]) p = ch[p][0]; return p; &#125; // 找到值为val的结点，并将其旋转到根 bool find(int val) &#123; for (int p = rt; p;) &#123; if (key[p] == val) &#123; splay(p); return true; &#125; if (val &lt; key[p]) p = ch[p][0]; else p = ch[p][1]; &#125; return false; &#125; // 删除值为val的节点 void remove(int val) &#123; if (!find(val)) return; // 若找到则将其旋转到根 if (cnt[rt] &gt; 1) &#123; --cnt[rt], pushup(rt); return; &#125; stk[++top] = rt; // 内存回收 if (!ch[rt][0] &amp;&amp; !ch[rt][1]) &#123; rt = 0; return; &#125; if (!ch[rt][0]) &#123; rt = ch[rt][1]; fa[rt] = 0; return; &#125; if (!ch[rt][1]) &#123; rt = ch[rt][0]; fa[rt] = 0; return; &#125; int x = pre(), p = rt; splay(x); fa[ch[p][1]] = x; ch[x][1] = ch[p][1]; pushup(rt); &#125; // 找到第一个严格大于 val 的元素。 int bigger(int val) &#123; int ret = 1e9; for (int p = rt; p;) &#123; if (key[p] &gt; val) &#123; ret = min(ret, key[p]); p = ch[p][0]; &#125; else p = ch[p][1]; &#125; return ret; &#125;&#125; splay; Splay 维护区间根据区间顺序进行建树，树型决定了偏序关系。与区间内元素的取值无关。 那么如果我们要处理区间 $[l,r]$ 的信息。我们可以通过先将 $l-1$ 旋转到根，再将 $r+1$ 旋转到根的儿子。这样 $r+1$ 左边这棵树就是区间 $[l,r]$。 为了不特判边界情况，我们可以在首尾各插入一个哨兵节点。 比如注意哨兵节点，注意 $pushdown$ 和 $pushup$，注意修改的时候别忘了修改父亲。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#define key_value ch[ch[rt][1]][0]int a[maxn];struct Splay &#123; int sz[maxn], ch[maxn][2], fa[maxn]; int key[maxn], stk[maxn]; bool rev[maxn]; int rt, tot; void pushup(int x) &#123; sz[x] = 1 + sz[ch[x][0]] + sz[ch[x][1]]; &#125; void pushr(int x) &#123; swap(ch[x][0], ch[x][1]); rev[x] ^= 1; &#125; void pushdown(int x) &#123; if (rev[x]) &#123; if (ch[x][0]) pushr(ch[x][0]); if (ch[x][1]) pushr(ch[x][1]); rev[x] = 0; &#125; &#125; // 1-index void init(int n) &#123; tot = top = 0; for (int i = 1; i &lt;= n; i++) a[i] = i; // 首尾插入两个哨兵结点 rt = newnode(0, -1); ch[rt][1] = newnode(rt, -1); key_value = build(1, n, ch[rt][1]); pushup(ch[rt][1]), pushup(rt); &#125; int build(int l, int r, int p) &#123; if (l &gt; r) return 0; int m = l + r &gt;&gt; 1; int x = newnode(p, a[m]); ch[x][0] = build(l, m - 1, x); ch[x][1] = build(m + 1, r, x); pushup(x); return x; &#125; int newnode(int p = 0, int k = 0) &#123; int x = ++tot; fa[x] = p, sz[x] = 1, key[x] = k; ch[x][0] = ch[x][1] = 0; rev[x] = 0; return x; &#125; int get(int x) &#123; return x == ch[fa[x]][1]; &#125; void rotate(int x) &#123; int y = fa[x], z = fa[y], d = get(x); if (z) ch[z][get(y)] = x; fa[x] = z, fa[y] = x; ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y; ch[x][d ^ 1] = y; pushup(y), pushup(x); &#125; void splay(int x, int goal = 0) &#123; int top = 0; stk[++top] = x; for (int i = x; i != goal; i = fa[i]) stk[++top] = fa[i]; for (int i = top; i; i--) pushdown(stk[i]); for (int f = fa[x]; f = fa[x], f != goal; rotate(x)) &#123; if (fa[f] != goal) rotate(get(x) == get(f) ? f : x); &#125; if (!goal) rt = x; &#125; // 返回序列中第 k-1 个节点（有哨兵），1-index int kth(int r, int k) &#123; pushdown(r); int t = sz[ch[r][0]] + 1; if (t == k) return r; return t &gt; k ? kth(ch[r][0], k) : kth(ch[r][1], k - t); &#125; // 选择区间 [l,r], key_value 为区间 [l,r] 的根节点 void select(int l, int r) &#123; splay(kth(rt, l), 0); splay(kth(ch[rt][1], r - l + 2), rt); &#125; // 后继节点 int nxt() &#123; pushdown(rt); // 记得 pushdown! int p = ch[rt][1]; pushdown(p); while (ch[p][0]) &#123; p = ch[p][0]; pushdown(p); &#125; return p; &#125; // 反转区间 [l,r] void reverse(int l, int r) &#123; select(l, r); pushr(key_value); &#125; // 将区间[l,r]切下，移动到p后面。 void cut(int l, int r, int p) &#123; select(l, r); int tmp = key_value; fa[tmp] = 0; key_value = 0; pushup(ch[rt][1]), pushup(rt); splay(kth(rt, p + 1)); int succ = nxt(); ch[succ][0] = tmp; fa[tmp] = succ; pushup(succ); splay(succ); &#125; // 输出树的时候记得 pushdown!&#125; splay;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李超树]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%9D%8E%E8%B6%85%E6%A0%91%2F</url>
    <content type="text"><![CDATA[标记永久化：不用向上合并？那么查询的时候肯定就要每次都递归到叶子节点，然后在这个递归的过程中取最优值。 李超树从我目前接触的题目看来，李超树主要用于维护凸壳。 考虑这么一个问题： 二维平面上有 $n$ 个操作： 加入一条直线 给定 $x$ 值，查询所有直线对应 $y$ 的最大值 实际上是在维护若干直线组成的下凸壳。 做法： 对 $x$ 坐标轴建立线段树，线段树上的每个节点存储着斜率和截距，表示在当前区间，这条直线的某部分在凸壳上。但由于不确定具体是哪部分，所以我们在查询的时候要查询到叶节点（这也是为什么必须要单点查询），然后在查询的过程中取最值即可。 如何维护： 我们发现并不需要区间信息的合并，即不用向上合并。因为查询是个递归到叶子节点，且依次取最值的过程。 那么对于一个区间，考虑新加进来一条直线后如何修改。 首先应按照斜率的大小来分类分讨论。 设 $[L,R]$ 的中点为 $mid$，那么我们还要按照两条直线在 $mid$ 处的函数值来确定到底是更新左边还是右边。 所以共有四种情况，具体可以看下面的代码。 例题题目链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)const int maxn = 1e5 + 5;struct Node &#123; double k, b;&#125; seg[maxn &lt;&lt; 2];void build(int l, int r, int rt) &#123; seg[rt].b = seg[rt].k = 0; if (l == r) return; int m = l + r &gt;&gt; 1; build(l, m, lson); build(m + 1, r, rson);&#125;double val(const Node &amp;t, int x) &#123; return t.k * (x - 1) + t.b; &#125;void update(int l, int r, int rt, Node x) &#123; if (l == r) &#123; if (val(seg[rt], l) &lt; val(x, l)) seg[rt] = x; return; &#125; int m = l + r &gt;&gt; 1; if (x.k &gt; seg[rt].k) &#123; if (val(x, m) &lt;= val(seg[rt], m)) &#123; update(m + 1, r, rson, x); &#125; else &#123; update(l, m, lson, seg[rt]); seg[rt] = x; &#125; &#125; else &#123; if (val(x, m) &lt;= val(seg[rt], m)) &#123; update(l, m, lson, x); &#125; else &#123; update(m + 1, r, rson, seg[rt]); seg[rt] = x; &#125; &#125;&#125;double query(int l, int r, int rt, int p) &#123; if (l == r) return val(seg[rt], l); int m = l + r &gt;&gt; 1; double ans = val(seg[rt], p); if (p &lt;= m) ans = max(ans, query(l, m, lson, p)); else ans = max(ans, query(m + 1, r, rson, p)); return ans;&#125;int main() &#123; int n; scanf("%d", &amp;n); char op[20]; build(1, maxn, 1); for (int i = 0; i &lt; n; i++) &#123; scanf("%s", op); if (op[0] == 'P') &#123; double k, b; scanf("%lf%lf", &amp;b, &amp;k); update(1, maxn, 1, Node&#123;k, b&#125;); &#125; else &#123; int x; scanf("%d", &amp;x); printf("%d\n", int(query(1, maxn, 1, x)) / 100); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>李超树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F09%2F01%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include &lt;bits/stdc++.h&gt;using namespace std;using uint = unsigned int;template &lt;typename T&gt;struct listNode &#123; T data; listNode&lt;T&gt;*succ, *pred; // successor, predecessor public: listNode() &#123; succ = nullptr, pred = nullptr; &#125; listNode(T data, listNode&lt;T&gt;* s = nullptr, listNode&lt;T&gt;* p = nullptr) : data(data), succ(s), pred(p) &#123;&#125; listNode&lt;T&gt;* insertAsSucc(const T&amp; rhs); // 返回插入后的位置 listNode&lt;T&gt;* insertAsPred(const T&amp; rhs);&#125;;template &lt;typename T&gt;listNode&lt;T&gt;* listNode&lt;T&gt;::insertAsSucc(const T&amp; rhs) &#123; // 插到该节点的后继 listNode&lt;T&gt;* it = new listNode&lt;T&gt;(rhs, succ, this); succ-&gt;pred = it; succ = it; return it;&#125;template &lt;typename T&gt;listNode&lt;T&gt;* listNode&lt;T&gt;::insertAsPred(const T&amp; rhs) &#123; // 插到该节点的前驱 listNode&lt;T&gt;* it = new listNode&lt;T&gt;(rhs, this, pred); pred-&gt;succ = it; pred = it; return it;&#125;// --------------------------------------------------------------------------------------------------template &lt;typename T&gt;class linkList &#123; listNode&lt;T&gt;*header, *trailer; // 尾节点方便尾部插入和删除节点 uint _size; public: linkList(); ~linkList(); T&amp; operator[](uint p) const; // const: 该函数不会修改数据成员 listNode&lt;T&gt;* begin() &#123; return header-&gt;succ; &#125; listNode&lt;T&gt;* end() &#123; return trailer; &#125; listNode&lt;T&gt;* find(const T&amp; data) const; listNode&lt;T&gt;* insertAsFirst(const T&amp; data) &#123; ++_size; return header-&gt;insertAsSucc(data); &#125; listNode&lt;T&gt;* insertAsLast(const T&amp; data) &#123; ++_size; return trailer-&gt;insertAsPred(data); &#125; T remove(listNode&lt;T&gt;* p); listNode&lt;T&gt;* search(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end, const T&amp; data) const; // 找到第一个大于等于data的位置 // 排序算法，左闭右开 void insertionSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end); // 插入排序 void selectionSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end); // 选择排序 listNode&lt;T&gt;* mergeSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end, int n = -1); // 归并排序 void quickSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end); // 快速排序&#125;;template &lt;typename T&gt;linkList&lt;T&gt;::linkList() &#123; header = new listNode&lt;T&gt;; trailer = new listNode&lt;T&gt;; header-&gt;succ = trailer; trailer-&gt;pred = header; _size = 0;&#125;// 如果不throw，可以设置成privatetemplate &lt;typename T&gt;T&amp; linkList&lt;T&gt;::operator[](uint p) const &#123; // if (p &gt;= sz) throw; listNode&lt;T&gt;* now = header-&gt;succ; while (p--) now = now-&gt;succ; return now-&gt;data;&#125;template &lt;typename T&gt;listNode&lt;T&gt;* linkList&lt;T&gt;::find(const T&amp; data) const &#123; listNode&lt;T&gt;* it = header-&gt;nxt; while (it != trailer) &#123; if (it-&gt;data == data) return it; else it = it-&gt;nxt; &#125; return nullptr;&#125;template &lt;typename T&gt;T linkList&lt;T&gt;::remove(listNode&lt;T&gt;* p) &#123; T tmp = p-&gt;data; p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; delete p; --_size; return tmp;&#125;template &lt;typename T&gt;linkList&lt;T&gt;::~linkList() &#123; listNode&lt;T&gt;* it = header; while (it != nullptr) &#123; auto tmp = it-&gt;succ; delete it; it = tmp; &#125; _size = 0;&#125;template &lt;typename T&gt;listNode&lt;T&gt;* linkList&lt;T&gt;::search(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end, const T&amp; data) const &#123; listNode&lt;T&gt;* it = begin; while (it != end) &#123; if (it-&gt;data &gt;= data) return it; it = it-&gt;succ; &#125; return end;&#125;template &lt;typename T&gt;void linkList&lt;T&gt;::insertionSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end) &#123; if (begin == end) return; listNode&lt;T&gt;* head = begin; listNode&lt;T&gt;* it = begin-&gt;succ; while (it != end) &#123; listNode&lt;T&gt;* p = search(head, it, it-&gt;data); // 找到第一个大于等于data的位置 p-&gt;insertAsPred(it-&gt;data); // 插入到它的前驱 if (p == head) head = p-&gt;pred; listNode&lt;T&gt;* succ = it-&gt;succ; remove(it); it = succ; &#125;&#125;template &lt;typename T&gt;void linkList&lt;T&gt;::selectionSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end) &#123; if (begin == end) return; listNode&lt;T&gt;* it = begin; while (it != end) &#123; listNode&lt;T&gt;*p = it-&gt;succ, *Min = it; while (p != end) &#123; if (p-&gt;data &lt; Min-&gt;data) Min = p; p = p-&gt;succ; &#125; if (it == Min) it = it-&gt;succ; else it-&gt;insertAsPred(Min-&gt;data), remove(Min); &#125;&#125;template &lt;typename T&gt;listNode&lt;T&gt;* linkList&lt;T&gt;::mergeSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end, int n) &#123; // 默认参数写在定义中 if (n == -1) &#123; // 计算长度 n = 0; listNode&lt;T&gt;* it = begin; while (it != end) ++n, it = it-&gt;succ; &#125; if (begin == end || n &lt; 2) return begin; int mid = n / 2; listNode&lt;T&gt;* midNode = begin; for (int i = 0; i &lt; mid; i++) midNode = midNode-&gt;succ; begin = mergeSort(begin, midNode, mid); midNode = mergeSort(midNode, end, n - mid); // 因为有删除操作，因此merge后首节点可能会改变。所以函数要返回排序后的首节点。 listNode&lt;T&gt;*l1 = begin, *l2 = midNode; // 注意判断条件， 因为有删除操作，所以不能判 l1 != minNode， 而要判 l1 != l2。 while (l1 != l2 &amp;&amp; l2 != end) &#123; if (l1-&gt;data &lt;= l2-&gt;data) &#123; l1 = l1-&gt;succ; &#125; else &#123; l1-&gt;insertAsPred(l2-&gt;data); if (l1 == begin) begin = l1-&gt;pred; l2 = l2-&gt;succ; remove(l2-&gt;pred); &#125; &#125; return begin;&#125;template &lt;typename T&gt;void linkList&lt;T&gt;::quickSort(listNode&lt;T&gt;* begin, listNode&lt;T&gt;* end) &#123; if (begin == end || begin-&gt;succ == end) return; // 没有元素或只有一个元素 bool isSorted = true; // 检查是否已经排好序，特判序列元素全相等的情况。 listNode&lt;T&gt;* p = begin-&gt;succ; while (p != end) &#123; if (p-&gt;data &lt; p-&gt;pred-&gt;data) &#123; isSorted = false; break; &#125; p = p-&gt;succ; &#125; if (isSorted) return; listNode&lt;T&gt;* mid = begin; // 选第一个节点作为分界点 p = begin-&gt;succ; while (p != end) &#123; if (p-&gt;data &lt; mid-&gt;data) &#123; mid-&gt;insertAsPred(p-&gt;data); if (mid == begin) begin = mid-&gt;pred; // 首节点会改变 p = p-&gt;succ; remove(p-&gt;pred); &#125; else p = p-&gt;succ; &#125; quickSort(begin, mid); quickSort(mid-&gt;succ, end);&#125;int main() &#123; linkList&lt;int&gt; test; mt19937 rnd(time(0)); int n = 10; for (int i = 0; i &lt; n; i++) test.insertAsLast(rnd()); for (int i = 0; i &lt; n; i++) cout &lt;&lt; test[i] &lt;&lt; ' '; cout &lt;&lt; endl; test.quickSort(test.begin(), test.end()); for (int i = 0; i &lt; n; i++) cout &lt;&lt; test[i] &lt;&lt; ' '; cout &lt;&lt; endl; test.mergeSort(test.begin(), test.end()); for (int i = 0; i &lt; n; i++) cout &lt;&lt; test[i] &lt;&lt; ' '; cout &lt;&lt; endl; test.selectionSort(test.begin(), test.end()); for (int i = 0; i &lt; n; i++) cout &lt;&lt; test[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf102222L Continuous Intervals]]></title>
    <url>%2F2019%2F08%2F31%2Fcf102222L-Continuous-Intervals%2F</url>
    <content type="text"><![CDATA[题目链接 题意给一个长度为 $n$ 的序列 $a$。 问有多少个区间 $[l,r]$ 满足：排序后，相邻两个数之间的差小于等于 $1$。 $1 \leq n \leq 1e5$ 分析首先考虑这个条件怎么用数学的方式表示：设 $cnt$ 为区间内的种类数，那么当 $max - min + 1 = cnt$ 满足时，当前区间就是满足条件的。 而且我们可以发现 $max - min + 1 &gt;= cnt$，所以我们可以枚举右端点，对每个左端点维护 $max - min - cnt$ 的最小值以及相应的数量。 对于 $cnt$：我们只要预处理每个数上一个出现的位置即可，然后做一个区间减法。 对于 $max,min$：我们可以利用单调栈的思想，每次区间加/减一个最值的增量。这样对于每一个右端点都可以处理出来所有后缀的最值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define Lson l, m, lson#define Rson m + 1, r, rsonusing ll = long long;const int maxn = 1e5 + 5;struct Node &#123; ll sum, cnt; ll lazy;&#125; seg[maxn &lt;&lt; 2];int a[maxn];int n;int last[maxn];inline void pushup(int rt) &#123; auto &amp;o = seg[rt], &amp;ls = seg[lson], &amp;rs = seg[rson]; o.sum = min(ls.sum, rs.sum); o.cnt = 0; if (o.sum == ls.sum) o.cnt += ls.cnt; if (o.sum == rs.sum) o.cnt += rs.cnt;&#125;inline void pushdown(int rt) &#123; auto &amp;o = seg[rt], &amp;ls = seg[lson], &amp;rs = seg[rson]; if (!o.lazy) return; ls.sum += o.lazy; rs.sum += o.lazy; ls.lazy += o.lazy; rs.lazy += o.lazy; o.lazy = 0;&#125;void build(int l, int r, int rt) &#123; seg[rt].lazy = 0; if (l == r) &#123; seg[rt].sum = 0; seg[rt].cnt = 1; return; &#125; int m = l + r &gt;&gt; 1; build(Lson); build(Rson); pushup(rt);&#125;void update(int l, int r, int rt, int L, int R, int x) &#123; if (L &gt; R || x == 0) return; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].sum += x; seg[rt].lazy += x; return; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; if (L &lt;= m) update(Lson, L, R, x); if (m + 1 &lt;= R) update(Rson, L, R, x); pushup(rt);&#125;ll query() &#123; if (seg[1].sum == -1) return seg[1].cnt; return 0;&#125;ll work() &#123; ll ret = 0; map&lt;int, int&gt; tmp; for (int i = 1; i &lt;= n; i++) &#123; if (tmp.find(a[i]) == tmp.end()) last[i] = 1; else last[i] = tmp[a[i]] + 1; tmp[a[i]] = i; &#125; stack&lt;int&gt; mx, mi; for (int i = 1; i &lt;= n; i++) &#123; update(1, n, 1, last[i], i, -1); int r = i - 1; int MAX = a[i]; while (!mx.empty() &amp;&amp; a[i] &gt; a[mx.top()]) &#123; int p = mx.top(); mx.pop(); int L; if (mx.empty()) L = 1; else L = mx.top() + 1; update(1, n, 1, L, r, a[i] - a[p]); if (!mx.empty()) r = mx.top(); &#125; mx.push(i); r = i - 1; int MIN = a[i]; while (!mi.empty() &amp;&amp; a[i] &lt; a[mi.top()]) &#123; int p = mi.top(); mi.pop(); int L; if (mi.empty()) L = 1; else L = mi.top() + 1; update(1, n, 1, L, r, a[p] - a[i]); if (!mi.empty()) r = mi.top(); &#125; mi.push(i); ret += query(); &#125; return ret;&#125;int main() &#123; int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); build(1, n, 1); ll ans = work(); printf("Case #%d: %lld\n", kase++, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷4119 [Ynoi2018]未来日记]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B4%9B%E8%B0%B74119-Ynoi2018-%E6%9C%AA%E6%9D%A5%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题意长度为 $n$ 的序列 $a$，有 $m$ 次操作 把区间 $[l,r]$ 内所有 $x$ 变成 $y$ 查询区间 $[l,r]$ 内 $k$ 小值 $1 \leq n,m,a_i \leq 100000$ 分析动态区间第 $k$ 小。 第一道分块题，看着别人的题解抄抄改改总算搞出来了。 首先考虑静态的怎么做。 首先对序列分块，再对值域分块。 $sumVal[i][j]$ 表示前 $i$ 块中，值为 $j$ 的数量。 $sumBlock[i][j]$ 表示前 $i$ 块中，值域在第 $j$ 块的数量。 $cnt[i][j]$ 表示第 $i$ 块中，值为 $j$ 的数量。 考虑询问 $(l,r,k)$ 设 $bl$ 表示 $l$ 所在块，$br$ 表示 $r$ 所在块。如果 $bl=br$，那么直接块内暴力。不然的话这两块是要单独暴力处理的。 我们可以用两个辅助数组来记录 $bl$ 和 $br$ 这两个块的信息。 $c[i]$ 表示 $[l,r]$ 区间内，值为 $j$ 的数量。 $s[i]$ 表示 $[l,r]$ 区间内，值域在第 $j$ 块的数量。 然后我们从小到大枚举值域块，用 $sum$ 来记录数量。 $sum += s[i] + sumBlock[br-1][i] - sumBlock[bl][i]$ 如果 $sum \geq k$，则说明答案当前块内，然后我们在当前块内暴力就可以了。 现在我们考虑动态的情况。 首先考虑对于 $bl$ 和 $br$ 所在的块：这两个块是要暴力修改的。我们应该把这个块内的 $x$ 都变成 $y$ 后再去修改后续的 $sumVal$ 和 $sumBlock$。 然后就是那些中间的块：中间的块肯定不能再暴力了，必须通过打标记的方式来降低复杂度。我们所作的操作是将区间中所有的 $x$ 都变成 $y$。考虑并查集维护每个块中同一个值的所有位置，我们可以把块内的该值出现的第一个位置当作根节点。这样我们在打标记的时候，实际上做的是：找到 $x$ 出现的第一个位置 $pos$，然后使 $a[pos] = y$（合并两个并查集）。 $rt[i][j]$ 表示第 $i$ 块中，值为 $j$ 的第一次出现的位置。 暴力修改块内元素的时候不要忘了更新 $rt$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5, sqrt_maxn = 350;int n, m, K, sz, vsz, a[maxn];int L[sqrt_maxn], R[sqrt_maxn];int fa[maxn];int vblock[maxn]; // 每个值所属的值域块int sumBlock[sqrt_maxn][sqrt_maxn];int sumVal[sqrt_maxn][maxn];int rt[sqrt_maxn][maxn]; // 第i块中，值为j的第一次出现的位置int cnt[sqrt_maxn][maxn]; // 第i块中，值为j的个数int c[maxn], s[sqrt_maxn];int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;int stk[maxn];void update(int id, int l, int r, int x, int y) &#123; // 暴力更新块内 int tmp = 0, top = 0; rt[id][x] = rt[id][y] = 0; for (int i = L[id]; i &lt;= R[id]; i++) &#123; a[i] = a[find(i)]; if (a[i] == x || a[i] == y) stk[++top] = i; &#125; // 不能合并到上面，因为 find() 会改变 for (int i = l; i &lt;= r; i++) if (a[i] == x) a[i] = y, ++tmp; for (int i = 1, t, w; i &lt;= top; i++) &#123; fa[stk[i]] = stk[i]; t = stk[i], w = a[t]; if (!rt[id][w]) rt[id][w] = t; else fa[t] = rt[id][w]; &#125; cnt[id][x] -= tmp, cnt[id][y] += tmp; for (int i = id; i &lt;= K; i++) &#123; sumVal[i][x] -= tmp; sumVal[i][y] += tmp; if (vblock[x] != vblock[y]) sumBlock[i][vblock[x]] -= tmp, sumBlock[i][vblock[y]] += tmp; &#125;&#125;inline void count(int l, int r, int w) &#123; for (int i = l; i &lt;= r; i++) &#123; a[i] = a[find(i)]; c[a[i]] += w; s[vblock[a[i]]] += w; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); sz = 600; vsz = 400; for (int i = 1; i &lt; maxn; i++) vblock[i] = (i + vsz - 1) / vsz; while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); memset(cnt, 0, sizeof(cnt)); memset(rt, 0, sizeof(rt)); K = (n + sz - 1) / sz; for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), fa[i] = i; for (int i = 1; i &lt;= K; i++) &#123; L[i] = (i - 1) * sz + 1, R[i] = min(n, i * sz); for (int j = 1; j &lt;= vsz; j++) sumBlock[i][j] = sumBlock[i - 1][j]; for (int j = 1; j &lt; maxn; j++) sumVal[i][j] = sumVal[i - 1][j]; for (int j = L[i]; j &lt;= R[i]; j++) &#123; if (!rt[i][a[j]]) rt[i][a[j]] = j; else fa[j] = rt[i][a[j]]; ++sumBlock[i][vblock[a[j]]]; ++sumVal[i][a[j]]; ++cnt[i][a[j]]; &#125; &#125; for (int _ = 0, op, l, r, x, y; _ &lt; m; _++) &#123; scanf("%d%d%d", &amp;op, &amp;l, &amp;r); int lb = (l + sz - 1) / sz, rb = (r + sz - 1) / sz; if (op == 1) &#123; scanf("%d%d", &amp;x, &amp;y); if (x == y) continue; if (lb == rb) update(lb, l, r, x, y); else &#123; update(lb, l, R[lb], x, y); update(rb, L[rb], r, x, y); int pre = 0; for (int i = lb + 1; i &lt; rb; i++) &#123; if (rt[i][x]) &#123; if (!rt[i][y]) rt[i][y] = rt[i][x], a[rt[i][x]] = y; else fa[rt[i][x]] = rt[i][y]; rt[i][x] = 0; pre += cnt[i][x]; cnt[i][y] += cnt[i][x]; cnt[i][x] = 0; &#125; sumVal[i][x] -= pre, sumVal[i][y] += pre; if (vblock[x] != vblock[y]) sumBlock[i][vblock[x]] -= pre, sumBlock[i][vblock[y]] += pre; &#125; for (int i = rb; i &lt;= K; i++) &#123; sumVal[i][x] -= pre, sumVal[i][y] += pre; if (vblock[x] != vblock[y]) sumBlock[i][vblock[x]] -= pre, sumBlock[i][vblock[y]] += pre; &#125; &#125; &#125; else &#123; scanf("%d", &amp;x); int sum = 0, ll, rr; if (lb == rb) &#123; count(l, r, 1); for (int i = 1; i &lt;= vsz; i++) &#123; sum += s[i]; if (sum &gt;= x) &#123; sum -= s[i]; ll = (i - 1) * vsz + 1, rr = i * vsz; break; &#125; &#125; for (int i = ll; i &lt;= rr; i++) &#123; sum += c[i]; if (sum &gt;= x) &#123; printf("%d\n", i); break; &#125; &#125; count(l, r, -1); continue; &#125; count(l, R[lb], 1); count(L[rb], r, 1); for (int i = 1; i &lt;= vsz; i++) &#123; sum += s[i] + sumBlock[rb - 1][i] - sumBlock[lb][i]; if (sum &gt;= x) &#123; sum -= s[i] + sumBlock[rb - 1][i] - sumBlock[lb][i]; ll = (i - 1) * vsz + 1; rr = i * vsz; break; &#125; &#125; for (int i = ll; i &lt;= rr; i++) &#123; sum += c[i] + sumVal[rb - 1][i] - sumVal[lb][i]; if (sum &gt;= x) &#123; printf("%d\n", i); break; &#125; &#125; count(l, R[lb], -1); count(L[rb], r, -1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性时间选择]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[线性时间选择在线性时间内求出数组中第 $k$ 小的元素。 该问题可以通过分治来解决： 随机选择数组中的一个元素，把小于它的元素放在它的左边，大于它的元素放在右边（相等的放在左右都可以，尽量保证两边的数量差不多，不然对于数字全相等的情况可能会退化）。 判断递归左边或右边。 可以证明这样期望的复杂度是 $O(n)$ 的。 nth_element() 是线性时间选择在标准库中的实现。 我按照同样的接口简单实现了一下。 一道模板题：hdu 6040 1234567891011121314151617181920212223242526272829303132333435363738// 0-index, O(n)struct Nth_element &#123; mt19937 rnd; int a[maxn]; Nth_element() : rnd(time(0)) &#123;&#125; int RandomizedPartition(int l, int r) &#123; uniform_int_distribution&lt;int&gt; distribution(l, r); // 均匀分布 int pos = distribution(rnd); // 随机选择 swap(a[l], a[pos]); int L = l + 1, R = r; int val = a[l]; while (true) &#123; while (L &lt; r &amp;&amp; a[L] &lt; val) L++; while (l &lt; R &amp;&amp; a[R] &gt; val) R--; if (L &gt;= R) break; swap(a[L], a[R]); L++, R--; &#125; a[l] = a[R]; a[R] = val; return R; &#125; // [l+1,k]的元素都小于等于a[k]，[k+1,r]的元素都大于等于a[k]。 void RandomizedSelect(int l, int r, int k) &#123; if (r - l + 1 &lt;= k) assert(false); if (l == r) return; int pos = RandomizedPartition(l, r); if (pos - l == k) return; else if (pos - l &gt; k) RandomizedSelect(l, pos - 1, k); else RandomizedSelect(pos + 1, r, k - (pos - l + 1)); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>其它算法</category>
      </categories>
      <tags>
        <tag>线性时间选择</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的小记事本]]></title>
    <url>%2F2019%2F08%2F27%2FC-%E7%9A%84%E5%B0%8F%E8%AE%B0%E4%BA%8B%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[NULL 与 nullptr 的区别123int *a = nullptr;int *b = 0;int *c = NULL; 这三种生成空指针的方法是等价的。 nullptr 是一种特殊类型 nullptr_t 的字面值，它可以被转换成任意其他的指针类型。 在新标准下，最好使用 nullptr ，同时尽量避免使用 NULL。因为 NULL 和 0 存在二义性，它们既可以当作空指针（指针类型），又可以当做整型。 1234567void test(int *a, int *b) &#123; cerr &lt;&lt; "1" &lt;&lt; endl; &#125;void test(int *a, int b) &#123; cerr &lt;&lt; "2" &lt;&lt; endl; &#125;int main() &#123; test(nullptr, 0); // 2 test(nullptr, NULL); // 2 NULL 是 long long 类型 test(nullptr, nullptr); // 1&#125; const p 与 const p 的区别int const *p 表示*p是常量，即不能修改*p的内容，但是可以修改p的指向。int * const p 表示p是常量，即不能修改p的指向，但是可以修改*p的内容。 volatilevolatile int i; 表示i是易变的，不允许编译器对其优化，每次用i都要从其地址中读取。12volatile int i = 10;int j = i, k = i; 对上述代码，编译器会优化为：在j赋值之后，会将此时的i值保存下来，从而在对k赋值的时候，就不需要重新访问i的地址了。但如果i声明为易变的变量，就表示i的值随时可能发生变化（比如寄存器变量，或某个端口的数据），在两次调用期间可能i值会发生改变。 C++内存空间划分 代码段：用来存放程序的执行代码。 数据段： BSS段：用来存放程序中未初始化的外部变量和未初始化的静态局部变量。 静态数据区：存放已初始化的外部变量，静态局部变量和常量。 堆空间：存放程序执行中动态分配的内存段。存放全局对象。 栈空间：存放局部变量，函数参数和函数返回地址等。 new与malloc的区别new是操作符，分配内存后会调用构造函数。malloc是库函数，单纯分配一块内存，需要进行类型转换。 mutablemutable int i; 表示i是永远可变的，即使i是某个const对象的数据成员。 友元关系的特点 友元关系是非传递的，例如类B是类A的友元类，类C是类B的友元类，在类C和类A之间并无友元关系。 友元关系是单向的，例如类B是类A的友元类，但是类A的成员函数不能访问类B的私有和保护数据。 友元关系不能继承。 类模板和模板类函数模板与类模板的区别：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf102059D Dumae]]></title>
    <url>%2F2019%2F08%2F26%2Fcf102059D-Dumae%2F</url>
    <content type="text"><![CDATA[题意$n$ 个人排队，每个人都不知道自己是第几位，但每个人有一个给定的区间，表示这个人的名次一定在这个区间内。同时有 $m$ 个关系表示他们的偏序（谁在谁的前面）。求一种可行的方案。 分析首先判断给出的 $m$ 个二元关系是否会构成环，如果构成环则说明误解。然后在逆拓扑序上 DP 求出每个人最大的位置，$\displaystyle R_u = \min_{(u, v) \in e} {R_v - 1}$ 接着再进行一次拓扑排序，使用两个优先队列，第一个队列存放所有度为零的点，当某个点的 $L_u \leq i$ 时，丢进第二个优先队列中（满足 $L_u$ 的限制），从第二个优先队列中贪心地选取 $R_u$ 最小的点放在当前位置，并删边。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e5 + 5;int L[maxn], R[maxn], d[maxn];vector&lt;int&gt; G[maxn];bool vis[maxn]; int n, m;bool topo() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) if (d[i] == 0) q.push(i); int cnt = q.size(); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto &amp;v : G[u]) &#123; d[v]--; if (d[v] == 0) &#123; q.push(v); cnt++; &#125; &#125; &#125; return cnt == n;&#125;int dfs(int u) &#123; if (vis[u]) return R[u]; vis[u] = 1; for (auto &amp;v : G[u]) R[u] = min(R[u], dfs(v) - 1); return R[u];&#125;int ans[maxn], dd[maxn];using pii = pair&lt;int, int&gt;;bool solve() &#123; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq[2]; for (int i = 1; i &lt;= n; i++) if (!dd[i]) pq[0].push(&#123;L[i], i&#125;); int id = 1; while (!pq[0].empty() || !pq[1].empty()) &#123; while (true) &#123; if (pq[0].size() == 0) break; auto it = pq[0].top(); int u = it.second; if (L[u] &gt; id) break; pq[0].pop(); pq[1].push(&#123;R[u], u&#125;); &#125; if (pq[1].empty()) break; if (!pq[1].empty()) &#123; auto it = pq[1].top(); pq[1].pop(); int u = it.second; if (R[u] &lt; id) return false; ans[id++] = u; for (auto &amp;v : G[u]) &#123; dd[v]--; if (dd[v] == 0) &#123; pq[0].push(&#123;L[v], v&#125;); &#125; &#125; &#125; &#125; return id == n + 1;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d%d", L + i, R + i); for (int i = 0, u, v; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); d[v]++; dd[v]++; &#125; if (topo() == false) &#123; puts("-1"); return 0; &#125; for (int i = 1; i &lt;= n; i++) R[i] = dfs(i); bool ok = solve(); if (!ok) puts("-1"); else for (int i = 1; i &lt;= n; i++) printf("%d\n", ans[i]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf102059G Fascination Street]]></title>
    <url>%2F2019%2F08%2F26%2Fcf102059G-Fascination-Street%2F</url>
    <content type="text"><![CDATA[题意路上有 $n$ 盏灯，点亮一盏灯的花费是 $w_i$。你可以交换 $k$ 次。要求最小化花费，使得每个位置左右或自己至少有一个位置的灯点亮。 分析首先，一定是交换一个点亮的灯和不点亮的灯。其次，每个位置是否点灯取决于之前两个位置的状态。 令 $dp[i][S][a][b]$ 表示考虑到第 $i$ 个位置，上两个位置的情况为 $S$ ，换出 $a$ 个点亮的灯，换入 $b$ 个不点亮的灯的最小代价。 转移一共有四种，点亮、不点亮、点亮后换出、不点亮并换来一个点亮的。 需要注意初始化的边界，复杂度 $O(nk^2)$ 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int maxn = 3e5 + 5;ll dp[maxn][2][2][10][10];int w[maxn];int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d", w + i); memset(dp, 0x3f, sizeof(dp)); dp[1][1][0][0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int a = 0; a &lt; 2; a++) &#123; for (int b = 0; b &lt; 2; b++) &#123; for (int x = 0; x &lt;= k; x++) &#123; for (int y = 0; y &lt;= k; y++) &#123; ll &amp;v = dp[i][a][b][x][y]; dp[i + 1][b][1][x][y] = min(dp[i + 1][b][1][x][y], v + w[i]); if (a + b &gt; 0) dp[i + 1][b][0][x][y] = min(dp[i + 1][b][0][x][y], v); if (a + b &gt; 0 &amp;&amp; x + 1 &lt;= k) dp[i + 1][b][0][x + 1][y] = min(dp[i + 1][b][0][x + 1][y], v + w[i]); if (y + 1 &lt;= k) dp[i + 1][b][1][x][y + 1] = min(dp[i + 1][b][1][x][y + 1], v); &#125; &#125; &#125; &#125; &#125; ll ans = 1e18; for (int a = 0; a &lt; 2; a++) for (int b = 0; b &lt; 2; b++) for (int x = 0; x &lt;= k; x++) if (a + b &gt; 0) ans = min(ans, dp[n + 1][a][b][x][x]); printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图全局最小割]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%97%A0%E5%90%91%E5%9B%BE%E5%85%A8%E5%B1%80%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[无向图的割无向图的割：在联通无向图 $G$ 中，通过割去一些边使得 $G$ 变成两个连通分量，则称那些边为 $G$ 的一个割。 全局最小割：所有割中权值和最小的割。 Stoer-Wagner 算法算法基于这样一个事实：对于图中的任意两点 $s,t$，它们要么在全局最小割的同侧，要么在全局最小割的两侧。 每次从图中任意找一个最小割 $(s,t)$，然后更新答案。 然后将 $(s,t)$ 两点合并。 继续找最小割，直到只剩余一个点为止。 证明还在学习（意思就是大概率咕咕 时间复杂度：$O(n ^ 3)$ 模板题 poj 2914 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// O(n^3) 1-index// 不能有负权边（可以改成加偏移的，不过有点烦struct StoerWagner &#123; int n; int mask[maxn]; // 因为有删点的操作，所以用mask[i]来表示第i个位置是几号点 int G[maxn][maxn]; // 邻接矩阵 int d[maxn]; // 表示集合到各个点的距离 bool vis[maxn]; // 该点是否加入了集合 void init(int n) &#123; this-&gt;n = n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] = 0; &#125; void addedge(int u, int v, int c) &#123; G[u][v] += c; G[v][u] += c; &#125; int solve() &#123; int res = INF; for (int i = 1; i &lt;= n; i++) mask[i] = i; while (n &gt; 1) &#123; int k, pre = 1; // 默认1号点是集合的第一个点 for (int i = 1; i &lt;= n; i++) vis[mask[i]] = 0, d[mask[i]] = 0; vis[mask[pre]] = true; for (int i = 2; i &lt;= n; i++) &#123; k = -1; for (int j = 1; j &lt;= n; j++) &#123; // 寻找距离最远的点加入集合 if (!vis[mask[j]]) &#123; d[mask[j]] += G[mask[pre]][mask[j]]; if (k == -1 || d[mask[k]] &lt; d[mask[j]]) k = j; &#125; &#125; vis[mask[k]] = true; // 加入集合 if (i == n) &#123; // 只剩一个点 res = min(res, d[mask[k]]); for (int j = 1; j &lt;= n; j++) &#123; // 修改边权 G[mask[pre]][mask[j]] += G[mask[j]][mask[k]]; G[mask[j]][mask[pre]] += G[mask[j]][mask[k]]; &#125; mask[k] = mask[n--]; // 去掉最后加入的点 &#125; pre = k; &#125; &#125; return res; &#125;&#125; sw;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf1207F Remainder Problem]]></title>
    <url>%2F2019%2F08%2F25%2Fcf1207F-Remainder-Problem%2F</url>
    <content type="text"><![CDATA[题目链接 题意$n$ 个数，初始值都为 $0$，有 $q$ 个操作： $(1,x,y)$: $a_x = a_x + y$ $(2,x,y)$: 计算 $\sum_{i \in R(x,y)}a_i$， $R(x,y)$ 表示模 $x$ 余 $y$ 的数的集合 $1 \leq q \leq 500000, 1 \leq n \leq 500000$ 分析 并不知道有什么数据结构可以直接维护模 $x$ 余 $y$ 的数的集合。 模 $x$ 余 $y$ 这个条件，对于 $x$ 较大的时候，符合条件的数字很少。 所以我们可以按根号分块，对于 $x$ 较小的那部分，我们直接维护 $b[x][y]$ 表示模 $x$ 余 $y$ 的答案，这样更新是 $sqrt(n)$ 的；对于 $x$ 较大的那部分，我们直接维护 $a[i]$ 表示这个数字的值，然后每次 $sqrt(n)$ 的查询答案。 代码123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int maxn = 5e5 + 5;const int N = 1e3 + 5;const int gap = sqrt(maxn);int a[maxn];int b[N][N];int main() &#123; // memset(b, 0, sizeof(b)); int q; scanf("%d", &amp;q); for (int _ = 0, op, x, y; _ &lt; q; _++) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; a[x] += y; for (int i = 1; i &lt; gap; i++) &#123; b[i][x % i] += y; &#125; &#125; else &#123; ll ans = 0; if (x &gt;= gap) &#123; for (int i = 0; y + i * x &lt; maxn; i++) &#123; ans += a[y + i * x]; &#125; &#125; else &#123; ans = b[x][y]; &#125; printf("%lld\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA10806 Dijkstra, Dijkstra.]]></title>
    <url>%2F2019%2F08%2F22%2FUVA10806-Dijkstra-Dijkstra%2F</url>
    <content type="text"><![CDATA[题目链接 题意求一条 $s$ 到 $t$ 的最短往返路，要求不能走重复的边。 分析考虑网络流中的退流操作。 先跑一遍s到t的最短路，然后把这条路的权值都更新为正无穷，保证之后不会再走第二遍。然后把相应地反向边的权值变成相反数。 再跑一次s到t的最短路，此时如果走到之前的反向边，则相当于“退流”。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; pii;int G[maxn][maxn];int p[maxn], d[maxn];int n, m;void dijsktra(int s, int t) &#123; for (int i = 1; i &lt;= n; i++) d[i] = INF; d[s] = 0; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq; pq.push(make_pair(0, s)); while (!pq.empty()) &#123; pii now = pq.top(); pq.pop(); int v = now.second; if (d[v] &lt; now.first) continue; for (int i = 1; i &lt;= n; i++) &#123; if (G[v][i] &lt; INF) &#123; if (d[i] &gt; d[v] + G[v][i]) &#123; d[i] = d[v] + G[v][i]; p[i] = v; pq.push(&#123;d[i], i&#125;); &#125; &#125; &#125; &#125;&#125;int main() &#123; while (~scanf("%d", &amp;n)) &#123; if (!n) break; memset(G, 0x3f, sizeof(G)); scanf("%d", &amp;m); for (int i = 0, u, v, t; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;t); G[u][v] = t; G[v][u] = t; &#125; dijsktra(1, n); int ans = d[n]; p[1] = -1; for (int u = n; u != 1; u = p[u]) &#123; G[p[u]][u] = INF; G[u][p[u]] *= -1; &#125; dijsktra(1, n); ans += d[n]; if (ans &gt;= INF) puts("Back to jail"); else printf("%d\n", ans); &#125;&#125;/*211 2 999331 3 102 1 203 2 509121 2 101 3 101 4 102 5 103 5 104 5 105 7 106 7 107 8 106 9 107 9 108 9 100*/]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu3251 Being a Hero]]></title>
    <url>%2F2019%2F08%2F20%2Fhdu3251-Being-a-Hero%2F</url>
    <content type="text"><![CDATA[题目链接 题意有 $n$ 个城市，编号为 $[1,n]$，有 $m$ 条有向边，每条边有个权值 $w_i$，给定一个大小为 $f$ 的点集 $V$，每个点都有一个权值 $c_i$，你可以从中选择一些点并获得它的权值。但是要求从 $1$ 号点出发，不能够到达任何你选的点。你可以在选点之前切掉一些边，切掉边的代价为边的权值。最后获得的价值为所选点的权值和减去切掉边的权值和。 求获得的最大价值，以及应该选择切掉哪些边？ $1 \leq n \leq 10^3, 1 \leq m \leq 10^5$ 分析类似最大权闭合子图的建图。 将所有边反向，然后建立源点 $s$，对于点集 $V$ 中的每个点 $u$，建立 $(s,u)$ 容量为权值的边。 我们先默认 $V$ 中所有的点都被选，然后考虑要去掉哪些点或去掉哪些边。 这实际上就成为了一个最小割的问题。 在上面的建图中跑最小割。 如果割的是从源点出发的边，则表示这个点不会被选。如果割的是其它边，则表示需要割掉这些边。 挺经典的建图，如果忘了可以去复习最大权闭合子图的建图方式。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e5;const int INF = 0x3f3f3f3f;int edge_id[maxn];struct Edge &#123; int u, v, cap, flow; Edge(int u = 0, int v = 0, int c = 0, int f = 0) : u(u), v(v), cap(c), flow(f) &#123;&#125;&#125;;struct Dinic &#123; int n, s, t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn], cur[maxn]; void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt;= n; i++) G[i].clear(); edges.clear(); &#125; int addEdge(int u, int v, int c) &#123; edges.push_back(&#123;u, v, c, 0&#125;); edges.push_back(&#123;v, u, 0, 0&#125;); int m = edges.size(); G[u].push_back(m - 2); G[v].push_back(m - 1); return m - 2; &#125; bool BFS() &#123; for (int i = 0; i &lt;= n; i++) d[i] = 0; d[s] = 1; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); int v; for (auto &amp;id : G[u]) &#123; auto &amp;e = edges[id]; v = e.v; if (!d[v] &amp;&amp; e.cap &gt; e.flow) &#123; d[v] = d[u] + 1; q.push(v); &#125; &#125; &#125; if (d[t]) return true; return false; &#125; int DFS(int u, int f) &#123; if (u == t || f == 0) return f; int v, a, flow = 0; for (int &amp;i = cur[u]; i &lt; G[u].size(); i++) &#123; auto &amp;e = edges[G[u][i]]; v = e.v; if (d[v] == d[u] + 1 &amp;&amp; (a = DFS(v, min(f, e.cap - e.flow))) &gt; 0) &#123; e.flow += a; edges[G[u][i] ^ 1].flow -= a; flow += a; f -= a; if (f == 0) break; &#125; &#125; return flow; &#125; int MaxFlow(int s, int t) &#123; this-&gt;s = s, this-&gt;t = t; int flow = 0; while (BFS()) &#123; for (int i = 0; i &lt;= n; i++) cur[i] = 0; flow += DFS(s, INF); &#125; return flow; &#125; bool vis[maxn]; int edge_id[maxn]; // 每条边的编号 vector&lt;int&gt; cut; // 割边的编号 void findCut(int m) &#123; cut.clear(); for (int i = 0; i &lt;= n; i++) vis[i] = 0; queue&lt;int&gt; q; q.push(s); vis[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto &amp;id : G[u]) &#123; auto &amp;e = edges[id]; if (!vis[e.v] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.v] = 1; q.push(e.v); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; auto &amp;e = edges[edge_id[i]]; if (vis[e.u] == vis[e.v]) continue; if (e.cap == e.flow) cut.push_back(i + 1); // 1-index &#125; &#125;&#125; dinic;int main() &#123; int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int n, m, f; scanf("%d%d%d", &amp;n, &amp;m, &amp;f); int s = 0, t = 1; dinic.init(n); for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edge_id[i] = dinic.addEdge(v, u, w); &#125; int sum = 0; for (int i = 0, u, w; i &lt; f; i++) &#123; scanf("%d%d", &amp;u, &amp;w); sum += w; dinic.addEdge(s, u, w); &#125; int flow = dinic.MaxFlow(s, t); printf("Case %d: %d\n", kase++, sum - flow); dinic.findCut(m); printf("%d", dinic.cut.size()); for (int i = 0; i &lt; dinic.cut.size(); i++) &#123; printf(" %d", dinic.cut[i]); &#125; puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疑问句]]></title>
    <url>%2F2019%2F08%2F20%2F%E7%96%91%E9%97%AE%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[“Who she is” and “Who is she” ?They are both right. However, the meanings are different, and that’s why they are both correct. “Who she is” describes precisely that - who she is. eg. Cruel is a good word to tell you who she is. “Who is she” is used as a question to find out more about her. eg. “I’ve seen that woman somewhere before. Who is she?” Sandy is amazing, that is just who she is, she can get anyone to buy a car. Who is she? The girl in the pink dress. He is such a nice guy all the time, is that just who he is? Is that the man you like, who is he?]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu6677 度度熊与组题]]></title>
    <url>%2F2019%2F08%2F19%2Fhdu6677-%E5%BA%A6%E5%BA%A6%E7%86%8A%E4%B8%8E%E7%BB%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 题意给定 $2n$ 个数，平均分成两组，每组 $n$ 个数。将每组按从小到大排序，求使得 $\sum_{i=1}^{n} |a_i - b_i|$ 最小的方案数，答案模 $10^9+7$。 $ 1 \leq n \leq 10^5$ 分析设 $dp[v]$ 表示值小于等于 $v$ 的数已经完成分组的方案数。 可以发现将小于等于 $v$ 的数分组后，两组大小之差的绝对值不会超过 $1$。 简单证明： 设 o 表示小于等于 $v$ 的数字， x表示大于 $v$ 的数字。 对于下面这种情况：12ooxxxoooox 可以通过置换可以变为：12oooxxoooxx 而显然后者答案更优。 设等于 $v$ 的数字有 $k$ 个，小于 $v$ 的数字有 $t$ 个。 如果 $k$ 为奇数，且 $t$ 为奇数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2}$ 如果 $k$ 为奇数，且 $t$ 为偶数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2} \times 2$ 如果 $k$ 为偶数，且 $t$ 为奇数，则转移为： $dp[v] = dp[v-1] \times (C_{k}^{k / 2} + C_{k}^{k / 2 + 1})$ 如果 $k$ 为偶数，且 $t$ 为偶数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2}$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int mod = 1e9 + 7;const int maxn = 2e5 + 5;int a[maxn];ll dp[maxn], f[maxn];ll Pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;inline ll inv(ll x) &#123; return Pow(x, mod - 2); &#125;ll C(ll n, ll m) &#123; if (n &lt; m) return 0; return f[n] * inv(f[m] * f[n - m] % mod) % mod;&#125;int main() &#123; f[0] = 1; for (int i = 1; i &lt; maxn; i++) f[i] = f[i - 1] * i % mod; int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; 2 * n; i++) scanf("%d", a + i); int p = 0; dp[0] = 1; for (int i = 1; i &lt;= 2 * n; i++) &#123; int k = 0, t; while (p &lt; 2 * n &amp;&amp; a[p] &lt;= i) &#123; k++; p++; &#125; t = p - k; if (t &amp; 1) &#123; if (p &amp; 1) &#123; dp[i] = dp[i - 1] * (C(k, k / 2) + C(k, k / 2 + 1)) % mod; &#125; else &#123; dp[i] = dp[i - 1] * C(k, k / 2) % mod; &#125; &#125; else &#123; if (p &amp; 1) &#123; dp[i] = dp[i - 1] * C(k, k / 2) % mod * 2LL % mod; &#125; else &#123; dp[i] = dp[i - 1] * C(k, k / 2) % mod; &#125; &#125; &#125; printf("%lld\n", dp[2 * n]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>题目</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应辛普森积分]]></title>
    <url>%2F2019%2F08%2F13%2F%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[辛普森积分在求图像面积的时候我们通常会使用定积分，但对于一些图像我们很难求出其定积分，那么我们就可以使用辛普森公式进行计算。 辛普森公式的思想是在一段小区间内，用二次函数去逼近原函数，这样的效果往往比用矩形/梯形逼近更好。 $$\int_a^bf(x)\text{d}x\approx\int_a^b(Ax^2+Bx+C)\text{d}x$$ $$\int_a^bf(x)\text{d}x\approx\frac{(b-a)(f(a)+f(b)+4f(\frac{a+b}2))}6$$ 自适应为了满足精度的要求，采用三点式辛普森法。 对于一段区间 $[a,b]$，我们取其终点 $mid$。 如果 $fabs(ans(a,b) - (ans(a,mid) + ans(mid, b))) \leq 15 \times eps$，我们认为其满足了精度要求，不然则要继续细分区间。 123456789101112131415double F(double x) &#123;&#125;double simpson(double a, double b) &#123; // 三点Simpson法 double c = a + (b - a) / 2; return (F(a) + 4 * F(c) + F(b)) * (b - a) / 6;&#125;double asr(double a, double b, double eps, double A) &#123; //自适应Simpson公式（递归过程）。已知整个区间[a,b]上的三点Simpson值A double c = a + (b - a) / 2; double L = simpson(a, c), R = simpson(c, b); if (fabs(L + R - A) &lt;= 15 * eps) return L + R + (L + R - A) / 15.0; return asr(a, c, eps / 2, L) + asr(c, b, eps / 2, R);&#125;double asr(double a, double b, double eps) &#123; return asr(a, b, eps, simpson(a, b));&#125; 题目洛谷 4525， 4526 可以测试模板。]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>辛普森积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2019%2F08%2F06%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结自《背包九讲》 01背包有 $N$ 种物品，每种物品只有一件，第 $i$ 件物品的体积是 $c_i$，价值是 $w_i$。你现在有一个容量为 $V$ 的背包，求解将这些物品装入背包可获得的最大价值。 思想$dp[i][j]$: 表示前 $i$ 件物品中选若干件，放入容量为 $j$ 的背包中，可获得的最大价值。 考虑第i件物品放或不放，那么转移就是： $$dp[i][j] = Max(dp[i-1][j], dp[i-1][j-c_i] + w_i)$$ 优化1因为我们发现当前状态只和上一个状态相关，因此第一维实际上只要存 $2$ 个数即可。 优化2我们通过转移的顺序发现，如果我们倒过来进行转移，只需要一维即可。 初始化问题如果是恰好装满， 那么 $dp[0][i]$ 都要初始化为 $0$， 而其他都要初始化为负无穷。 如果是不必装满，那么 $dp[0][i]$ 要初始化为 $0$， 其他的会在转移的时候计算，不需要初始化。 变形容量和价值换一换，$dp[i][j]$:表示前i件物品，价值为j的最小容量。 一样做。 可达性背包问 $N$ 种物品，每种物品只有一件，你有一个容量为 $V$ 的背包，问可以组成的价值的种类数。 需要用 $bitset$ 优化。 $bitset$ 中的每一位表示这个价值是否能达到。 12345678910111213141516bitset&lt;maxn&gt; bt[2][maxn];for (int j = 0; j &lt;= V; j++) &#123; bt[0][j].reset(); bt[1][j].reset();&#125;for (int i = 1; i &lt;= N; i++) &#123; int id = i &amp; 1; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) bt[id][j] = bt[id ^ 1][j]; else bt[id][j] |= bt[id ^ 1][j - c[i]].set(w[i]); &#125;&#125;cout &lt;&lt; bt[N &amp; 1][V].count() &lt;&lt; endl; 代码12345678910111213141516171819202122232425262728293031323334353637383940// 恰好装满clr(dp,0xc0); // 初始化负无穷clr(dp[0],0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = c[i]; j &lt;= V; j++) &#123; dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); &#125;&#125;// 不必装满clr(dp[0], 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]); &#125;&#125;// 优化1clr(dp[0], 0);for (int i = 1; i &lt;= N; i++) &#123; int id = i &amp; 1; for (int j = 0; j &lt;= V; j++) &#123; if (j &lt; c[i]) dp[id][j] = dp[id ^ 1][j]; else dp[id][j] = max(dp[id ^ 1][j], dp[id ^ 1][j - c[i]] + w[i]); &#125;&#125;cout &lt;&lt; dp[N &amp; 1][V] &lt;&lt; endl;// 优化2clr(dp, 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = V; j &gt;= c[i]; j++) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125;&#125;cout &lt;&lt; dp[V] &lt;&lt; endl; 完全背包有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限个。第 $i$ 种物品的的体积是 $c_i$,价值是 $w_i$。 求解将这些物品装入背包可获得的最大价值。 思想它和01背包类似，但又不完全相同。 $dp[i][j]$ 表示前 $i$ 个物品，装入容量为 $j$ 的背包可获得的最大价值。 它的转移可能是由 $dp[i-1][j - k \times c_i] + k \times w_i$ 转移过来的， 如果去枚举 $k$ ,那么复杂度必定爆炸。 换一种转移：$dp[i][j] = max(dp[i][j-c_i] + w_i, dp[i-1][j])$ 观察转移式，我们可以继续优化：$dp[j] = Max(dp[j], dp[j-c_i]+w_i)$ 代码123456clr(dp, 0);for (int i = 1; i &lt;= N; i++) &#123; for (int j = c[i]; j &lt;= V; j++) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125;&#125; 多重背包有 $N$ 种物品和一个容量为 $V$ 的背包，第 $i$ 种物品有 $m_i$ 件可用，第 $i$ 种物品的体积是 $c_i$,价值是 $w_i$。 求背包能装下的最大价值。 思想通过拆分每种物品，使其变成 $01$ 背包。 假如某种物品有 $k$ 件， 那么可以拆分成: $2^0, 2^1, 2^2… 2^t, k - 2^t$ 这么多种新的物品。 然后做 $01$ 背包即可。 复杂度 $O(NVlog(M))$ 代码123456789101112131415161718192021int _N = 0;for (int i = 1; i &lt;= N; i++) &#123; // 拆分 for (int j = 0;; j++) &#123; if (m[i] &gt; (1 &lt;&lt; j)) &#123; m[i] -= (1 &lt;&lt; j); _c[_N] = (1 &lt;&lt; j) * c[i]; _w[_N] = (1 &lt;&lt; j) * w[i]; _N++; &#125; else break; &#125; _c[_N] = m[i] * c[i]; _w[_N] = m[i] * w[i]; _N++;&#125;clr(dp, 0);for (int i = 1; i &lt; _N; i++) &#123; // 01背包 for (int j = V; j &gt;= _c[i]; j++) &#123; dp[j] = max(dp[j], dp[j - _c[i]] + _w[i]); &#125;&#125; 可行性问题若问题变为：是否能填满容量为 $V$ 的背包。 则就变成了可行性问题，是可以 $O(VN)$ 解出的。 $dp[i][j]$ 表示前 $i$ 种物品，填满容量为 $j$ 的背包后，第 $i$ 种物品的剩余数量 $dp[i][j] = -1$ 表示不可行 1234567891011121314clr(dp[0], -1);dp[0][0] = 0;for (int i = 1; i &lt;= N; i++) &#123; for (int j = 0; j &lt;= V; j++) &#123; if (dp[i - 1][j] &gt;= 0) dp[i][j] = m[i]; else dp[i][j] = -1; &#125; for (int j = 0; j &lt;= V - c[i]; j++) &#123; if (dp[i][j] &gt; 0) dp[i][j + c[i]] = max(dp[i][j + c[i]], dp[i][j] - 1); &#125;&#125; 混合背包有 $N$ 种物品和一个容量为 $V$ 的背包， 每种物品，有的只有一件，有的有多件，有的有无限件。 求能装下的最大价值。 思想多重背包可以通过拆分变成 $01$ 背包，那么最后问题实际上就是 $01$ 背包和无限背包的混合。 1234567for i = 1 : n if i 为01背包 for j = V : c[i] dp[j] = max(dp[j], dp[j-c[i]] + w[i]); if i 为无限背包 for j = c[i] : V dp[j] = max(dp[j], dp[j-c[i]] + w[i]); 分组背包有 $N$ 件物品和一个容量为 $V$ 的背包。第 $i$ 件物品的体积是 $c_i$,价值是 $w_i$。这些物品被划分为 $K$ 组，每组中的物品互相冲突，最多选一件。 求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。 思想$dp[i][j]$:表示用前 $i$ 组的物品填容量为 $j$ 的背包，能得到的的最大价值。 那么对于每组来说，就有选一件或者不选两种决策。 时间复杂度 $O(VN)$ 12345for k = 1 : K for j = V : 0 for item in k if(j &gt;= c[item]) dp[j] = max(dp[j], dp[j - c[item]] + w[item]); 依赖背包每个物品都有依赖关系，如果 $i$ 依赖于 $j$，那么要买 $i$ 物品，必须先买 $j$ 物品。 限制条件： 每个物品最多只能依赖一件物品；没有循环依赖。 称每个有依赖的为附件，没有依赖的为主件。 思想先考虑简化版，即每个附件都没有附件。 那么对于每个主件所在的物品集合里，我们可以先跑一次01背包，得到每个费用可得到的最大价值。然后把每个$(cost, val), c_i \leq cost \leq V $ 看作一个新的物品。这样问题就转化成了分组背包。 再考虑普通版，即每个附件也可能存在附件。 解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先LCA]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA%2F</url>
    <content type="text"><![CDATA[倍增法可以在树上直接倍增求 $LCA$，查询复杂度是 $O(\log (n))$ 经常在倍增时维护其他信息。 1234567891011121314151617181920212223242526272829const int BASE = 20;int dep[maxn]; // 深度int par[maxn][BASE + 1];void dfs(int u, int fa) &#123; dep[u] = dep[fa] + 1; par[u][0] = fa; for (auto&amp; v : G[u]) &#123; if (v == fa) continue; dfs(v, u); &#125;&#125;void init(int n) &#123; for (int j = 1; j &lt;= BASE; j++) for (int i = 1; i &lt;= n; i++) &#123; int v = par[i][j - 1]; par[i][j] = par[v][j - 1]; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[v]) swap(u, v); for (int i = BASE; i &gt;= 0; i--) if (dep[par[v][i]] &gt;= dep[u]) v = par[v][i]; // 先跳到同一高度 if (u == v) return u; for (int i = BASE; i &gt;= 0; i--) if (par[u][i] != par[v][i]) u = par[u][i], v = par[v][i]; // 一起向上跳 return par[u][0];&#125; ST表法将树型转化为区间形式，然后再 $RMQ$ 所查区间内深度最小的点，即为 $lca$ 查询 $2$ 与 $3$ 的 $lca$ 时，会查询其 $dfs$ 序上区间 $dfn$ 的最小值。 1234567891011121314151617181920212223242526272829303132333435363738// 预处理 O(nlogn), 查询 O(1)const int maxn = 1e6+5;struct LCA &#123; vector&lt;int&gt; G[maxn], sp; int dep[maxn], dfn[maxn]; pii dp[21][maxn &lt;&lt; 1]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) G[i].clear(); sp.clear(); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; void dfs(int u, int fa) &#123; dep[u] = dep[fa] + 1; dfn[u] = sp.size(); sp.push_back(u); for (auto &amp;v : G[u]) &#123; if (v == fa) continue; dfs(v, u); sp.push_back(u); &#125; &#125; void initRmq() &#123; int n = sp.size(); for (int i = 0; i &lt; n; i++) dp[0][i] = &#123;dfn[sp[i]], sp[i]&#125;; for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++) for (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + (1 &lt;&lt; (i - 1))]); &#125; int lca(int u, int v) &#123; int l = dfn[u], r = dfn[v]; if (l &gt; r) swap(l, r); int k = 31 - __builtin_clz(r - l + 1); return min(dp[k][l], dp[k][r - (1 &lt;&lt; k) + 1]).second; &#125;&#125; lca; Tarjan网上看到一篇很详细的 blog，带有模拟过程，所以自己就不再写啦（懒癌.. Tarjan 算法是离线的，时间复杂度为 O(n+q) 参考博客 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 1000000;struct LCA &#123; vector&lt;int&gt; G[maxn]; vector&lt;pii&gt; Q[maxn]; bool vis[maxn]; int par[maxn], dist[maxn], ANS[maxn]; int find(int u) &#123; return u == par[u] ? u : par[u] = find(par[u]); &#125; void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; par[v] = u; &#125; &#125; void init(int n, int m) &#123; for (int i = 0; i &lt; n + 1; i++) &#123; G[i].clear(); vis[i] = false; par[i] = i; &#125; for (int i = 0; i &lt; m + 1; i++) Q[i].clear(); &#125; void add_edge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void add_query(int u, int v, int id) &#123; Q[u].pb(mp(v, id)); Q[v].pb(mp(u, id)); &#125; void Tarjan(int u, int fa) &#123; vis[u] = true; for (auto v : G[u]) &#123; if (fa != v) &#123; Tarjan(v, u); merge(u, v); // 注意合并顺序，一定是v合并到u上 &#125; &#125; for (auto V : Q[u]) &#123; if (vis[V.first] == true) &#123; ANS[V.second] = find(V.first); // 公共祖先为par[v] &#125; &#125; &#125;&#125; lca;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F07%2F25%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[转自线性基学习笔记 概述基（basis） 是线性代数中的一个概念，它是描述、刻画向量空间的基本工具。而在现行的 OI 题目中，通常在利用基在异或空间中的一些特殊性质来解决题目，而这一类题目所涉及的知识点被称作「线性基」。 先说明一点，$a_i$，表示一个标量，而加粗的 $\mathbf{a}_i$，表示一个向量，以便于区分。 预备知识向量空间（vector space）向量空间 - 维基百科 定义 ($F, V, +, \cdot$) 为向量空间（vector space），其中 $F$ 为域，$V$ 为集合，$V$ 中元素称为向量，$+$ 为向量加法，$\cdot$ 为标量乘法，且运算满足 8 条公理（见维基百科）。 线性无关（linearly independent）线性无关 - 维基百科 对于向量空间中 $V$ 上 $n$ 个元素的向量组 ($\mathbf{v}_1, \ldots, \mathbf{v}_n$)，若存在不全为 $0$ 的数 $a_i \in F$，满足$$a_{1}\mathbf {v} {1}+a{2}\mathbf {v} {2}+\ldots +a{n}\mathbf {v} _{n} = 0$$则称这 $n$ 个向量线性相关（linearly dependent），否则称为线性无关（linearly independent）。 张成（span）对于向量空间中 $V$ 上 $n$ 个元素的向量组 ($\mathbf{v}_1, \ldots, \mathbf{v}_n$)，其所有线性组合所构成的集合称为 ($\mathbf{v}_1, \ldots, \mathbf{v}_n$) 的张成（span），记为 $\mathrm{span}(\mathbf{v}_1, \ldots, \mathbf{v}_n$)。 基（basis）若向量空间 $V$ 中向量组 $\mathfrak{B}$ 既是线性无关的又可以张成 $V$，则称其为 $V$ 的基（basis）。 $\mathfrak {B}$ 中的元素称为基向量。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 性质设 $\mathfrak {B}$ 是向量空间 $V$ 的基。则 $\mathfrak {B}$ 具有以下性质： $V$ 是 $\mathfrak {B}$ 的极小生成集，就是说只有 $\mathfrak {B}$ 能张成 $V$，而它的任何真子集都不张成全部的向量空间。 $\mathfrak {B}$ 是 $V$ 中线性无关向量的极大集合，就是说 $\mathfrak {B}$ 在 $V$ 中是线性无关集合，而且 $V$ 中没有其他线性无关集合包含它作为真子集。 $V$ 中所有的向量都可以按唯一的方式表达为 $\mathfrak {B}$ 中向量的线性组合。 第三点尤其重要，感性的理解，基就是向量空间中的一个子集，它可以通过唯一的线性组合，来张成向量空间中所有的向量，这样就可以大大的缩小我们向量空间的大小。 线性基对于数 $a_0, a_1, \ldots, a_n$，将 $a_i$ 的二进制表示 $a_i = (b_{m}\ldots b_0)_2$ 看作一个向量 $\mathbf{a}_i = (b_m, \ldots, b_0)$，为了叙述上的方便，下文称向量 $\mathbf{a}_i$ 的第 $j$ 位为 $b_j$。 向量组 $\mathbf{a}_1, \ldots, \mathbf{a}_n$ 可以张成一个向量集合 $\mathrm{span}(\mathbf{a}_1, \ldots, \mathbf{a}_n)$，加上我们的异或运算和乘法运算（显然满足 8 条公理），即可形成一个向量空间 $V = ({0, 1}, \mathrm{span}(\mathbf{a}_1, \ldots, \mathbf{a}_n), \oplus, \cdot)$。 我们考虑求出向量空间 $V$ 的一个基 $\mathfrak{B}$，从 $\mathfrak{B} = (\mathbf{a}_1, \ldots, \mathbf{a}_n)$ 开始。 第 1 步：如果 $\mathbf{a}_1 = \mathbf{0}$ ，则从 $\mathfrak{B}$ 中去掉 $\mathbf{a_1}$​ ，否则保持 $\mathfrak{B}$ 不变。 第 j 步：若 $\mathbf{a}_j \in \mathrm{span}(\mathbf{a}1, \ldots, \mathbf{a}{j - 1})$，则从 $\mathfrak{B}$ 中去掉 $\mathbf{a}_j$​​ ，否则保持 $\mathfrak{B}$ 不变。 经过 $n$ 步后终止程序，得到一个向量组 $\mathfrak{B}$。由于每一次去掉的向包含于前面诸向量的张成，到最后这个组 $\mathfrak{B}$ 仍然可以张成 $V$。而且这一程序确保了 $\mathfrak{B}$ 中的任何向量都不包含与它前面诸向量的张成，根据线性相关性引理可知 $\mathfrak{B}$ 是线性无关的。于是 $\mathfrak{B}$ 是 $V$ 的一个基。 利用高斯消元来判断向量能否被前面的向量张成，就可以写出下面的程序： 12345678910111213141516void cal() &#123; for (int i = 0; i &lt; n; ++i) for (int j = MAX_BASE; j &gt;= 0; --j) if (a[i] &gt;&gt; j &amp; 1) &#123; if (b[j]) a[i] ^= b[j]; else &#123; b[j] = a[i]; for (int k = j - 1; k &gt;= 0; --k) // 消元 if (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; 1)) b[j] ^= b[k]; for (int k = j + 1; k &lt;= MAX_BASE; ++k) if (b[k] &gt;&gt; j &amp; 1) b[k] ^= b[j]; break; &#125; &#125;&#125; 当然消元或者不消元影响并不大，因此也可以写成这样： 123456789101112131415161718192021222324struct LB &#123; int basis[MAX_BASE + 1]; LB() &#123; memset(basis, 0, sizeof(basis)); &#125; int query() &#123; int ret = 0; for (int i = MAX_BASE; i &gt;= 0; i--) &#123; ret = max(ret, ret ^ basis[i]); &#125; return ret; &#125; bool insert(int x) &#123; for (int i = MAX_BASE; i &gt;= 0 &amp;&amp; x; --i) if (x &gt;&gt; i &amp; 1) &#123; if (basis[i]) x ^= basis[i]; else &#123; basis[i] = x; return true; &#125; &#125; return false; &#125; void clear() &#123; memset(basis, 0, sizeof(basis)); &#125;&#125;; 线性基求交集严格的说法是两个线性空间求交集。 两个线性空间的交集仍然是线性空间，那么必然可以用一组线性基来描述。 假设 $V_1$ 和 $V_2$ 是两个线性空间，他们的基分别是 $B_1$ 和 $B_2$。 令 $W = B_2 \cap V_1$，若 $B_1 \cup (B_2 - W)$ 线性无关，则 $W$ 是 $V_1 \cap V_2$的一组基。 我们可以枚举 $B_2$ 中的元素，若和 $B_1$ 线性无关，则插入到 $B_1$ 中。 否则把 $V_1$ 对该元素的贡献加到答案中。 12345678910111213141516171819202122232425262728293031323334353637383940LB Intersect(LB A, LB B) &#123; LB All, C, D; All.clear(); C.clear(); D.clear(); for (int i = MAX_BASE; i &gt;= 0; i--) &#123; All.basis[i] = A.basis[i]; D.basis[i] = 1ll &lt;&lt; i; &#125; for (int i = MAX_BASE; i &gt;= 0; i--) &#123; if (B.basis[i]) &#123; int v = B.basis[i], k = 0; bool can = true; for (int j = MAX_BASE; j &gt;= 0; j--) &#123; if (v &amp; (1ll &lt;&lt; j)) &#123; if (All.basis[j]) &#123; v ^= All.basis[j]; k ^= D.basis[j]; &#125; else &#123; can = false; All.basis[j] = v; D.basis[j] = k; break; &#125; &#125; &#125; if (can) &#123; int v = 0; for (int j = MAX_BASE; j &gt;= 0; j--) &#123; if (k &amp; (1ll &lt;&lt; j)) &#123; v ^= A.basis[j]; &#125; &#125; C.insert(v); &#125; &#125; &#125; return C;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[树的重心（质心）：最大子树最小；到所有点距离最小； 性质： 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 一棵树最多有两个重心，且相邻。 每棵子树的大小不超过 $\frac{n}{2}$ 点分治 每次做子树间的信息，然后递归去做子树内的信息。 为了防止树的退化，可以在每次递归的时候找子树重心，这样保证递归层数不超过$\log n$ 一般是统计路径数，需要维护所有点到根的一个信息，然后对每个子树去计算在其它子树中的贡献。还有根的贡献可能需要单独算。 动态点分治 把重心相互连接起来，构成点分树。 首先要明确原树和点分树之间的区别：点分树中的每个结点都是原树中某个子树的重心。 用点分树的结点去保存信息，这样在修改的时候只要向上跳$\log $次即可。 最后还是要明确：点分治（重心分治）的目的就是通过改变树型，使得只要$\log$次即可从根跳到叶子。并没有什么太多的技巧。 树上权值和小于等于k的路径数 poj1741 树上权值和为k的倍数的路径数 bzoj2152 树上权值和为素数的路径数 PRIMEDST 树上游戏 动态点分治： 捉迷藏 幻想乡战略游戏 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const int maxn = 1e5 + 5;int rt, ans, treesz;bool vis[maxn];vector&lt;pii&gt; G[maxn];int heavySonSz[maxn], sz[maxn];vector&lt;int&gt; nodes;// 找重心// rt = 0, heavySonSz[rt] = INF, treeSz = n;void getRoot(int u, int fa) &#123; sz[u] = 1, heavySonSz[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].first; if (vis[v] || v == fa) continue; getRoot(v, u); sz[u] += sz[v]; heavySonSz[u] = max(heavySonSz[u], sz[v]); &#125; heavySonSz[u] = max(heavySonSz[u], treesz - sz[u]); if (heavySonSz[u] &lt; heavySonSz[rt]) rt = u;&#125;void dfsSub(int u, int fa, int val) &#123; // 对子树中每个点的操作 nodes.push_back(u); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].first; int w = G[u][i].second; if (vis[v] || v == fa) continue; dfsSub(v, u, val + w); &#125;&#125;int cal(int u, int val) &#123; // 遍历子树得到想要的信息 nodes.clear(); dfsSub(u, 0, val); int ret = 0; // 计算贡献 for (int i = 0; i &lt; nodes.size(); i++) &#123; &#125; return ret;&#125;void dfs(int u) &#123; vis[u] = 1; ans += cal(u, 0); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].first; if (vis[v]) continue; ans -= cal(v, G[u][i].second); // 减去两端点在同一子树中的贡献 treesz = sz[v], rt = 0, getRoot(v, u); dfs(rt); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复数]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%A4%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[我所理解的复数如同几个世纪之前人们对负数的出现难以接受，虚数的提出也是一件非常难以接受的事情。因为怎么会有一个数的平方是个负数呢？但这个问题既然出现了，说明数学的理论还不够完善。而坦然接受这个事实，建立新的理论来解决问题才是应该采取的措施。 负数的平方根是怎么出现的呢？是一个数学家在解一个一元三次方程的时候遇到的，根据求根公式得到的式子中包含有负数的平方根，虽然最后可以消掉，但这的确和以往的认知不同。因为如果不承认负数可以有平方根，那这个式子就是无意义的，而求根公式是被证明没错的，因此我们需要接受负数的平方根存在（就像接受负数的存在），并给出相应的定义。 复数有实部和虚部，形如$a+bi$，其中$a$是实部，$b$是虚部，其中$i=\sqrt{-1}$。 这样我们就将原本是一维的数字扩展到了二维。 但这样一来就出现了一个问题就是没有办法画函数图像了，因为输入是二维，输出也是二维，图像就是四维的了。显然人是没有办法理解四维的，目前有效的工具是通过黎曼曲面（然后就不会了 复数的性质$z = a + bi$ $|z| = \sqrt{a^2+b^2}$ 极坐标中的表示$z = r \times(cos\theta + isin\theta) = re^{i\theta}$ $z_1 \times z_2 = (r_1r_2)\times(cos(\theta_1+\theta_2) + isin(\theta_1+\theta_2))$ 复数相乘：角度相加，长度相乘。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>复数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整除分块/数论分块]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[整除分块/数论分块$O(\sqrt{N})$的时间复杂度内计算下列式子$$\sum_{i=1}^N \lfloor{\frac{N}{i}}\rfloor$$ 为了加速计算，我们需要计算对于一个固定的取值，有多少种$i$可以选择。 即对于一个$\lfloor{\frac{N}{i}}\rfloor$，要找到最大的$d$，使得$\lfloor{\frac{N}{i}}\rfloor = \lfloor{\frac{N}{i+d}}\rfloor$ 不妨设$ki + p = N$，$k(i+d) + p’ = N$ 那么有$p’ = p - kd$， 因为$p’ \geq 0$，因此$d \leq \lfloor{\frac{p}{k}}\rfloor$ 那么$i + d_{max} = i + \lfloor{\frac{p}{k}}\rfloor = i + \lfloor{\frac{N - ki}{k}}\rfloor = \lfloor{\frac{N}{k}}\rfloor = \lfloor{\frac{N}{\lfloor{\frac{N}{i}}\rfloor}}\rfloor$ 又因为$\lfloor{\frac{N}{i}}\rfloor$的取值不会超过$O(\sqrt{N})$种，因此时间复杂度可以控制在$O(\sqrt{N})$之内。 12345// O(sqrt(n))for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / i); ans += (n / l) * (r - l + 1);&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反演]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[参考文献 我所理解的反演形如$$f(n) = \sum_i g(i)$$ 对于$f(n)$易算的情况下，想要通过$f(n)$得到$g(n)$。即计算出$g(n)$关于$f(n)$的表达式。 这个过程称为反演。 其实一个比较显然的做法就是通过高斯消元直接求解$O(n^3)$，有的时候因为矩阵是个上（下）三角矩阵，因此可以简化复杂度到$O(n^2)$。 但对于数据量比较大的情况，只能手推出反演式再进行计算。 普通反演$$f(n) = \sum_{i=0}^{n}x_ig(i)$$ 写成矩阵形式 $$ \left( \begin{matrix} x_0 &amp; 0 &amp; 0 \\ x_0 &amp; x_1 &amp; 0 \\ x_0 &amp; x_1 &amp; x_2 \end{matrix} \right) \times \left( \begin{matrix} g(0) \\ g(1) \\ g(2) \end{matrix} \right) = \left( \begin{matrix} f(0) \\ f(1) \\ f(2) \end{matrix} \right)$$ 直接高斯消元即可（因为已经是下三角矩阵，因此可以简化为$O(n^2)$ 二项式反演$$f(n) = \sum_{k=0}^n \tbinom{n}{k} g(k)$$ $$g(n) = \sum_{k=0}^{n}(-1)^{n-k}\tbinom{n}{k}f(k)$$ 证明如下： $$g(n) = \sum_{m=0}^n [n-m=0] \tbinom{n}{m} g(m) \tag1 $$ $$\sum_{k=0}^n (-1)^k \tbinom{n}{k} = [n=0] \tag2$$ $[n=0]$表示在只有在$n$为$0$时取值是$1$，否则取值为$0$。 将$(2)$代入$(1)$中 $$g(n) = \sum_{m=0}^n \sum_{k=0}^{n-m}(-1)^k \tbinom{n-m}{k} \tbinom{n}{m} g(m)$$ $\tbinom{n-m}{k} \tbinom{n}{m}$表示从一个大小为$n$的集合拿出两个大小分别为$m$和$k$的子集，它和$\tbinom{n-k}{m} \tbinom{n}{k}$是等价的。 $$g(n) = \sum_{m=0}^n \sum_{k=0}^{n-m}(-1)^k \tbinom{n}{k} \tbinom{n-k}{m} g(m)$$ 交换求和符号 $$g(n) = \sum_{k=0}^n(-1)^k\tbinom{n}{k}\sum_{m=0}^{n-k}g(m)\tbinom{n-k}{m}$$ 最右边的部分实际上是$f(n-k)$ $$g(n) = \sum_{k=0}^n(-1)^k\tbinom{n}{k}f(n-k)$$ 变换下标 $$g(n) = \sum_{k=0}^{n}(-1)^{n-k}\tbinom{n}{k}f(k)$$ 莫比乌斯反演$$f(n) = \sum_{d|n} g(d)$$ $$g(n) = \sum_{d|n} \mu(\frac{n}{d})f(d)$$ 证明如下： $$g(n) = \sum_{m|n}[\frac{n}{m}=1]g(m) \tag3$$ $$\sum_{d|n}\mu(d) = [n=1] \tag4$$ 将$(4)$ 代入$(3)$中 $$g(n) = \sum_{m|n}\sum_{d|\frac{n}{m}}\mu(d)g(m)$$ 交换求和符号 $$g(n) = \sum_{d|n}\mu(d)\sum_{m|\frac{n}{d}}g(m)$$ 最右边的部分是$f(\frac{n}{d})$ $$g(n) = \sum_{d|n}\mu(d)f(\frac{n}{d})$$ 变换下标 $$g(n) = \sum_{d|n} \mu(\frac{n}{d})f(d)$$ 莫比乌斯函数莫比乌斯函数 $$\mu (n) = \begin{cases} 1 \quad (n=0)\\ (-1)^k \quad(n=p_1p_2…p_k)\\ 0 \quad (others) \end{cases}$$ 有性质 $$\sum_{d|n}\mu(d) = [n=1]$$ 子集反演咕咕咕]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>反演</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何交换求和符号]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%A6%82%E4%BD%95%E4%BA%A4%E6%8D%A2%E6%B1%82%E5%92%8C%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[参考：《算两次》——单樽 双重求和符号的交换双重求和实际上可以看作对一个矩阵的求和，只不过矩阵的形态会有不同。 上下三角型矩阵$$\sum_{k=1}^{n} \sum_{i=1}^{k} \frac{a_i}{k}$$ 它的形态就是 $$ \left( \begin{matrix} \frac{a_1}{1} &amp; \frac{a_1}{2} &amp; \frac{a_1}{3} \\ 0 &amp; \frac{a_2}{2} &amp; \frac{a_2}{3} \\ 0 &amp; 0 &amp; \frac{a_3}{3} \end{matrix} \right)$$ 所以我们只要变换行列的求和顺序即可$$\sum_{i=1}^{n} a_i \sum_{k=i}^{n} \frac{1}{k}$$ 对称矩阵$$g(n) = \sum_{m|n}\sum_{d|\frac{n}{m}} \mu(d) g(m) = \sum_{d|n}\sum_{m|\frac{n}{d}}\mu(d)g(m)$$]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRT]]></title>
    <url>%2F2019%2F04%2F24%2FCRT%2F</url>
    <content type="text"><![CDATA[参考博客 中国剩余定理有一次同余方程组 $$\begin{cases} x \equiv r_1\quad mod(m_1)\\x \equiv r_2\quad mod(m_2)\\x \equiv r_3\quad mod(m_3)\\…\end{cases}$$ 条件：$m_i$两两互质。 解法： 设$M=lcm(m_1,m_2,…)$。 设$t_i$满足$t_i \times \frac{M}{m_i} \equiv 1 \quad mod (m_i)$，该方程有解有且当且$m_i$与$\frac{M}{m_i}$互质（证明参考扩展欧几里得算法）。 那么有特解$x = \sum (r_i\times t_i\times \frac{M}{m_i})$。 通解为$x + k\times M (k \in Z)$ 123456789101112131415// mod两两互质// 通解 re + k * M// 返回最小非负整数解void crt(ll r[], ll m[], ll n, ll &amp;re, ll &amp;M)&#123; M = 1, re = 0; for (int i = 0; i &lt; n; i++) M *= m[i]; for (int i = 0; i &lt; n; i++) &#123; ll x, y, tm = M / m[i]; ll d = exgcd(tm, m[i], x, y); re = (re + tm * x * r[i]) % M; &#125; re = (re + M) % M;&#125; 扩展中国剩余定理条件：$m_i$不满足两两互质 解法： 假设已经求得前$k-1$个同余方程的通解$x + k\times M (k \in Z)$，其中$M=\prod_{i=1}^{k-1}m_i$。 那么加入第$k$个方程$x \equiv a_k \quad mod(m_k)$后，新的解满足$x + t\times M \equiv a_k \quad mod(m_k)$，只要求出$t$即可。 求解上述方程可用扩展欧几里得。 若有一个同余方程无解，则整个一次同余方程组无解。 所以我们只要求$k$次扩展欧几里得即可。 12345678910111213141516171819// mod不满足两两互质// 通解为 re + k*M// 返回最小非负整数解bool excrt(ll r[], ll m[], ll n, ll &amp;re, ll &amp;M)&#123; ll x, y; M = m[0], re = r[0]; for (int i = 1; i &lt; n; i++) &#123; ll d = exgcd(M, m[i], x, y); if ((r[i] - re) % d != 0) return 0; x = (r[i] - re) / d * x % (m[i] / d); re += x * M; M = M / d * m[i]; re %= M; &#125; re = (re + M) % M; return 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论基础]]></title>
    <url>%2F2019%2F04%2F14%2F%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[无向图的连通性一些定义在无向连通图 $G$ 上进行如下定义： 割点：若删掉某点 $P$ 后，$G$ 分裂成两个或两个以上的子图，则称 $P$ 为 $G$ 的割点。 割点集合：如果有一个顶点集合，删除这个顶点集合以及与该点集中的顶点相关联的边以后，原图分成多于一个连通块，则称这个点集为 $G$ 的割点集合。 点连通度：最小割点集合的大小称为无向图 $G$ 的点连通度。 割边（桥）：若删掉某条边 $e$ 后，$G$ 分裂成两个或两个以上的子图，则称 $e$ 为 $G$ 的割边（桥）。 割边集合：如果有一个边集合，删除这个边集后，原图分成多于一个连通块，则称这个边集为割边集合。 边连通度：最小割边集合的大小称为无向图 $G$ 的边连通度。 点双连通图：点连通度大于 $1$ 的图称为点双连通图（没有割点）。 边双连通图：边连通度大于 $1$ 的图称为边双连通图（没有割边）。 （点/边）双连通分量：无向图的极大（点/边）双连通子图称为（点/边）双连通分量。 Tarjan 算法Tarjan 基于对图的深度优先搜索，对每个节点引入了两个值： $dfn[u]$：节点 $u$ 的时间戳，记录点 $u$ 是 $DFS$ 过程中第几个访问的节点。 $low[u]:$ 记录节点 $u$ 或 $u$ 的子树 不经过搜索树上的边能够到达的时间戳最小的节点。 维护方法对于每一条与 $u$ 相连的边 $(u,v)$ 若在搜索树上 $v$ 是 $u$ 的子节点，则更新 $low[u] = min ( low[u], low[v] )$ 若 $(u,v)$ 不是搜索树上的边，则更新 $low[u] = min(low[u], dfn[v])$ 求割点对于搜索树上的一条边 $(u,v)$，其中 $u$ 是 $v$ 的父节点，若 $low[v] &gt;= dfn[u]$，则 $u$ 为割点。 $low[v] &gt;= dfn[u]$ 说明从 $v$ 及 $v$ 的子树的点 到以 $u$ 为根的子树之外的点必须要经过点 $u$，因此 $u$ 是割点。 注意： 如果根只有一个孩子，那么它不是割点。 123456789101112131415161718vector&lt;int&gt; G[maxn];int dfs_clock, dfn[maxn];bool iscut[maxn];int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; int child = 0; for (auto &amp;v : G[u]) &#123; if (!dfn[v]) &#123; child++; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &gt;= dfn[u]) iscut[u] = true; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) lowu = min(lowu, dfn[v]); &#125; if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = false; // root return lowu;&#125; 点双联通分量其他定义：对于一个无向连通图，如果任意两点至少存在两条点不重复路径，则称这个图为点双连通的。 可以在求割点的过程中维护一个栈，从而求出每个点双连通分量。 建立一个栈，存储 DFS 过程中访问的节点， 初次访问一个点时把该点入栈。 如果边 $(u,v)$ 满足 $low[v] &gt;= dfn[u]$，即满足了 $u$ 是割点的判断条件，那么把点从栈顶依次取出，直至取出了点 $v$，取出的这些点和点 $u$ 一起组成了一个点双连通分量。 割点可能属于多个点双连通分量，其余点和每条边属于且仅属于一个点双连通分量。因此在从栈中取出节点时，要把 $u$ 留在占中。 整个 $DFS$ 结束后，栈中还剩余的节点构成一个点双联通分量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;int&gt; G[maxn], bcc[maxn];int bcc_cnt, dfs_clock;int dfn[maxn], iscut[maxn], bccno[maxn];stack&lt;pii&gt; stk;int dfs(int u) &#123; int lowu = dfn[u] = ++dfs_clock; int child = 0; for (auto &amp;v : G[u]) &#123; pii e = &#123;u, v&#125;; if (!dfn[v]) &#123; stk.push(e); child++; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &gt;= dfn[u]) &#123; // u为割点 iscut[u] = true; bcc_cnt++; bcc[bcc_cnt].clear(); //注意！bcc从1开始编号 for (;;) &#123; pii x = stk.top(); stk.pop(); if (bccno[x.first] != bcc_cnt) bcc[bcc_cnt].push_back(x.first), bcc[x.first] = bcc_cnt; if (bccno[x.second] != bcc_cnt) bcc[bcc_cnt].push_back(x.second), bcc[x.second] = bcc_cnt; if (x.first == u &amp;&amp; x.second == v) break; &#125; &#125; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123; stk.push(e); lowu = min(lowu, dfn[v]); &#125; &#125; if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = 0; return lowu;&#125;//割点的bccno无意义void solve(int n) &#123; //调用结束后stack保证为空，所以不用清空 memset(iscut, 0, sizeof(iscut)); memset(bccno, 0, sizeof(bccno)); memset(dfn, 0, sizeof(dfn)); dfs_clock = bcc_cnt = 0; for (int i = 0; i &lt; n; i++) if (!dfn[i]) dfs(i, -1);&#125; 注意对每个割点或者割边来说，判定定理可能不止一次成立，所以不要边判定边输出。 割边对于一条搜索树上的边 $(u,v)$，其中 $u$ 是 $v$ 的父节点，若 $low[v] &gt; dfn[u]$，则 $(u,v)$ 是桥。 $low[v]$ 表示 $v$ 和 $v$ 的子树不经过搜索树上的边能够到达的时间戳的最小的节点。 $low[v] &gt; dfn[u]$ 说明从以 $v$ 为根的子树到子树之外的必须要经过边 $(u,v)$，因此 $(u,v)$ 是桥。 可以像求割点一样，当 $v$ 回溯至 $u$ 后，判断上述不等式是否成立。 另一种判断方法：当递归 $v$ 结束时，如果 $low[v] == dfn[v]$ 说明 $v$ 和 $v$ 的父节点之间的边是桥。 注意：在有重边的图上求桥，需要对重边加以区分。需要记录 $(u,fa)$ 的数量，若大于 $1$ 说明有重边，则要设置 $low[u] = dfn[fa]$。 123456789101112131415161718192021vector&lt;pii&gt; G[maxn]; // first: 下一个点， second: 该边的编号int dfs_clock, dfn[maxn];bool iscut[N]; // N: 边数int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; // int father = 0; for (auto &amp;V : G[u]) &#123; int v = V.first; int id = V.second; // 边的编号 // if(v == fa) father++; if (!dfn[v]) &#123; int lowv = dfs(v, u); lowu = min(lowv, lowu); if (lowv &gt; dfn[u]) iscut[id] = true; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) lowu = min(lowu, dfn[v]); &#125; // if(father &gt; 1) return dfn[fa]; return lowu;&#125; 边双联通分量其他定义：对于一个无向连通图，如果任意两点至少存在两条边不重复路径，则称该图为边双连通的。 边双连通分量的求法非常简单，只需在求出所有的桥后，把桥删除。 此时原图分成了若干个连通块，每个连通块就是一个边双连通分量。 桥不属于任何一个边双连通分量。 其余的边和每个顶点都属于且仅属于一个边双连通分量。 12345678910111213141516171819202122232425262728vector&lt;int&gt; G[maxn];int bcc_cnt, dfs_clock;int dfn[maxn], bccno[maxn];stack&lt;int&gt; stk;int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; stk.push(u); bool flag = false; // 有重边 for (auto &amp;v : G[u]) &#123; if (v == fa &amp;&amp; !flag) &#123; flag = true; continue; &#125; if (!dfn[v]) &#123; int lowv = dfs(v, u); lowu = min(lowu, lowv); &#125; else lowu = min(lowu, dfn[v]); &#125; if (lowu == dfn[u]) &#123; bcc_cnt++; // 编号从1开始 while (!stk.empty()) &#123; int v = stk.top(); bccno[v] = bcc_cnt; if (u == v) break; &#125; &#125;&#125; 边双连通分量的构造任意给定一个无向连通图，最少添加多少条边可以把它变为双连通图？ 求出所有的桥和边双连通分量，把每个双连通分量缩成一个点。 此时的图只包含缩点后的双连通分量 和 桥边，是一棵无根树。 统计树中度数为 $1$ 的节点的个数 $cnt$ 。把树变为边双连通图，至少需要添加 $\lceil \frac{cnt}{2} \rceil$ 条边。 构造方法： 设缩点后的叶子为 $v_1, v_2, … , v_n$，让 $v_i$ 与 $v_{i + \lfloor \frac{n}{2} \rfloor}$ 连边即可。 如果相连的两个节点的 $LCA$ 不是根的话，必然会留下一些桥（根到 $LCA$ 的路径上都是桥）。 有向图连通性强连通分量若在一张有向图中，各个点互相可达，则称此图强连通。 最大强连通子图又称强连通分量。 实际问题中，强连通分量往往会被看成一个点来处理(缩点)。 123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;int&gt; G[maxn];int scc, dfs_clock, top; // scc: 强连通分量的数量bool instack[maxn];int dfn[maxn], low[maxn], belong[maxn], Stack[maxn];// int num[maxn]; // 每个强连通分量的数量。 1 ~ scc// int maps[maxn]; //缩点之后 每个点对应的新点的标号void Tarjan(int u) &#123; dfn[u] = low[u] = ++dfs_clock; instack[u] = true; Stack[top++] = u; for (auto &amp;v : G[u]) &#123; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (instack[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; ++scc; int cnt = 0; int now; while (top &gt; 0) &#123; now = Stack[--top]; instack[now] = false; belong[now] = u; ++cnt; if (now == u) &#123; // num[scc] = cnt; // maps[u] = scc; break; &#125; &#125; &#125;&#125;void solve(int n) &#123; memset(instack, 0, sizeof(instack)); memset(dfn, 0, sizeof(dfn)); scc = dfs_clock = top = 0; for (int i = 1; i &lt;= n; i++) &#123; // 点的标号从1开始 if (!dfn[i]) Tarjan(i); &#125;&#125; 有向图的必经结点（割点）（支配树）给定有向图 $G$（可能有环）和图中的一个点 $s$，对于 $G$ 中的任意一个点 $t$，求从 $s$ 到 $t$ 的路径上（可能有很多条）必须经过的点集。 支配树：$(G,s)$ 的支配树是一棵根为 $s$ 的有向树，从 $s$ 出发可以到达 $G$ 中的所有点。$x$ 的必经节点集合 $dom(x)$ 就是支配树上 根 $s$ 到 $x$ 路径上的点集。 一些概念必经点(dom)（割点）： 若从 $s$ 到 $t$ 的路径一定经过点 $x$，则称 $x$ 是从 $s$ 到 $t$ 的必经点（割点），记为 $x\quad dom\quad t$。 从 $s$ 出发到达 $t$ 的所有必经点集合为 $dom(t)$，即 $dom(t) = {x | x\quad dom\quad y}$. 最近必经点(idom)： 节点 $t$ 的必经点集合 $dom(t)$ 中 $dfn$ 值最大的点 $x$ 是距离 $t$ 最近的必经点，称 $x$ 为 $t$ 的最近必经节点。 最近必经点是唯一的，因此可以记 $x = idom(t)$。 半必经点(semi)： 在搜索树 $T$ 上，点 $t$ 的祖先中通过非树边可以到达 $t$ 的且 $dfn$ 最小的祖先 $x$，称为 $t$ 的半必经点。半必经点也是唯一的，因此可以记为 $x = semi(t)$。 半必经点定理： 对于 $G$ 中的一点 $t$，考虑所有 $x \in pre(t)$（前驱），定义一个临时变量 $tmp = INF$。 若 $dfn[x] &lt; dfn[t]$，则 $(x,t)$ 为树边或前向边，此时 $tmp = min(tmp, dfn[x])$。 若 $dfn[x] &gt; dfn[t]$，则 $(x,t)$ 为横叉边或后向边，此时 $x$ 的祖先中所有满足 $dfn[z] &gt; dfn[t]$ 的，有 $tmp = min(tmp, dfn[semi[z]])$。 $semi[t] = id[tmp]$，即在上述所有可能情况中取 $dfn$ 值最小的一种，就是 $t$ 的半必经点。 必经点定理： 对于 $G$ 中的一点 $x$，考虑搜索树 $T$ 中 $semi(x)$ 到 $x$ 的路径上除端点之外的点构成的集合 $path$。 设 $y$ 为 $path$ 中半必经点的时间戳最小的节点。 若 $semi(x) = semi(y)$，则 $idom(x) = semi(x)$。 若 $semi(x) \neq semi(y)$，则 $idom(x) = idom(y)$ Lengauer-Tarjan 算法：通过DFS构建搜索树，并计算出每个节点的时间戳。 根据半必经点定理，按照时间戳从大到小的顺序计算每个节点的半必经节点。 根据必经点定理，按照时间戳从小到大的顺序，把半必经节点 $\neq$ 必经节点的点进行修正。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// dom[i]：（支配树）编号为i的点所支配的最近节点// idom[i]：编号为i的点的最近必经节点// semi[i]：编号为i的点的半必经节点// id[i]：dfn为i的点的编号// best[i]：编号为i的点的祖先中dfn最小的点的编号// pre[i]：编号为i的点的前驱// suc[i]：编号为i的点的后继// son[i]：编号为i的点的儿子struct DomiTree &#123; int dfs_clock; int dfn[maxn], id[maxn], fa[maxn]; int semi[maxn], best[maxn], idom[maxn]; vector&lt;int&gt; pre[maxn], dom[maxn], suc[maxn], son[maxn]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) &#123; pre[i].clear(), dom[i].clear(), suc[i].clear(), son[i].clear(); fa[i] = best[i] = idom[i] = semi[i] = i, dfn[i] = 0; &#125; dfs_clock = 0; &#125; void addedge(int u, int v) &#123; // u -&gt; v pre[v].push_back(u); suc[u].push_back(v); &#125; void build(int s) &#123; dfs(s); tarjan(); &#125; void dfs(int u) &#123; dfn[u] = ++dfs_clock; id[dfs_clock] = u; for (auto &amp;v : suc[u]) &#123; if (dfn[v]) continue; dfs(v); son[u].push_back(v); &#125; &#125; inline int Min(int x, int y) &#123; return dfn[semi[x]] &lt; dfn[semi[y]] ? x : y; &#125; int find(int u) &#123; if (u == fa[u]) return u; int v = find(fa[u]); best[u] = Min(best[fa[u]], best[u]); return fa[u] = v; &#125; void tarjan() &#123; for (int i = dfs_clock; i &gt; 0; i--) &#123; int k = id[i]; for (auto v : pre[k]) &#123; if (dfn[v] == 0) continue; if (dfn[v] &lt; dfn[k] &amp;&amp; dfn[v] &lt; dfn[semi[k]]) semi[k] = v; if (dfn[v] &gt;= dfn[k]) &#123; find(v); semi[k] = semi[Min(best[v], k)]; &#125; &#125; if (k != semi[k]) dom[semi[k]].push_back(k); for (auto &amp;v : dom[k]) &#123; find(v); if (semi[best[v]] == k) idom[v] = k; else idom[v] = best[v]; &#125; dom[k].clear(); for (auto &amp;v : son[k]) fa[v] = k; &#125; for (int i = 2; i &lt;= dfs_clock; i++) &#123; int k = id[i]; if (idom[k] != semi[k]) idom[k] = idom[idom[k]]; if (k != idom[k]) dom[idom[k]].push_back(k); &#125; &#125;&#125; dt; 有向图的必经边（割边）给定有向图 $G$（可能有环）和图中的一个点 $s$，对于 $G$ 中的任意一个点 $t$，求 $s$ 到 $t$ 路径上（可能有多条）的必经边的集合。 无环图做法求 $s$ 到每个点的路径数 $Scnt$，$t$ 到每个点的路径数 $Tcnt$。 若边 $(u,v)$ 满足 $Scnt[u] \times Tcnt[v] = Scnt[t]$，那么 $(u,v)$ 是从 $s$ 到 $t$ 的必经边。 可以对几个大质数取模做上述计算。 有环图做法在 $(u,v)$ 中间加一个点 $w$，然后利用 $Lengauer-Tarjan$ 算法求有向图割点，若 $w$ 是割点，那么 $(u,v)$ 是割边。]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做题记录2019.4]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%952019-4%2F</url>
    <content type="text"><![CDATA[结束啦结束啦~~~~ CF1149-B题意：给你一个长度为$n \leq 1e6$的只包含小写字母的模式串，有 3 个初始长度为 0 的串，有$q \leq 1000$次操作，每次操作可以选择一个串在其尾部增加一个字母或去掉一个字母，回答是否这三个串同时满足是模式串的不重合子序列。每个串的长度不超过 250. 解：一开始光想着贪心选择最靠后的满足条件的字母。但是发现有点问题，只能 dp 了。 dp[i][j][k] 表示第一个串的前 i 个和第二个串的前 j 个和第三个串的前 k 个满足条件的最小模式串长度。由于每次只在最后添加或删除字母，因此只要更新剩下的两维即可，复杂度是 250*250 的。（还是太年轻 同济校赛H-菜哭武的 01 串题意：给你一个长度为$n \leq 1e6$的 01 串，问这个串所有子序列可以表示的最大的连续正整数。 解：序列自动机上 bfs 第一个不能表示的正整数，然后减一。需要记忆化，为什么能够记忆化呢？假设当前点 i 是从之前很多状态转移过来的，因为每次转移都是贪心走字典序最小的，所以只要记录第一次访问 i 的状态即可。 到现在已经用序列自动机解决了两种题目了 判断一个串是否是另一个串的子序列 判断一个串中所有子序列可以表示的最大连续正整数 本质不同子序列个数（感觉 dp 一下当前结点出去的子序列个数，然后求个和 Comet OJ - Contest #2比赛网址 B解：一个小技巧记录一下，就是在精度要求不高的时候比如 1e-4 这种，可以将数据乘 1e4 之后枚举计算，最后结果再除回去就可以。 D题意：记$dist(i,j)$为树上 i 到 j 路径上的边数，设$f(S)=max{dist(x,y) | x,y \in S, x \neq y}$，$S$为点集。对每个 i 求满足$f(S) = i$的点集个数。 $n \leq 2000$ 解：首先我们注意到$f(S)$实际上是点集的直径。对于一个点集，其中所有的直径的中点是一样的（有可能是边，有可能是点）。那么我们可以通过枚举中点（边）和半径来做。由于边不好枚举，因此我们将一条边的中点拿出来，即(u-&gt;v)拆成(u-&gt;m-&gt;v)。这样只要枚举点即可。因为枚举的是半径，那么要求有至少有两个子树中的点被选到。 E题意：有 n 个人在睡觉，第 i 个人有$p_i$的概率自己醒来。第 i 个人向第$to_i$个人中出卖了自己的自由，也就是说当第 i 个人没有睡着时，他会有$s_i$的概率去把第$to_i$个人叫醒。求最终每个人醒来的概率。$2 \leq n \leq 10^5$ 解：不难发现这是一个基环森林。如果不考虑环的存在，那么每个人醒来的概率简单 dp 即可算出。对于有环的情况，我们先用前面的 dp 把当前的基环树缩成一个环。即环上的每个点醒来的概率都是 dp[i]。那么环上的概率怎么算呢？$ans[i] = dp[i] + (1 - dp[i])(dp[i-1]s[i-1]) + (1-dp[i])(1-dp[i-1])(dp[i-2]s[i-2]s[i-1])…$ 意思是：i 点本身醒着的概率+i 点没醒，i-1 点醒了且叫醒了 i 点的概率 + i 和 i-1 点都没醒，i-2 醒了且叫醒了 i-1，i-1 又叫醒了 i 的概率 + … 需要注意的是：为什么不能用$ans[i-1]$去更新$ans[i]$呢？因为$ans[i-1]$表示 i-1 点最终醒来的概率，它是考虑了$i$的影响的。而计算$i$最终醒来的概率是不能考虑$i$对其它人的影响的。 南昌网络赛比赛网址 B题意： 给定$n$个食物，每个食物有个能量$a[i]$。每次查询一个区间$[l,r]$，表示从第$l$个食物开始顺序吃到第$r$个食物得到的能量。要求： 要吃就全部吃完 当前吃的食物的能量只能比上一次吃的食物的能量低 当前食物能吃就吃，不能吃就跳过（原题意中没有这句话，但是没有这句话会理解错题意，导致这题的难度会上升） 一共有$q$个查询，每次给定$l,r,p,c$，分别表示查询吃$[l,r]$区间能获得的能量，吃完之后修改第$p$个食物的值为$c$。 解： $f[rt]$表示线段树中当前结点代表的区间的答案，那么它的转移有两种： 如果$rt$结点的最小值在左子树$lson$中取得，那么$f[rt] = f[lson]$ 不然的话$f[rt] = f[lson] + x$，$x$表示在右子树$rson$中能够获得的能量 接下来考虑如何计算$x$ 设$dfs(x,u)$表示初始值小于$x$，在$u$结点所代表的区间内可获得的能量。 那么上面第二个转移中的转移可以写为$f[rt] = f[lson] + dfs(lson_min, rson)$ 接下来考虑$dfs(x,u)$的状态转移。设$lu$为$u$的左子树，$ru$为$u$的右子树。 如果$x \leq lu_min$，那么$dfs(x,u) = dfs(x, ru)$ 不然$dfs(x,u) = dfs(x,lu) + f[u] - f[lu]$ 这样我更新一个结点的复杂度是$O(\log n)$ 接下来是查询： 首先把要查询区间所包含的所有结点找到，按左端点排序，顺序调用上面的$dfs$加一加就可以了。 更新的话就正常线段树单点更新。 D题意： 给一个长度为$n(\leq 100)$的表达式，只包含数字和加减运算符。每个数字和运算符都是由若干个火柴拼接而成。问在不改变原始表达式的结构（数字的个数，运算符的个数和每个数字的位数）的条件下，通过移动火柴使得新的表达式的值最大。 解： $dp[i][tot][0/1]$表示到第$i$个位置，还剩下$tot$个火柴，上一个运算符是加或减，所能得到的最大值。转移的状态只有十种，注意一下前导零。 I题意： 设一个区间的$val$为这个区间的和乘以这个区间的最小值。给定一个 n 个整数的数组，求它所有子区间中最大的$val$。（有负数） 解: 单调栈搞一下每个数最为最小值的范围，然后线段树维护一下前缀和的最值和后缀和的最值。 M题意： 给一个字符串$S(\leq 100000)$，再给 $n(\leq 100000)$ 个字符串$t_i(\leq 1000)$，判断每个$t_i$是不是$S$的子序列。 解： 卡的有 1 丶丶紧，必须要纯正的$O(nt)$的做法，维护一下$next[i][ch]$从$i$位开始，字符$ch$的下一个出现位置，搞一搞。 原来这就是序列自动机啊（cslnb 2050 大厦 hdu6496题意： 在二维平面上匡一个矩形，给定若干条斜率为 pi/4 和 3pi/4 的直线，问这些直线组成的矩形有多少个在大矩形框内。 解： 将直线分为两个集合$S_1,S_2$，对$S_1$中的每条直线暴力出与$S_2$中每条直线的交点（在大矩形框内。 从$S_1$中任选两条直线，它们合法交点的交集就是这两条直线对答案的贡献 http://acm.hdu.edu.cn/showproblem.php?pid=6496 codeforce 1155 D题意： 给一个数组，求其最大的连续子序列和 解： dp[i][0/1/2]分别表示到第 i 个，还没选/正在选/选完了的状态。http://codeforces.com/contest/1155/problem/D gcj qualification D 交互题意：有 1024 台机器，其中有 15 台坏了，要你猜五次，把这些坏的机器猜出来。每一次猜，可以输入一个只有 0 和 1 的字符串，第 i 位表示发送给第 i 台机器的数字。若机器没坏则它会把原始数据返回给你。 解：如果可以猜十次，那么我可以把[0,1023]遍历一遍。缺少的数字就是坏掉的机器。猜五次的话就要利用只有 15 台坏掉的条件，我们按 16 台一组进行分组，这样不会有一组同时被吞掉。组内枚举[0,15]即可。 夺宝奇兵 秦皇岛 Day1题意：有 n 个人，m 个宝贝，每个宝贝有个价值 w[i]，这 m 个宝贝都在这 n 个人手里。如果想获得某个宝贝，必须从这个人手里花费 w[i]买过来。现在你手上没有宝贝，问至少需要多少钱才可是使得你成为拥有宝物最多（严格大于所有人）的人。 解: 两种策略： 去买那些价值小的宝物 从拥有宝物多的人那里买 显然只考虑一种是不够的，那我们需要同时兼顾这两种策略。 枚举当前人民最多拥有的宝物数，对于那些拥有宝物多的人，要优先购买他们手中价格低的宝物。如果最后拥有的宝物数没有满足条件，则再从所有未购买的宝物中购买价值最低的那些宝物。 用权值线段树去维护宝物的价值。最后均摊复杂度$O(n\log n)$。 树上博弈题意：在基环树上有若干终点，A 先手，A B 轮流移动，A 不能移动到 B 经过过的点上，当 A 到达若干个终点之一时即可获胜。 解：首先如果存在某个终点到 A 的距离比 B 近，那么 A 一定可以赢。不然 A 只能借助环来赢。那么 A 什么情况会赢呢？首先应该是 B 先到环，然后 B 会懵逼，不知道往哪里走，他会随机挑一个方向走。这时候 A 到环上，只要选择另一条路走，这时候 B 再回头可能就晚了，于是 A 就可以赢了。 ccpc final：Balance of the Force 二分+优先队列 贪心题意：有 n 个人，每个人可以选择属性值加$l_i$或者$d_i$，有 k 个限制，每个限制是两个人不能选择一样的（比如都选$l_i$）。现在想要所有人中属性值最大的和最小的的差值尽可能小，求出这个差值。 解：每个限制抽象成一条无向边，那么原图就会形成若干个连通分量。对于一个连通分量他会有两种值，因为一个联通分量里，一个人确定，那么整个联通分量的最大和最小值就确定了。现在我们把每个联通分量的两种取值情况都拿出来$(l_1,r_1)和(l_2,r_2)$。然后我们二分答案，答案确定后，我们将所有的 pair 按最大值($r$)排序，知道最大值后减去答案就是最小值。用个优先队列，队列中按最小值($l$)排序。当队列中 pair 的数量大于一半的时候说明当前答案是可以满足的。 2050 热身赶火车 期望的递归定义题意：一共有 n+m 条路，n 条路正确，走正确的路则 a[i]分钟后会到达终点。走错误的路会浪费 b[i]分钟。走过的路可能会重复走。问期望走到终点的时间？ 解: 用递归的定义写出期望的表达式，然后就可以解出期望。$EX = \frac{\sum a[i]}{n + m} + \frac{\sum b[i] + mEX}{n+m} $ 定理证明 递归解题题意: 有 n 个定理，现在要顺序写出一些推理关系，使得最终这个 n 个定理相互可达。怎么写可以写出最多的推理关系？比如 3 个定理：可以写成 4 条(1-&gt;2,2-&gt;3,3-&gt;2,2-&gt;1)，也可以写成 5 条(1-&gt;3,2-&gt;3,1-&gt;2,2-&gt;1,3-&gt;2) 解：1 先向 3 到 n 连边，然后 2 向 3 到 n 连边，再将 1 和 2 相连，这样 1 和 2 就可以缩成一个点。这样规模就变成了 n-1. kickstar2019 round Bb题意：有 n 个能量棒，每个能量棒有 s，e，l 三个属性。s 表示吃掉这根能量棒所需要的时间，e 表示吃掉这个能量棒能获得的能量，l 表示每秒钟能量棒的能力会衰减的值。现在要使得所获得的能量最多，问最多是多少？ n 为 100 解：对于能量棒 i 和 j，如果不存在能量棒衰减为 0 的情况，那么如果$s_i \times l_j &lt; s_j \times l_i$ 那么就应该先吃 j 再吃 i。按这个顺序排序之后，贪心选就可以了。 但是如果某个能量棒会衰减为 0，那么就不能这么贪心。但这些会衰减为 0 的能量棒并不影响选择的顺序。因此可以 01 背包做一下。 简单证明一下：假设按照排序结果先吃 i 再吃 j 或者只吃 j 不吃 i 。我们需要证明的是先吃 j 再吃 i 不会更优。 第一种情况是 i 和 j 都不会衰减到 0。这时候一定是先吃 i 再吃 j； 第二种情况是 i 会衰减到 0，j 不会。这时候吃完 j，i 已经衰减到 0 了，我们绝对不会再去选择 i 第三种情况是 j 会衰减到 0，i 不会。$e_i - l_i \times t \geq e_j - l_j \times t + e_i - l_i \times(t + s_j)$ 又因为$e_j - l_j(t + s_i) \leq 0$ 并且$s_i \times l_j &gt; s_j \times l_i$。所以先吃 i 的的收益更大。 第四种情况是 i 和 j 都会衰减到 0。这种情况要么吃 i 要么吃 j，不会出现先吃 j 又把 i 吃了的情况。 c题意：给一个有 n 数字的数组 a[]和一个 s。 定义$(l,r)$表示区间[l,r]内，所有合法元素的数量。合法的定义为该种类的数字重复出现的次数小于等于 s。若出现次数大于 s，那么该元素就不算了。比如 s=2，那么对于 a=[1,1,1]，那么$(1,2) = 2, (1,3) = 0$。 解：我们将数组内的元素用 [+1, +1, -2]这种形式来表示，那么对于一个固定的左端点，只要求一个前缀和最大值即可。那么移动左端点的话，只需要更改几个点。所以我们就可以用线段树来维护一个前缀和最大值。]]></content>
      <categories>
        <category>ACM</category>
        <category>做题记录</category>
      </categories>
      <tags>
        <tag>做题记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[参考文章： 2009NOI 国家集训队论文——罗穗骞 代码解释sa[i]：表示排名为i的后缀的起始位置 rank[i]：表示从i开始的后缀的排名 height[i] = LCP(suffix(sa[i-1]), suffix(sa[i]))：排名为i-1和排名为i的两个后缀的最长公共前缀 h[i] = height[rank[i]]：起始位置为i的后缀和它前一名的后缀的最长公共前缀 性质： $suffix(i)$和$suffix(k)$的最长公共前缀为$height[rank[i]+1]…height[rank[k]]$中的最小值。 $h[i] \geq h[i-1] - 1$ 例题 给定一个字符串，求某两个后缀的最长公共前缀性质：LCP(suffix(i), suffix(j)) = min { height[rank[i]+1], ..., height[rank[j]] }因此可以用rmq预处理区间最小值，然后 O(1)查询 可重叠最长重复子串重复子串：若字符串R在字符串L中至少出现两次，则称R是L的重复子串因为相邻排名的两个后缀串之间的lcp一定比不相邻的两个后缀串的lcp大，因此答案是height数组的最大值。 不可重叠最长重复字串（poj1743）二分答案，然后按答案对height进行分组，使得同一组内的后缀串相互之间的lcp都大于等于二分的答案。如果一组内的最大的 sa 值减去最小的 sa 值大于等于二分的答案，那么就是可行的。用并查集维护一下就好。要注意的是，本题是对差分后的数组建后缀数组，因此首先要保证数组元素非负，然后是差分后的公共前缀的长度的意义是不同的。 可重叠的出现至少 k 次的重复子串（poj3261）同样还是按height分组的思想。二分答案，分组后要求同一组内的后缀串数量大于等于 k，则满足条件。 本质不同的子串数量（spoj705）$ans = \sum_{i=1}^{n}(n-sa[i]-height[i])$ 最长回文子串（ural1297）将字符串逆转后和原字符串拼接起来，拼接前要加一个从未出现过的字符在原字符串后面，这样可以防止匹配越界。然后枚举回文串的中心点，讨论一下长度的奇偶。 连续重复子串（poj2406）给定一个字符串$L$，已知这个字符串是由某个字符串$S$重复$R$次而得到的，求$R$的最大值。枚举长度$k$，如果$lcp(0,0+k) == n-k$那么$k$是满足条件的，$R = \frac{n}{k}$，因此找到最小的$k$即可。要注意字符串长度为$10^6$，直接建后缀数组是会$MLE$（因为$dp$数组爆了）。但是我们并不需要$rmq$，因为第一个参数一直为$0$，所以我们可以将$dp$数组降到一维。 重复次数最多的连续重复子串（spoj687）给定一个字符串$L$，求$L$的所有子串中重复次数最多的连续重复子串。枚举长度$k$，那么$s[0],s[0+k]…,s[0+nk]$，中一定有两个相邻的会被选上，但显然这不一定是两个重复子串的开头。开头可能会在前面$k-1$个位置中。$n + \frac{n}{2} + \frac{n}{3} + ….. = n\log n$ 最长公共子串（ural1517）给定两个字符串 $A$ 和 $B$，求最长公共子串。将两个字符串拼接起来，中间加个从未出现的字符。排名相邻且不在同一字符串的两个后缀的 $lcp$ 的最大值为答案。 长度不小于 k 的公共子串的个数(pku3415) 不小于 k 个字符串中的最长子串(pku3294) 每个字符串至少出现两次且不重叠的最长子串(spoj220) 出现或反转后出现在每个字符串中的最长子串(PKU3294) 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// build 复杂度:O(nlogn)// 需要保证s[n]为之前没有出现过的最小的字符。必要时手动添加，或者自动'\0'。// sa下标从1开始编号，sa[0]表示加入的最小字符'\0'struct SA &#123; char s[maxn]; int sa[maxn], t[maxn], t2[maxn], c[maxn], rank[maxn], height[maxn]; int dp[maxn][30]; void build(int m, int n) &#123; // [0,m-1]字符集, [0,n-1] 字符串 n++; int *x = t, *y = t2; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k; i &lt; n; i++) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; n--; int k = 0; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (s[i + k] == s[j + k]) k++; height[rank[i]] = k; // h[i] = height[rank[i]] &#125; &#125; void initRmq(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; int rmq(int l, int r) &#123; int k = 31 - __builtin_clz(r - l + 1); return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); &#125; int lcp(int a, int b) &#123; // 返回起始地址为a和b的两个后缀串的lcp a = rank[a], b = rank[b]; if (a &gt; b) swap(a, b); return rmq(a + 1, b); &#125;&#125; sa;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加密算法]]></title>
    <url>%2F2019%2F04%2F08%2FRSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[RSA非对称加密通信过程我拥有私钥，我将公钥交给想和我通信的人。 他发送消息时用公钥加密，我收到消息后用私钥解密。 我发送消息时用私钥加密，他收到消息后用公钥解密。 算法原理密钥生成 选两个质数p和q $n = pq$ $\phi(n) = (p-1)\times (q-1)$ $(n,e)$构成公钥，$1 &lt; e &lt; \phi(n)$ 且 $e$与$\phi(n)$互质 $(n,d)$构成私钥，$ed \equiv 1 \quad mod \quad \phi(n)$ 加密过程消息$m$ 公钥(私钥)加密： $c = m^e \quad mod \quad n$ 私钥(公钥)解密： $m = c^d \quad mod \quad n$ 原理以公钥加密，私钥解密为例： 我们需要验证：$m \equiv m^{ed} \quad mod \quad n$ 因为 $ed \equiv 1 \quad mod \quad \phi(n)$ 所以 $ed = 1 + k\phi(n)$ -&gt; $m^{ed} = m^{1 + k\phi(n)}$ 当n与m互质时： 由欧拉定理可知：$m^{\phi(n)} \equiv 1 \quad mod \quad n$ 因此：$m^{1 + k\phi(n)} \equiv m \quad mod \quad n$ 即：$m \equiv m^{ed} \quad mod \quad n$ 当n与m不互质时： 因为$n=pq$，因此$m=kp$或$m=kq$，不妨设$m=kp$ $m^{\phi(q)} = (kp)^{\phi(q)} \equiv 1 \quad mod \quad q$ -&gt; $(kp)^{h\phi(p) \phi(q) + 1} \equiv (kp) \quad mod \quad q$ -&gt; $(kp)^{ed} \equiv (kp) \quad mod \quad q$ -&gt; $(kp)^{ed} = kp + tq$ 因为$kp + tq \equiv 0 \quad mod \quad p$ 因此$t = rp$ -&gt; $(kp)^{ed} = kp + rpq$ -&gt; $m^{ed} \equiv m \quad mod \quad n$ 证毕]]></content>
      <categories>
        <category>加密算法</category>
      </categories>
      <tags>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[逆元参考博客 费马小定理参考博客 x在模p意义下存在逆元，当且仅当x与p互质。 利用费马小定理求逆元费马小定理： 对于质数p，对于任意整数a，均满足: $a^p \equiv a$ mod(p) 移项后得：$a(a^{p-1} - 1) \equiv 0$ mod(p) 所以：$a^{p-1} \equiv 1$ mod(p) 即:$a \times a^{p-2} \equiv 1$ mod(p) 因此a在模p意义下的逆元就是$a^{p-2}$ 1ll inv(ll a, ll p) &#123; return Pow(a, p - 2); &#125; 扩展欧几里得求逆元$ax \equiv 1$ mod(p) -&gt; $ax + py = 1$ 当a与p互质时，上式有解，直接扩展欧几里得求出x 12345ll inv(ll a, ll p) &#123; ll x, y; ll d = ex_gcd(a, p, x, y); return d == 1 ? (x % p + p) % p : -1;&#125; 线性递推逆元1! ~ n!的逆元证明： $fac[i] \times inv[i] \equiv 1$ mod(p) -&gt; $fac[i+1] \times (i+1) \times inv[i+1] \equiv 1$ mod(p) -&gt; $inv[i] = inv[i+1] \times (i+1)$ 123456getInv(int n) &#123; f[0] = 1; for (int i = 1; i &lt; n; i++) f[i] = f[i - 1] * i % mod; inv[n - 1] = Pow(f[n - 1], mod - 2); for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;&#125; 1 ~ n的逆元证明： 令s = p // i,t = p % i，则有s * i + t = p 因此$s * i + t \equiv 0 $ mod(p) 同时除以i * t得 $inv[i] \equiv -s \times inv[t]$ mod(p) 将s = p // i,t = p % i 带入得 $inv[i] \equiv inv[p\%i] \times \frac{-p}{i}$ mod(p) 123getInv(int n) &#123; for (int i = 2; i &lt; n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F04%2F02%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[介绍参考博客1参考博客1 复杂度分析时间复杂度： insert：主串的长度 build：结点数×字符集大小 query：主串的长度？ 空间复杂度： 结点数 约等于 模式串的大小×模式串的数量 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Trie &#123; int ch[maxn][26], f[maxn], val[maxn]; int sz, rt; int newnode() &#123; memset(ch[sz], -1, sizeof(ch[sz])), val[sz] = 0; return sz++; &#125; void init() &#123; sz = 0, rt = newnode(); &#125; int idx(char c) &#123; return c - 'A'; &#125; void insert(const char* s) &#123; int u = 0; for (int i = 0; s[i]; i++) &#123; int c = idx(s[i]); if (ch[u][c] == -1) ch[u][c] = newnode(); u = ch[u][c]; &#125; val[u]++; &#125; void build() &#123; queue&lt;int&gt; q; f[rt] = rt; for (int c = 0; c &lt; 26; c++) &#123; if (~ch[rt][c]) f[ch[rt][c]] = rt, q.push(ch[rt][c]); else ch[rt][c] = rt; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); // val[u] |= val[f[u]]; for (int c = 0; c &lt; 26; c++) &#123; if (~ch[u][c]) f[ch[u][c]] = ch[f[u]][c], q.push(ch[u][c]); else ch[u][c] = ch[f[u]][c]; &#125; &#125; &#125; int query(const char* s) &#123; int u = rt; int res = 0; for (int i = 0; s[i]; i++) &#123; int c = idx(s[i]); u = ch[u][c]; for(int j=u;j!=rt&amp;&amp;~val[j];j=f[j]) res+=val[j],val[j]=-1; &#125; return res; &#125;&#125; trie; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 指针版struct Node &#123; Node *f, *ch[Types]; int val; Node() &#123; val = 0; f = nullptr; for (int i = 0; i &lt; Types; i++) ch[i] = nullptr; &#125;&#125;;struct Trie &#123; vector&lt;Node *&gt; nodes; // 全部结点，方便删除 Node *rt; void init() &#123; rt = new Node(); nodes.push_back(rt); &#125; int idx(const char &amp;c) &#123; return c - 'A'; &#125; void insert(int id, const char *s) &#123; Node *u = rt; for (int i = 0, c; s[i]; i++) &#123; c = idx(s[i]); if (u-&gt;ch[c] == nullptr) u-&gt;ch[c] = new Node(), nodes.push_back(u-&gt;ch[c]); u = u-&gt;ch[c]; &#125; u-&gt;val++; &#125; void build() &#123; queue&lt;Node *&gt; q; rt-&gt;f = rt; for (int i = 0; i &lt; Types; i++) &#123; if (rt-&gt;ch[i] != nullptr) rt-&gt;ch[i]-&gt;f = rt, q.push(rt-&gt;ch[i]); else rt-&gt;ch[i] = rt; &#125; while (!q.empty()) &#123; Node *u = q.front(); q.pop(); for (int i = 0; i &lt; Types; i++) &#123; if (u-&gt;ch[i] != nullptr) u-&gt;ch[i]-&gt;f = u-&gt;f-&gt;ch[i], q.push(u-&gt;ch[i]); else u-&gt;ch[i] = u-&gt;f-&gt;ch[i]; &#125; &#125; &#125; int query(const char *s) &#123; int ret = 0; Node *u = rt; for (int i = 0, c; s[i]; i++) &#123; c = idx(s[i]); u = u-&gt;ch[c]; for (auto p = u; p != rt &amp;&amp; p-&gt;val != -1; p = p-&gt;f) &#123; ret += p-&gt;val; p-&gt;val = -1; &#125; &#125; return ret; &#125; void delTrie() &#123; for (auto &amp;v : nodes) delete v; nodes.clear(); &#125;&#125; trie; 练习HDU2222: 一个主串，多个模式串，问主串中有多少种模式串记录单词结尾的val数组，访问一次之后就要清空，这样就可以统计种类了。 HDU2896: 多个主串，多个模式串，问每个主串中有多少种模式串因为每个主串最多有3个模式串，所以可以记录一次匹配中有哪些val被访问了，匹配结束后恢复一下即可。 ZOJ3494: 问[A,B]内有多少数字，其bcd表示不含模式串数位dp的状态用ac自动机上的结点来表示。每加一位数字，相当于在ac自动机上转移四次(BCD码将一位数字表示成四个二进制位)。优化时间：用val数组表示是否会出现模式串，在build的时候如果val[f[u]]大于0，那么说明val[u]也要大于0.这样防止查询的时候在自动机上来回跳。 POJ2778: 问有多少个长度为n的串不包含模式串，n为2e9，模式串总长度小于100通过ac自动机构造可达矩阵(结点i到结点j的方案数)，可达矩阵的n次幂，就是i到j有多少条长度为n的路径。最后统计$\sum_{i=0}^{sz}mat[0][i]$即可 HDU2243: 问有多少个长度至多为n的串不包含模式串相对于上一题多了一个求和，需要用到公式： $$ \left(\begin{matrix}A &amp; E \\ 0 &amp; E\end{matrix}\right)^n = \left(\begin{matrix}A^n &amp; E+A+A^2+…+A^{n-1} \\ 0 &amp; E\end{matrix}\right) $$]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM模板]]></title>
    <url>%2F2019%2F04%2F01%2FACM%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[头文件123456789101112131415161718192021222324252627282930// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define Lson l, m, lson#define Rson m+1, r, rson#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)using ll = long long;using pii = pair&lt;int,int&gt;;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif// */ std::ios::sync_with_stdio(false);&#125; 字符串KMP1234567891011121314151617181920212223242526struct KMP&#123; int back[maxn]; void getfail(string line)&#123; int i,k; k = back[0] = -1; i = 0; while(i &lt; line.size())&#123; while(k != -1 &amp;&amp; line[i] != line[k]) k = back[k]; back[++i] = ++k; &#125; &#125; int match(string T,string P)&#123; int i = 0,k = 0; int ret = 0; getfail(P); while(i &lt; T.size())&#123; while(k != -1 &amp;&amp; T[i] != P[k]) k = back[k]; ++i;++k; if(k &gt;= P.size())&#123; ret++; k = back[k]; &#125; &#125; return ret; &#125;&#125;; AC 自动机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*insert: 字符串长度build: 结点数*字符集大小query: 字符串长度*/struct Trie &#123; int ch[maxn][26], f[maxn], val[maxn]; int sz, rt; int newnode() &#123; memset(ch[sz], -1, sizeof(ch[sz])), val[sz] = 0; return sz++; &#125; void init() &#123; sz = 0, rt = newnode(); &#125; int idx(char c) &#123; return c - 'A'; &#125; void insert(const char* s) &#123; int u = 0; for (int i = 0; s[i]; i++) &#123; int c = idx(s[i]); if (ch[u][c] == -1) ch[u][c] = newnode(); u = ch[u][c]; &#125; val[u]++; &#125; void build() &#123; queue&lt;int&gt; q; f[rt] = rt; for (int c = 0; c &lt; 26; c++) &#123; if (~ch[rt][c]) f[ch[rt][c]] = rt, q.push(ch[rt][c]); else ch[rt][c] = rt; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); // val[u] |= val[f[u]]; for (int c = 0; c &lt; 26; c++) &#123; if (~ch[u][c]) f[ch[u][c]] = ch[f[u]][c], q.push(ch[u][c]); else ch[u][c] = ch[f[u]][c]; &#125; &#125; &#125; int query(const char* s) &#123; int u = rt; int res = 0; for (int i = 0; s[i]; i++) &#123; int c = idx(s[i]); u = ch[u][c]; for(int j=u;j!=rt&amp;&amp;~val[j];j=f[j]) res+=val[j],val[j]=-1; &#125; return res; &#125;&#125; trie; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 指针版struct Node &#123; Node *f, *ch[Types]; int val; Node() &#123; val = 0; f = nullptr; for (int i = 0; i &lt; Types; i++) ch[i] = nullptr; &#125;&#125;;struct Trie &#123; vector&lt;Node *&gt; nodes; // 全部结点，方便删除 Node *rt; void init() &#123; rt = new Node(); nodes.push_back(rt); &#125; int idx(const char &amp;c) &#123; return c - 'A'; &#125; void insert(int id, const char *s) &#123; Node *u = rt; for (int i = 0, c; s[i]; i++) &#123; c = idx(s[i]); if (u-&gt;ch[c] == nullptr) u-&gt;ch[c] = new Node(), nodes.push_back(u-&gt;ch[c]); u = u-&gt;ch[c]; &#125; u-&gt;val++; &#125; void build() &#123; queue&lt;Node *&gt; q; rt-&gt;f = rt; for (int i = 0; i &lt; Types; i++) &#123; if (rt-&gt;ch[i] != nullptr) rt-&gt;ch[i]-&gt;f = rt, q.push(rt-&gt;ch[i]); else rt-&gt;ch[i] = rt; &#125; while (!q.empty()) &#123; Node *u = q.front(); q.pop(); for (int i = 0; i &lt; Types; i++) &#123; if (u-&gt;ch[i] != nullptr) u-&gt;ch[i]-&gt;f = u-&gt;f-&gt;ch[i], q.push(u-&gt;ch[i]); else u-&gt;ch[i] = u-&gt;f-&gt;ch[i]; &#125; &#125; &#125; int query(const char *s) &#123; int ret = 0; Node *u = rt; for (int i = 0, c; s[i]; i++) &#123; c = idx(s[i]); u = u-&gt;ch[c]; for (auto p = u; p != rt &amp;&amp; p-&gt;val != -1; p = p-&gt;f) &#123; ret += p-&gt;val; p-&gt;val = -1; &#125; &#125; return ret; &#125; void delTrie() &#123; for (auto &amp;v : nodes) delete v; nodes.clear(); &#125;&#125; trie; 后缀数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*sa[i]：表示排名为 i 的后缀的起始位置rank[i]：表示从 i 开始的后缀的排名height[i] = LCP(suffix(sa[i-1]), suffix(sa[i])) ：排名为 i-1 和排名为 i 的两个后缀的最长公共前缀h[i] = height[rank[i]] ：起始位置为 i 的后缀和它前一名的后缀的最长公共前缀build 复杂度:O(nlogn)// 需要保证s[n]为之前没有出现过的最小的字符。必要时手动添加，或者自动'\0'。// sa下标从1开始编号，sa[0]表示加入的最小字符'\0'*/struct SA &#123; char s[maxn]; int sa[maxn], t[maxn], t2[maxn], c[maxn], rank[maxn], height[maxn]; int dp[maxn][30]; void build(int m, int n) &#123; // [0,m-1]字符集, [0,n-1] 字符串 n++; int *x = t, *y = t2; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[i] = s[i]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[i]]] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int p = 0; for (int i = n - k; i &lt; n; i++) y[p++] = i; for (int i = 0; i &lt; n; i++) if (sa[i] &gt;= k) y[p++] = sa[i] - k; for (int i = 0; i &lt; m; i++) c[i] = 0; for (int i = 0; i &lt; n; i++) c[x[y[i]]]++; for (int i = 1; i &lt; m; i++) c[i] += c[i - 1]; for (int i = n - 1; ~i; i--) sa[--c[x[y[i]]]] = y[i]; swap(x, y); p = 1; x[sa[0]] = 0; for (int i = 1; i &lt; n; i++) x[sa[i]] = y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++; if (p &gt;= n) break; m = p; &#125; n--; int k = 0; for (int i = 0; i &lt;= n; i++) rank[sa[i]] = i; for (int i = 0; i &lt; n; i++) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (s[i + k] == s[j + k]) k++; height[rank[i]] = k; &#125; &#125; void initRmq(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) dp[i][j] = min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; int rmq(int l, int r) &#123; int k = 31 - __builtin_clz(r - l + 1); return min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); &#125; int lcp(int a, int b) &#123; // 返回起始地址为a和b的两个后缀串的lcp a = rank[a], b = rank[b]; if (a &gt; b) swap(a, b); return rmq(a + 1, b); &#125;&#125; sa; Manacher 最长回文子串1234567891011121314151617181920212223const int maxn = 1e6+5;char Ma[maxn*2]; //插入新字符后的字符串int Mp[maxn*2]; //以当前位置为对称轴的回文半径void Manacher(string &amp;s)&#123; int l = 0; Ma[l++] = '$'; //防止越界 Ma[l++] = '#'; for(int i=0;i&lt;s.size();i++)&#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; //结尾设置为空字符，防止越界 int mx = 1,id = 1; for(int i=1;i&lt;l;i++)&#123; Mp[i] = mx &gt; i ? min(Mp[2*id-i],mx-i) : 1; while(Ma[i+Mp[i]] == Ma[i-Mp[i]]) Mp[i] ++; //扩展 if(i + Mp[i] &gt; mx)&#123; mx = i + Mp[i]; id = i; &#125; &#125;&#125; 数学小知识哥德巴赫猜想： 任何不小于 7 的奇数，都可以写成三个质数之和(已被证明) 任何不小于 4 的偶数，都可以写成两个质数之和 四色定理： 任何一张平面地图只用四种颜色就能使具有公共边界的国家着上不同的颜色 费马大定理： 当整数 n&gt;2 时，关于 x,y,z 的不定方程$x^n+y^n=z^n$无正整数解 费马小定理： 对于质数 p，对于任意整数 a，均满足$a^p \equiv a$ (mod p) 欧拉函数 $\phi(m) = {a: 1 \leq a \leq m, gcd(a,m) = 1 }$ 欧拉定理： 若正整数 a，n 互质，则$a ^ {\phi(n)} \equiv 1 \quad mod(n)$ 威尔逊定理： p 为素数的充要条件为$(p-1)! \equiv -1 \quad mod(p)$ 二次探测定理： 如果 p 是一个素数，且$0 &lt; x &lt; p$，则方程$x^2 \equiv 1 \quad mod(p)$的解为 1 和 p-1 海伦公式 三角形的面积公式$S = \sqrt{p(p-a)(p-b)(p-c)}$，其中$p = \frac{a+b+c}{2}$ 婆罗摩笈多公式 圆内接四边形面积公式$S = \sqrt{(p-a)(p-b)(p-c)(p-d)}$，其中$p = \frac{a+b+c+d}{2}$ 一般四边形面积公式$S = \sqrt{(p-a)(p-b)(p-c)(p-d) - abcd\cos^2 \theta }$，其中$\theta$为四边形一对角和的一半。 对于给定的四条边长，所有组成的四边形中圆内接四边形的面积最大 矩阵快速幂123456789101112131415161718192021222324namespace Matrix &#123;// Matrix mat(row, vec(col));typedef vector&lt;ll&gt; vec;typedef vector&lt;vec&gt; mat;mat mul(mat&amp; A, mat&amp; B) &#123; mat C(A.size(), vec(B[0].size())); for (int i = 0; i &lt; A.size(); i++) for (int k = 0; k &lt; B.size(); k++) if (A[i][k]) for (int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod; return C;&#125;mat Pow(mat A, ll n) &#123; mat B(A.size(), vec(A.size())); for (int i = 0; i &lt; A.size(); i++) B[i][i] = 1; while (n) &#123; if (n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;&#125; // namespace Matrix 组合数12345678910const int maxn = 1010;ll C[maxn][maxn];void CalComb() &#123; C[0][0] = 1; for (int i = 1; i &lt; maxn; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; &#125;&#125; 卢卡斯1234567891011121314151617181920// $1 \leq n, m \leq 1000000000, 1 &lt; p &lt; 100000$, p是素数const int maxp = 100010;ll f[maxn];ll inv[maxn]; // 阶乘的逆元void CalFact() &#123; f[0] = 1; for (int i = 1; i &lt; maxn; i++) f[i] = (f[i - 1] * i) % p; inv[maxn - 1] = Pow(f[maxn - 1], p - 2, p); for (int i = maxn - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % p;&#125;ll Lucas(ll n, ll m, ll p) &#123; ll ret = 1; while (n &amp;&amp; m) &#123; ll a = n % p, b = m % p; if (a &lt; b) return 0; ret = ret * f[a] % p * inv[b] % p * inv[a - b] % p; n /= p, m /= p; &#125; return ret;&#125; 大组合数12345678910111213141516171819202122232425262728293031// $0 \leq n \leq 10^9, 0 \leq m \leq 10^4, 1 \leq k \leq 10^9+7$vector&lt;int&gt; v;int dp[110];ll Cal(int l, int r, int k, int dis) &#123; ll res = 1; for (int i = l; i &lt;= r; i++) &#123; int t = i; for (int j = 0; j &lt; v.size(); j++) &#123; int y = v[j]; while (t % y == 0) dp[j] += dis, t /= y; &#125; res = res * (ll)t % k; &#125; return res;&#125;ll Comb(int n, int m, int k) &#123; memset(dp, 0, sizeof(dp)); v.clear(); int tmp = k; for (int i = 2; i * i &lt;= tmp; i++) if (tmp % i == 0) &#123; int num = 0; while (tmp % i == 0) tmp /= i, num++; v.push_back(i); &#125; if (tmp != 1) v.push_back(tmp); ll ans = Cal(n - m + 1, n, k, 1); for (int j = 0; j &lt; v.size(); j++) ans = ans * Pow(v[j], dp[j], k) % k; ans = ans * inv(Cal(2, m, k, -1), k) % k; return ans;&#125; 扩展欧几里得123456789101112131415161718192021222324// ax + by = gcd(a,b)// return d = gcd(a,b)ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (a == 0 &amp;&amp; b == 0) return -1; // 无最大公因数 ll d = a; if (b) d = ex_gcd(b, a % b, y, x), y -= x * (a / b); else x = 1, y = 0; return d;&#125;// X = x + dx * t, Y = y - dy * t// x是最小非负整数解bool solve(ll a, ll b, ll c, ll &amp;x, ll &amp;y, ll &amp;dx, ll &amp;dy) &#123; ll d; d = ex_gcd(a, b, x, y); if (d == -1 || c % d) return false; //无解 dx = b / d, dy = a / d; x = x * c / d; x = (x % dx + dx) % dx; y = (c - a * x) / b; return true;&#125; 类欧几里得$f = \sum^n_{i=0} \lfloor \frac{ai+b}{c} \rfloor $$g = \sum^n_{i=0} \lfloor \frac{ai+b}{c} \rfloor ^2$$h = \sum^n_{i=0} i\lfloor \frac{ai+b}{c} \rfloor $ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace likeGcd &#123;using ll = long long;const ll mod = 998244353;const ll inv2 = 499122177;const ll inv6 = 166374059;ll n, a, b, c;struct node &#123; ll f, g, h;&#125;;inline ll S1(ll n) &#123; return n * (n + 1) % mod * inv2 % mod; &#125;inline ll S2(ll n) &#123; return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod;&#125;inline node solve(ll a, ll b, ll c, ll n) &#123; ll t1 = a / c, t2 = b / c, s1 = S1(n), s2 = S2(n), m = (a * n + b) / c; node ans, now; ans.f = ans.g = ans.h = 0; if (!n) &#123; ans.f = t2; ans.g = t2 * t2 % mod; return ans; &#125; if (!a) &#123; ans.f = (n + 1) * t2 % mod; ans.g = (n + 1) * t2 % mod * t2 % mod; ans.h = t2 * s1 % mod; return ans; &#125; if (a &gt;= c || b &gt;= c) &#123; now = solve(a % c, b % c, c, n); ans.f = (now.f + t1 * s1 + (n + 1) * t2) % mod; ans.g = (now.g + 2 * t1 * now.h + 2 * t2 * now.f + t1 * t1 % mod * s2 + 2 * t1 * t2 % mod * s1 + (n + 1) * t2 % mod * t2) % mod; ans.h = (now.h + t1 * s2 + t2 * s1) % mod; return ans; &#125; now = solve(c, c - b - 1, a, m - 1); ans.f = (m * n - now.f) % mod; ans.f = (ans.f + mod) % mod; ans.g = (m * m % mod * n - 2 * now.h - now.f); ans.g = (ans.g + mod) % mod; ans.h = (m * s1 - now.g * inv2 - now.f * inv2) % mod; ans.h = (ans.h + mod) % mod; return ans;&#125;&#125;; // namespace likeGcd CRT12345678910111213// mod两两互质// 通解 re + k * M// 返回最小非负整数解void crt(ll r[], ll m[], ll n, ll &amp;re, ll &amp;M) &#123; M = 1, re = 0; for (int i = 0; i &lt; n; i++) M *= m[i]; for (int i = 0; i &lt; n; i++) &#123; ll x, y, tm = M / m[i]; ll d = ex_gcd(tm, m[i], x, y); re = (re + tm * x * r[i]) % M; &#125; re = (re + M) % M;&#125; EXCRT1234567891011121314151617// mod不满足两两互质// 通解为 re + k*M// 返回最小非负整数解bool excrt(ll r[], ll m[], ll n, ll &amp;re, ll &amp;M) &#123; ll x, y; M = m[0], re = r[0]; for (int i = 1; i &lt; n; i++) &#123; ll d = ex_gcd(M, m[i], x, y); if ((r[i] - re) % d != 0) return 0; x = (r[i] - re) / d * x % (m[i] / d); re += x * M; M = M / d * m[i]; re %= M; &#125; re = (re + M) % M; return 1;&#125; 逆元费马小定理求逆元12// 要求: p为质数ll inv(ll a, ll p) &#123; return Pow(a, p - 2); &#125; ex_gcd123456// 要求: a与p互质ll inv(ll a, ll p) &#123; ll x, y; ll d = ex_gcd(a, p, x, y); return d == 1 ? (x % p + p) % p : -1;&#125; 阶乘逆元线性递推123456getInv(int n) &#123; f[0] = 1; for (int i = 1; i &lt; n; i++) f[i] = f[i - 1] * i % mod; inv[n - 1] = Pow(f[n - 1], mod - 2); for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;&#125; 逆元线性递推123getInv(int n) &#123; for (int i = 2; i &lt; n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;&#125; 快速乘123456789101112inline ll Mul(ll a, ll b, ll m) &#123; if (m &lt;= (ll)1e9) return a * b % m; else if (m &lt;= (ll)1e12) return (((a * (b &gt;&gt; 20) % m) &lt;&lt; 20) + (a * (b &amp; ((1 &lt;&lt; 20) - 1)))) % m; else &#123; ll d = (ll)floor(a * (long double)b / m + 0.5); ll ret = (a * b - d * m) % m; if (ret &lt; 0) ret += m; return ret; &#125;&#125; Miller Rabin 大素数判定1234567891011121314151617181920212223242526272829303132ll Pow(ll a, ll b, ll p) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = Mul(ret, a, p); // 快速乘 a = Mul(a, a, p); b &gt;&gt;= 1; &#125; return ret;&#125;mt19937_64 rnd;// O(slogn)内判定素数// s为判定次数，错误率为(1/4)^sbool Miller_Rabin(ull n, int s) &#123; if (n == 2) return 1; if (n &lt; 2 || !(n &amp; 1)) return 0; int t = 0; ull x, y, u = n - 1; while ((u &amp; 1) == 0) t++, u &gt;&gt;= 1; for (int i = 0; i &lt; s; i++) &#123; ull a = rnd() % (n - 1) + 1; ull x = Pow(a, u, n); for (int j = 0; j &lt; t; j++) &#123; ull y = Mul(x, x, n); // ull y = __int128(x) * __int128(x) % n; if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) return 0; x = y; &#125; if (x != 1) return 0; &#125; return 1;&#125; FFT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237namespace fft &#123;typedef double db;struct cp &#123; db x, y; cp() &#123; x = y = 0; &#125; cp(db x, db y) : x(x), y(y) &#123;&#125;&#125;;inline cp operator+(cp a, cp b) &#123; return cp(a.x + b.x, a.y + b.y); &#125;inline cp operator-(cp a, cp b) &#123; return cp(a.x - b.x, a.y - b.y); &#125;inline cp operator*(cp a, cp b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;inline cp conj(cp a) &#123; return cp(a.x, -a.y); &#125;int base = 1;vector&lt;cp&gt; roots = &#123;&#123;0, 0&#125;, &#123;1, 0&#125;&#125;;vector&lt;int&gt; rev = &#123;0, 1&#125;;const db PI = acosl(-1.0);void ensure_base(int nbase) &#123; if (nbase &lt;= base) return; rev.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); for (int i = 0; i &lt; (1 &lt;&lt; nbase); i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1)); roots.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); while (base &lt; nbase) &#123; db angle = 2 * PI / (1 &lt;&lt; (base + 1)); for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) &#123; roots[i &lt;&lt; 1] = roots[i]; db angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base)); roots[(i &lt;&lt; 1) + 1] = cp(cos(angle_i), sin(angle_i)); &#125; base++; &#125;&#125;void fft(vector&lt;cp&gt;&amp; a, int n = -1) &#123; if (n == -1) n = a.size(); assert((n &amp; (n - 1)) == 0); int zeros = __builtin_ctz(n); ensure_base(zeros); int shift = base - zeros; for (int i = 0; i &lt; n; i++) if (i &lt; (rev[i] &gt;&gt; shift)) swap(a[i], a[rev[i] &gt;&gt; shift]); for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += 2 * k) for (int j = 0; j &lt; k; j++) &#123; cp z = a[i + j + k] * roots[j + k]; a[i + j + k] = a[i + j] - z; a[i + j] = a[i + j] + z; &#125;&#125;vector&lt;cp&gt; fa, fb;template &lt;class T&gt;vector&lt;T&gt; multiply(vector&lt;T&gt;&amp; a, vector&lt;T&gt;&amp; b) &#123; int need = a.size() + b.size() - 1; int nbase = 0; while ((1 &lt;&lt; nbase) &lt; need) nbase++; ensure_base(nbase); int sz = 1 &lt;&lt; nbase; if (sz &gt; (int)fa.size()) fa.resize(static_cast&lt;unsigned long&gt;(sz)); for (int i = 0; i &lt; sz; i++) &#123; T x = (i &lt; (int)a.size() ? a[i] : 0); T y = (i &lt; (int)b.size() ? b[i] : 0); fa[i] = cp(x, y); &#125; fft(fa, sz); cp r(0, -0.25 / sz); for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) &#123; int j = (sz - i) &amp; (sz - 1); cp z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r; if (i != j) &#123; fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r; &#125; fa[i] = z; &#125; fft(fa, sz); vector&lt;T&gt; res(static_cast&lt;unsigned long&gt;(need)); for (int i = 0; i &lt; need; i++) res[i] = fa[i].x + 0.5; return res;&#125;&#125;; // namespace fftnamespace ntt &#123;int Pow(int a, int b, int p) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1LL * ret * a % p; a = 1LL * a * a % p; b &gt;&gt;= 1; &#125; return ret;&#125;const int mod = 119 &lt;&lt; 23 | 1;const int G = 3;int wn[20];void getwn() &#123; // 千万不要忘记 for (int i = 0; i &lt; 20; i++) wn[i] = Pow(G, (mod - 1) / (1 &lt;&lt; i), mod);&#125;void change(int y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;void ntt(int y[], int len, int on) &#123; change(y, len); for (int h = 2, id = 1; h &lt;= len; h &lt;&lt;= 1, id++) &#123; for (int j = 0; j &lt; len; j += h) &#123; int w = 1; for (int k = j; k &lt; j + h / 2; k++) &#123; int u = y[k] % mod; int t = 1LL * w * (y[k + h / 2] % mod) % mod; y[k] = (u + t) % mod, y[k + h / 2] = ((u - t) % mod + mod) % mod; w = 1LL * w * wn[id] % mod; &#125; &#125; &#125; if (on == -1) &#123; // 原本的除法要用逆元 int inv = Pow(len, mod - 2, mod); for (int i = 1; i &lt; len / 2; i++) swap(y[i], y[len - i]); for (int i = 0; i &lt; len; i++) y[i] = 1LL * y[i] * inv % mod; &#125;&#125;/*int A[maxn], B[maxn];void multiply(int x[], int y[], int n, int m) &#123; // n,m 表示长度 （阶数要加一） int len = 1; while (len &lt;= (m + n)) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) A[i] = B[i] = 0; for (int i = 0; i &lt;= n; i++) A[i] = x[i]; for (int i = 0; i &lt;= m; i++) B[i] = y[i]; ntt(A, len, 1); ntt(B, len, 1); for (int i = 0; i &lt; len; i++) A[i] = 1LL * A[i] * B[i] % mod; ntt(A, len, -1);&#125;*/&#125; // namespace nttnamespace fft &#123;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/* * len必须为2^k形式， * on==1时是DFT，on==-1时是IDFT */void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;/*void multiply(int x[], int y[], int n, int m) &#123; // n,m 表示长度 （阶数要加一） int len = m + n; while (len &lt;= (m + n)) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) A[i] = B[i] = Complex(0, 0); for (int i = 0; i &lt;= n; i++) A[i] = Complex(x[i], 0); for (int i = 0; i &lt;= m; i++) B[i] = Complex(y[i], 0); fft(A, len, 1); fft(B, len, 1); for (int i = 0; i &lt; len; i++) A[i] = 1LL * A[i] * B[i] % mod; fft(A, len, -1); for (int i = 0; i &lt; len; i++) C[i] = int(A[i].x + 0.5); while (C[len] == 0 &amp;&amp; len &gt; 0) len--;&#125;*/&#125; // namespace fftnamespace fwt &#123;void fwt(int f[], int m) &#123; int n = __builtin_ctz(m); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) if (j &amp; (1 &lt;&lt; i)) &#123; int l = f[j ^ (1 &lt;&lt; i)], r = f[j]; f[j ^ (1 &lt;&lt; i)] = l + r, f[j] = l - r; // or: f[j] += f[j ^ (1 &lt;&lt; i)]; // and: f[j ^ (1 &lt;&lt; i)] += f[j]; &#125;&#125;void ifwt(int f[], int m) &#123; int n = __builtin_ctz(m); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) if (j &amp; (1 &lt;&lt; i)) &#123; int l = f[j ^ (1 &lt;&lt; i)], r = f[j]; f[j ^ (1 &lt;&lt; i)] = (l + r) / 2, f[j] = (l - r) / 2; // 如果有取模需要使用逆元 // or: f[j] -= f[j ^ (1 &lt;&lt; i)]; // and: f[j ^ (1 &lt;&lt; i)] -= f[j]; &#125;&#125;&#125; // namespace fwt 扩展埃氏筛1234567891011121314151617const int maxn = 1e6 + 6;ll f1[maxn], f2[maxn];// [1,n] 内素数个数。 n &lt; 1e12// f1[i]: [1,i] 内素数个数// f2[i]: [1,n/i] 内素数个数ll CalPrime(ll n) &#123; ll sn = sqrt(n); for (int i = 1; i &lt;= sn; i++) f1[i] = i - 1, f2[i] = n / i - 1; for (ll i = 2; i &lt;= sn; i++) &#123; if (f1[i] == f1[i - 1]) continue; for (int j = 1; j &lt;= sn / i; j++) f2[j] -= f2[j * i] - f1[i - 1]; for (int j = sn / i + 1; j &lt;= n / (i * i) &amp;&amp; j &lt;= sn; j++) f2[j] -= f1[n / (j * i)] - f1[i - 1]; for (int j = sn; j &gt;= i * i; j--) f1[j] -= f1[j / i] - f1[i - 1]; &#125; return f2[1];&#125; 123456789101112131415161718192021222324252627const int maxn = 1e6 + 6;const int mod;const ll inv2;ll f1[maxn], f2[maxn];inline ll presum(const ll&amp; x) &#123; return (1 + x) * x % mod * inv2 % mod; &#125;// [1,n] 内素数和 + 1。 n &lt; 1e12// f1[i]: [1,i] 内素数和 + 1// f2[i]: [1,n/i] 内素数和 + 1ll CalPrime(ll n) &#123; if (!n) return 0; ll sn = sqrt(n); for (int i = 1; i &lt;= sn; i++) f1[i] = presum(i), f2[i] = presum(n / i); for (ll i = 2; i &lt;= sn; i++) &#123; if (f1[i] == f1[i - 1]) continue; for (int j = 1; j &lt;= sn / i; j++) f2[j] = (f2[j] - (f2[j * i] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; for (int j = sn / i + 1; j &lt;= n / (i * i) &amp;&amp; j &lt;= sn; j++) f2[j] = (f2[j] - (f1[n / (j * i)] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; for (int j = sn; j &gt;= i * i; j--) f1[j] = (f1[j] - (f1[j / i] - f1[i - 1] + mod) % mod * i % mod + mod) % mod; &#125; return f2[1];&#125; 区间筛123456789101112131415161718192021// 对区间$[a,b)$内的整数执行筛法// 函数返回区间内素数个数// \texttt&#123;is\_prime[i-a]=true&#125;表示$i$是素数// $1&lt;a&lt;b \le 10^&#123;12&#125;, b-a \le 10^6$const int maxn = 1e6 + 6;bool is_prime_small[maxn], is_prime[maxn];ll prime[maxn];int segment_sieve(ll a, ll b) &#123; int tot = 0; for (ll i = 0; i * i &lt; b; ++i) is_prime_small[i] = true; for (ll i = 0; i &lt; b - a; ++i) is_prime[i] = true; for (ll i = 2; i * i &lt; b; ++i) if (is_prime_small[i]) &#123; for (ll j = 2 * i; j * j &lt; b; j += i) is_prime_small[j] = false; for (ll j = max(2LL, (a + i - 1) / i) * i; j &lt; b; j += i) is_prime[j - a] = false; &#125; for (ll i = 0; i &lt; b - a; ++i) if (is_prime[i]) prime[tot++] = i + a; return tot;&#125; 线性筛因数个数1234567891011121314151617181920212223242526const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], d[maxn], num[maxn], tot;// d[i]: i的约数个数， num[i]: i的最小质因数的个数void init() &#123; memset(vis, 0, sizeof(vis)); d[1] = 1; for (ll i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; d[i] = 2; num[i] = 1; &#125; for (ll k = 0; k &lt; tot &amp;&amp; i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; d[i * prime[k]] = d[i] / (num[i] + 1) * (num[i] + 2); num[i * prime[k]] = num[i] + 1; break; &#125; else &#123; d[i * prime[k]] = d[i] * d[prime[k]]; num[i * prime[k]] = 1; &#125; &#125; &#125;&#125; 线性筛因数和12345678910111213141516171819202122232425const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], sd[maxn], num[maxn], tot;// sd[i]: i的约数和void init() &#123; memset(vis, 0, sizeof(vis)); sd[1] = 1; for (ll i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; sd[i] = num[i] = 1 + i; &#125; for (ll k = 0; k &lt; tot &amp;&amp; i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k]) &#123; sd[i * prime[k]] = sd[i] * sd[prime[k]]; num[i * prime[k]] = prime[k] + 1; &#125; else &#123; sd[i * prime[k]] = sd[i] / num[i] * (num[i] * prime[k] + 1); num[i * prime[k]] = num[i] * prime[k] + 1; break; &#125; &#125; &#125;&#125; 欧拉函数123456789101112131415161718192021222324252627282930313233343536373839// 求单个Eular函数map&lt;ll, ll&gt; Eular; //记忆化ll eular(ll n) &#123; ll &amp;ret = Eular[n]; if (ret) return ret; ret = n; for (ll i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret -= ret / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;// 线性筛 (同时得到欧拉函数和素数表)const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], phi[maxn];void CalPhi() &#123; memset(vis, 0, sizeof(vis)); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125; 欧拉降幂在模 $p$ 意义下： $$a^b \equiv \begin{cases} a ^{b \% \phi(p)} \quad gcd(a,p) = 1\\ a^b \quad gcd(a,p) \neq 1, b &lt; \phi(p) \\ a ^{b \% \phi(p) + \phi(p)} \quad gcd(a,p) \neq 1, b \geq \phi(p) \end{cases} $$ 对于 $b$ 和 $\phi(p)$ 的相对大小，可以在快速幂的过程中判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*计算 $a^&#123;a^&#123;a^&#123;...&#125;&#125;&#125; \% m $ 的值， 一共有 $b$ 个 $a$。*/#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], phi[maxn];void CalPhi() &#123; memset(vis, 0, sizeof(vis)); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;/* 快速幂的时候更改取模方式。 保证在 a^b &lt; p 的时候返回 a^b；在 a^b &gt;=p，返回 a^b % p + p。*/#define Mod(x, p) (x &lt; p ? x : x % p + p);ll Pow(ll a, ll b, ll p) &#123; ll ret = 1; bool ok = false; while (b) &#123; if (b &amp; 1) ret = Mod(ret * a, p); a = Mod(a * a, p); b &gt;&gt;= 1; &#125; return Mod(ret, p);&#125;// --------------------------------------------------------ll cal(int a, int b, int p) &#123; if (b == 1 || p == 1) return a &lt; p ? a : a % p + p; return Pow(a, cal(a, b - 1, phi[p]), p);&#125;int main() &#123; CalPhi(); int T; scanf("%d", &amp;T); while (T--) &#123; int a, b, m; scanf("%d%d%d", &amp;a, &amp;b, &amp;m); if (!b) &#123; printf("%d\n", 1 % m); continue; &#125; ll ans = cal(a, b, m) % m; printf("%lld\n", ans); &#125;&#125; 莫比乌斯函数1234567891011121314151617181920const int maxn = 1e7 + 5;bool check[maxn];int mu[maxn];vector&lt;int&gt; prime;void CalMu() &#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if (!check[i]) prime.push_back(i), mu[i] = -1; for (int j = 0; j &lt; prime.size(); j++) &#123; ll nxt = 1ll * prime[j] * i; if (nxt &gt;= maxn) break; check[nxt] = true; if (i % prime[j] == 0) &#123; mu[nxt] = 0; break; &#125; else mu[nxt] = -mu[i]; &#125; &#125;&#125; 高斯消元12345678910111213141516171819202122232425262728293031323334353637383940typedef double mat[maxn][maxn];// A为增广矩阵，执行后A[i][n]表示第i个未知数的值//无解或无穷多解返回falsebool gauss(mat &amp;A, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; int r = i; for (int j = i + 1; j &lt; n; j++) if (fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if (r != i) for (int j = 0; j &lt;= n; j++) swap(A[r][j], A[i][j]); if (fabs(A[i][i]) &lt; eps) return false; for (int k = 0; k &lt; n; k++) if (k != i) for (int j = n; k &gt;= i; j--) A[k][j] -= A[k][i] / A[i][i] * A[i][j]; &#125; return true;&#125;// 模意义下用逆元代替除法bool gauss(mat &amp;A, int n) &#123; for (int i = 0; i &lt; n; i++) &#123; int r = i; for (int j = i + 1; j &lt; n; j++) if (fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if (r != i) for (int j = 0; j &lt;= n; j++) swap(A[r][j], A[i][j]); if (fabs(A[i][i] - eps) &lt; eps) return false; ll b = Pow(A[i][i], mod - 2); for (int j = i; j &lt; n + 1; j++) A[i][j] = A[i][j] * b % mod; for (int j = 0; j &lt; n; j++) if (j != i) &#123; int c = A[j][i]; for (int k = i; k &lt; n + 1; k++) A[j][k] = (A[j][k] - A[i][k] * c % mod + mod) % mod; &#125; &#125; return true;&#125; 莫比乌斯函数12345678910111213141516171819// 线性筛莫比乌斯函数const int maxn = 1e7;int prime[maxn], tot, mu[maxn];bool check[maxn];void CalMu() &#123; mu[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if (!check[i]) prime[tot++] = i, mu[i] = -1; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt;= maxn) break; check[i * prime[j]] = true; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125; 整除分块12345// O(sqrt(n))for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans += (n / l) * (r - l + 1);&#125; 线性基1234567891011121314151617// 高斯消元void cal() &#123; for (int i = 0; i &lt; n; ++i) for (int j = MAX_BASE; j &gt;= 0; --j) if (a[i] &gt;&gt; j &amp; 1) &#123; if (b[j]) a[i] ^= b[j]; else &#123; b[j] = a[i]; for (int k = j - 1; k &gt;= 0; --k) if (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; 1)) b[j] ^= b[k]; for (int k = j + 1; k &lt;= MAX_BASE; ++k) if (b[k] &gt;&gt; j &amp; 1) b[k] ^= b[j]; break; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct LB &#123; int basis[MAX_BASE + 1]; LB() &#123; clear(); &#125; void clear() &#123; memset(basis, 0, sizeof(basis)); &#125; int query() &#123; int ret = 0; for (int i = MAX_BASE; i &gt;= 0; i--) &#123; ret = max(ret, ret ^ basis[i]); &#125; return ret; &#125; bool insert(int x) &#123; for (int i = MAX_BASE; i &gt;= 0 &amp;&amp; x; --i) if (x &gt;&gt; i &amp; 1) &#123; if (basis[i]) x ^= basis[i]; else &#123; basis[i] = x; return true; &#125; &#125; return false; &#125; LB operator+(const LB&amp; b) const &#123; LB ret; for (int i = 0; i &lt;= MAX_BASE; i++) ret.basis[i] = this-&gt;basis[i]; for (int i = MAX_BASE; i &gt;= 0; i--) if (b.basis[i]) ret.insert(b.basis[i]); return ret; &#125;&#125;;// 线性基求交LB Intersect(LB A, LB B) &#123; LB All, C, D; All.clear(); C.clear(); D.clear(); for (int i = MAX_BASE; i &gt;= 0; i--) &#123; All.basis[i] = A.basis[i]; D.basis[i] = 1ll &lt;&lt; i; &#125; for (int i = MAX_BASE; i &gt;= 0; i--) &#123; if (B.basis[i]) &#123; int v = B.basis[i], k = 0; bool can = true; for (int j = MAX_BASE; j &gt;= 0; j--) &#123; if (v &amp; (1ll &lt;&lt; j)) &#123; if (All.basis[j]) &#123; v ^= All.basis[j]; k ^= D.basis[j]; &#125; else &#123; can = false; All.basis[j] = v; D.basis[j] = k; break; &#125; &#125; &#125; if (can) &#123; int v = 0; for (int j = MAX_BASE; j &gt;= 0; j--) &#123; if (k &amp; (1ll &lt;&lt; j)) &#123; v ^= A.basis[j]; &#125; &#125; C.insert(v); &#125; &#125; &#125; return C;&#125; 自适应辛普森积分123456789101112131415double F(double x) &#123;&#125;double simpson(double a, double b) &#123; // 三点Simpson法 double c = a + (b - a) / 2; return (F(a) + 4 * F(c) + F(b)) * (b - a) / 6;&#125;double asr(double a, double b, double eps, double A) &#123; //自适应Simpson公式（递归过程）。已知整个区间[a,b]上的三点Simpson值A double c = a + (b - a) / 2; double L = simpson(a, c), R = simpson(c, b); if (fabs(L + R - A) &lt;= 15 * eps) return L + R + (L + R - A) / 15.0; return asr(a, c, eps / 2, L) + asr(c, b, eps / 2, R);&#125;double asr(double a, double b, double eps) &#123; return asr(a, b, eps, simpson(a, b));&#125; 图论DFS 序12345678910111213141516// 将子树转化为一个连续的区间// u 的子树区间 [in[u], out[u]]// 下标从1开始const int maxn = 100;vector&lt;int&gt; G[maxn];int in[maxn], out[maxn];int dfn;void init() &#123; dfn = 0; &#125;void dfs(int u, int fa) &#123; in[u] = ++dfn; for (auto &amp;v : G[u]) &#123; if (v != fa) dfs(v, u); &#125; out[u] = dfn;&#125; 割点123456789101112131415161718vector&lt;int&gt; G[maxn];int dfs_clock, dfn[maxn];bool iscut[maxn];int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; int child = 0; for (auto &amp;v : G[u]) &#123; if (!dfn[v]) &#123; child++; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &gt;= dfn[u]) iscut[u] = true; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) lowu = min(lowu, dfn[v]); &#125; if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = false; // root return lowu;&#125; 割边123456789101112131415161718192021vector&lt;pii&gt; G[maxn]; // first: 下一个点， second: 该边的编号int dfs_clock, dfn[maxn];bool iscut[N]; // N: 边数int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; // int father = 0; for (auto &amp;V : G[u]) &#123; int v = V.first; int id = V.second; // 边的编号 // if(v == fa) father++; if (!dfn[v]) &#123; int lowv = dfs(v, u); lowu = min(lowv, lowu); if (lowv &gt; dfn[u]) iscut[id] = true; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) lowu = min(lowu, dfn[v]); &#125; // if(father &gt; 1) return dfn[fa]; return lowu;&#125; 点双联通分量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;int&gt; G[maxn], bcc[maxn];int bcc_cnt, dfs_clock;int dfn[maxn], iscut[maxn], bccno[maxn];stack&lt;pii&gt; stk;int dfs(int u) &#123; int lowu = dfn[u] = ++dfs_clock; int child = 0; for (auto &amp;v : G[u]) &#123; pii e = &#123;u, v&#125;; if (!dfn[v]) &#123; stk.push(e); child++; int lowv = dfs(v, u); lowu = min(lowu, lowv); if (lowv &gt;= dfn[u]) &#123; // u为割点 iscut[u] = true; bcc_cnt++; bcc[bcc_cnt].clear(); //注意！bcc从1开始编号 for (;;) &#123; pii x = stk.top(); stk.pop(); if (bccno[x.first] != bcc_cnt) bcc[bcc_cnt].push_back(x.first), bcc[x.first] = bcc_cnt; if (bccno[x.second] != bcc_cnt) bcc[bcc_cnt].push_back(x.second), bcc[x.second] = bcc_cnt; if (x.first == u &amp;&amp; x.second == v) break; &#125; &#125; &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123; stk.push(e); lowu = min(lowu, dfn[v]); &#125; &#125; if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = 0; return lowu;&#125;//割点的bccno无意义void solve(int n) &#123; //调用结束后stack保证为空，所以不用清空 memset(iscut, 0, sizeof(iscut)); memset(bccno, 0, sizeof(bccno)); memset(dfn, 0, sizeof(dfn)); dfs_clock = bcc_cnt = 0; for (int i = 0; i &lt; n; i++) if (!dfn[i]) dfs(i, -1);&#125; 边双联通分量12345678910111213141516171819202122232425262728vector&lt;int&gt; G[maxn];int bcc_cnt, dfs_clock;int dfn[maxn], bccno[maxn];stack&lt;int&gt; stk;int dfs(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; stk.push(u); bool flag = false; // 有重边 for (auto &amp;v : G[u]) &#123; if (v == fa &amp;&amp; !flag) &#123; flag = true; continue; &#125; if (!dfn[v]) &#123; int lowv = dfs(v, u); lowu = min(lowu, lowv); &#125; else lowu = min(lowu, dfn[v]); &#125; if (lowu == dfn[u]) &#123; bcc_cnt++; // 编号从1开始 while (!stk.empty()) &#123; int v = stk.top(); bccno[v] = bcc_cnt; if (u == v) break; &#125; &#125;&#125; 强连通分量123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;int&gt; G[maxn];int scc, dfs_clock, top; // scc: 强连通分量的数量bool instack[maxn];int dfn[maxn], low[maxn], belong[maxn], Stack[maxn];// int num[maxn]; // 每个强连通分量的数量。 1 ~ scc// int maps[maxn]; //缩点之后 每个点对应的新点的标号void Tarjan(int u) &#123; dfn[u] = low[u] = ++dfs_clock; instack[u] = true; Stack[top++] = u; for (auto &amp;v : G[u]) &#123; if (!dfn[v]) &#123; Tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (instack[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; ++scc; int cnt = 0; int now; while (top &gt; 0) &#123; now = Stack[--top]; instack[now] = false; belong[now] = u; ++cnt; if (now == u) &#123; // num[scc] = cnt; // maps[u] = scc; break; &#125; &#125; &#125;&#125;void solve(int n) &#123; memset(instack, 0, sizeof(instack)); memset(dfn, 0, sizeof(dfn)); scc = dfs_clock = top = 0; for (int i = 1; i &lt;= n; i++) &#123; // 点的标号从1开始 if (!dfn[i]) Tarjan(i); &#125;&#125; 支配树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// dom[i]：（支配树）编号为i的点所支配的最近节点// idom[i]：编号为i的点的最近必经节点// semi[i]：编号为i的点的半必经节点// id[i]：dfn为i的点的编号// best[i]：编号为i的点的祖先中dfn最小的点的编号// pre[i]：编号为i的点的前驱// suc[i]：编号为i的点的后继// son[i]：编号为i的点的儿子struct DomiTree &#123; int dfs_clock; int dfn[maxn], id[maxn], fa[maxn]; int semi[maxn], best[maxn], idom[maxn]; vector&lt;int&gt; pre[maxn], dom[maxn], suc[maxn], son[maxn]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) &#123; pre[i].clear(), dom[i].clear(), suc[i].clear(), son[i].clear(); fa[i] = best[i] = idom[i] = semi[i] = i, dfn[i] = 0; &#125; dfs_clock = 0; &#125; void addedge(int u, int v) &#123; // u -&gt; v pre[v].push_back(u); suc[u].push_back(v); &#125; void build(int s) &#123; dfs(s); tarjan(); &#125; void dfs(int u) &#123; dfn[u] = ++dfs_clock; id[dfs_clock] = u; for (auto &amp;v : suc[u]) &#123; if (dfn[v]) continue; dfs(v); son[u].push_back(v); &#125; &#125; inline int Min(int x, int y) &#123; return dfn[semi[x]] &lt; dfn[semi[y]] ? x : y; &#125; int find(int u) &#123; if (u == fa[u]) return u; int v = find(fa[u]); best[u] = Min(best[fa[u]], best[u]); return fa[u] = v; &#125; void tarjan() &#123; for (int i = dfs_clock; i &gt; 0; i--) &#123; int k = id[i]; for (auto v : pre[k]) &#123; if (dfn[v] == 0) continue; if (dfn[v] &lt; dfn[k] &amp;&amp; dfn[v] &lt; dfn[semi[k]]) semi[k] = v; if (dfn[v] &gt;= dfn[k]) &#123; find(v); semi[k] = semi[Min(best[v], k)]; &#125; &#125; if (k != semi[k]) dom[semi[k]].push_back(k); for (auto &amp;v : dom[k]) &#123; find(v); if (semi[best[v]] == k) idom[v] = k; else idom[v] = best[v]; &#125; dom[k].clear(); for (auto &amp;v : son[k]) fa[v] = k; &#125; for (int i = 2; i &lt;= dfs_clock; i++) &#123; int k = id[i]; if (idom[k] != semi[k]) idom[k] = idom[idom[k]]; if (k != idom[k]) dom[idom[k]].push_back(k); &#125; &#125;&#125; dt; 单源最短路Dijkstra123456789101112131415161718192021222324252627282930// O(ElogV)typedef pair&lt;int, int&gt; pii;const int maxn = 100;int d[maxn];vector&lt;pii&gt; G[maxn];inline void addedge(int u, int v, int w) &#123; G[u].push_back(make_pair(w, v)); // G[v].push_back(make_pair(w,u));&#125;void dijkstra(int s, int n) &#123; for (int i = 0; i &lt; n; i++) d[i] = INF; d[s] = 0; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq; pq.push(mp(0, s)); while (!pq.empty()) &#123; pii now = pq.top(); pq.pop(); int v = now.second; if (d[v] &lt; now.first) continue; //剪枝！ 重要 for (int i = 0; i &lt; G[v].size(); i++) &#123; pii e = G[v][i]; int to = e.second; if (d[to] &gt; d[v] + e.first) &#123; d[to] = d[v] + e.first; pq.push(pii(d[to], to)); &#125; &#125; &#125;&#125; Bellman-Ford12345678910111213141516171819202122232425262728293031struct Edge&#123; int u,v,w; Edge(int u,int v,int w):u(u),v(v),w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;inline void addedge(int u,int v,int w)&#123; edges.push_back(Edge(u,v,w)); // edges.push_back(Edge(v,u,w));&#125;bool bellman_ford(int s,int n)&#123; for(int i=0;i&lt;n;i++) d[i] = INF; d[s] = 0; int cnt = 0; while(true)&#123; if(cnt &gt; n-1) return false; // exist negative circle cnt++; bool update = false; for(int i=0;i&lt;edges.size();i++)&#123; int from = edges[i].from; int to = edges[i].to; if(d[to] &gt; d[from] + edges[i].w)&#123; d[to] = d[from] + edges[i].w; // par[to] = from; // record path update = true; &#125; &#125; if(update == false) break; &#125; return true;&#125; 最小生成树Kruskal123456789101112131415161718192021222324252627282930313233const int maxn = 10;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;Edge&gt; edges;int par[maxn];void addedge(int u, int v, int w) &#123; edges.push_back(Edge(u, v, w)); // edges.push_back(Edge(v, u, w));&#125;int find(int x) &#123; return par[x] == x ? x : find(par[x]); &#125;int kruskal(int n) &#123; int ans = 0; for (int i = 0; i &lt; n; i++) par[i] = i; sort(edges.begin(), edges.end()); //按权值排序 int cnt = 0; for (int i = 0; i &lt; edges.size(); i++) &#123; if (cnt &gt;= n - 1) break; Edge &amp;now = edges[i]; int x = find(now.u); int y = find(now.v); if (x != y) &#123; cnt++; par[x] = y; ans += now.w; &#125; &#125; return ans;&#125; Prim1234567891011121314151617181920212223242526272829// 耗费矩阵cost[][],标号从0开始,0~n-1// 返回最小生成树的权值,返回-1表示原图不连通// O(n^2)const int maxn = 100;bool vis[maxn];int lowc[maxn];int cost[maxn][maxn]; //初始化为正无穷int Prim(int n) &#123; int ans = 0; memset(vis, 0, sizeof(vis)); vis[0] = 1; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; vis[p] = 1; ans += minc; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; return ans;&#125; 最近公共祖先 LCA倍增1234567891011121314151617181920212223242526272829const int BASE = 20;int dep[maxn]; // 深度int par[maxn][BASE + 1];void dfs(int u, int fa) &#123; dep[u] = dep[fa] + 1; par[u][0] = fa; for (auto&amp; v : G[u]) &#123; if (v == fa) continue; dfs(v, u); &#125;&#125;void init(int n) &#123; for (int j = 1; j &lt;= BASE; j++) for (int i = 1; i &lt;= n; i++) &#123; int v = par[i][j - 1]; par[i][j] = par[v][j - 1]; &#125;&#125;int lca(int u, int v) &#123; if (dep[u] &gt; dep[v]) swap(u, v); for (int i = BASE; i &gt;= 0; i--) if (dep[par[v][i]] &gt;= dep[u]) v = par[v][i]; // 先跳到同一高度 if (u == v) return u; for (int i = BASE; i &gt;= 0; i--) if (par[u][i] != par[v][i]) u = par[u][i], v = par[v][i]; // 一起向上跳 return par[u][0];&#125; ST1234567891011121314151617181920212223242526272829303132333435363738// 在线算法，预处理O(nlogn)，查询O(1)const int maxn = 1000000;struct LCA &#123; vector&lt;int&gt; G[maxn], sp; int dep[maxn], dfn[maxn]; pii dp[21][maxn &lt;&lt; 1]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) G[i].clear(); sp.clear(); &#125; void addEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; void dfs(int u, int fa) &#123; dep[u] = dep[fa] + 1; dfn[u] = sp.size(); sp.push_back(u); for (auto &amp;v : G[u]) &#123; if (v == fa) continue; dfs(v, u); sp.push_back(u); &#125; &#125; void initRmq() &#123; int n = sp.size(); for (int i = 0; i &lt; n; i++) dp[0][i] = &#123;dfn[sp[i]], sp[i]&#125;; for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++) for (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + (1 &lt;&lt; (i - 1))]); &#125; int lca(int u, int v) &#123; int l = dfn[u], r = dfn[v]; if (l &gt; r) swap(l, r); int k = 31 - __builtin_clz(r - l + 1); return min(dp[k][l], dp[k][r - (1 &lt;&lt; k) + 1]).second; &#125;&#125; lca; Tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 离线算法 O(n+q)const int maxn = 1000000;struct LCA &#123; vector&lt;int&gt; G[maxn]; vector&lt;pii&gt; Q[maxn]; bool vis[maxn]; int par[maxn], dist[maxn], ANS[maxn]; int find(int u) &#123; return u == par[u] ? u : par[u] = find(par[u]); &#125; void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; par[v] = u; &#125; &#125; void init(int n, int m) &#123; for (int i = 0; i &lt; n + 1; i++) &#123; G[i].clear(); vis[i] = false; par[i] = i; &#125; for (int i = 0; i &lt; m + 1; i++) Q[i].clear(); &#125; void add_edge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void add_query(int u, int v, int id) &#123; Q[u].pb(mp(v, id)); Q[v].pb(mp(u, id)); &#125; void Tarjan(int u, int fa) &#123; vis[u] = true; for (auto v : G[u]) &#123; if (fa != v) &#123; Tarjan(v, u); merge(u, v); // 注意合并顺序，一定是v合并到u上 &#125; &#125; for (auto V : Q[u]) &#123; if (vis[V.first] == true) &#123; ANS[V.second] = find(V.first); // 公共祖先为par[v] &#125; &#125; &#125;&#125; lca; Dsu-on-tree1234567891011121314151617181920212223242526272829303132333435363738394041// O(nlogn)// 统计所有子树的信息。启发式合并，保留重儿子的信息。// 给一棵树，每个节点都有一个颜色，每次查询问某棵子树上颜色为c的节点数vector&lt;int&gt; *vec[maxn], G[maxn];int cnt[maxn], sz[maxn], col[maxn];bool vis[maxn], bigc[maxn];int szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void add(int u, int fa, int x) &#123; cnt[col[u]] += x; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !bigc[v]) add(v, u, x);&#125;void dfs(int u, int fa, bool keep) &#123; int mx = -1, bc = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) &#123; mx = sz[v]; bc = v; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bc) dfs(v, u, 0); // run a dfs on small childs and clear them from cnt if (bc != -1) &#123; dfs(bc, u, 1); bigc[bc] = 1; &#125; // bigChild marked as big and not cleared from cnt add(u, fa, 1); // now cnt[c] is the number of vertices in subtree of vertex v that has // color c. You can answer the queries easily. if (bc != -1) bigc[bc] = 0; if (!keep) add(u, fa, -1);&#125; 网络流Edmond—Karp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Edge&#123; int from,to,cap,flow; Edge(int u,int v,int c,int f): from(u),to(v),cap(c),flow(f) &#123;&#125;&#125;;struct EdmonsKarp&#123; //时间复杂度O(v*E*E) int n,m; vector&lt;Edge&gt; edges; //边数的两倍 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号 int a[maxn]; //起点到i的可改进量 int p[maxn]; //最短路树上p的入弧编号 void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap)&#123; edges.push_back(Edge(from,to,cap,0)); edges.push_back(Edge(to,from,0,0)); //反向弧 m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; int Maxflow(int s,int t)&#123; int flow = 0; for(;;)&#123; memset(a,0,sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while(!Q.empty())&#123; int x = Q.front();Q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; Edge&amp; e = edges[G[x][i]]; if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123; //!a[e.to] 是了保证不会回退和出现分叉 p[e.to] = G[x][i]; //记录边的编号 a[e.to] = min(a[x],e.cap - e.flow); Q.push(e.to); &#125; &#125; if(a[t]) break; //走到汇点 &#125; if(!a[t]) break; //没有一条增广路存在 for(int u=t;u != s;u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125; ek; Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const int maxn = 1e4 + 6;const int INF = 0x3f3f3f3f;struct Edge &#123; int u, v; int cap, flow; Edge(int u_, int v_, int cap_, int flow_) : u(u_), v(v_), cap(cap_), flow(flow_) &#123;&#125;&#125;;struct Dinic &#123; int n, m, s, t; //结点数，边数（包括反向弧），源点编号和汇点编号 vector&lt;Edge&gt; edges; //边表。edge[e]和edge[e^1]互为反向弧 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号 bool vis[maxn]; // BFS使用 int d[maxn]; //从起点到i的距离 int cur[maxn]; //当前弧下标 void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt;= n; i++) G[i].clear(); edges.clear(); &#125; int AddEdge(int from, int to, int cap) &#123; edges.emplace_back(from, to, cap, 0); edges.emplace_back(to, from, 0, 0); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); return m - 2; &#125; bool BFS() &#123; for (int i = 0; i &lt;= n; ++i) vis[i] = false, d[i] = 0; queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0, v; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; v = e.v; if (!vis[v] &amp;&amp; e.cap &gt; e.flow) &#123; vis[v] = 1; d[v] = d[x] + 1; q.push(v); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int x, int a) &#123; if (x == t || a == 0) return a; int flow = 0, f; for (int &amp;i = cur[x], v; i &lt; G[x].size(); i++) &#123; //从上次考虑的弧 Edge&amp; e = edges[G[x][i]]; v = e.v; if (d[x] + 1 == d[v] &amp;&amp; (f = DFS(v, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; &#125; &#125; return flow; &#125; int Maxflow(int s, int t) &#123; this-&gt;s = s, this-&gt;t = t; int flow = 0; while (BFS()) &#123; for (int i = 0; i &lt;= n; i++) cur[i] = 0; flow += DFS(s, INF); &#125; return flow; &#125; int edge_id[maxn]; // 每条边的编号 vector&lt;int&gt; cut; // 割边的编号 void findCut(int m) &#123; cut.clear(); for (int i = 0; i &lt;= n; i++) vis[i] = 0; queue&lt;int&gt; q; q.push(s); vis[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto &amp;id : G[u]) &#123; auto &amp;e = edges[id]; if (!vis[e.v] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.v] = 1; q.push(e.v); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; auto &amp;e = edges[edge_id[i]]; if (vis[e.u] == vis[e.v]) continue; if (e.cap == e.flow) cut.push_back(i + 1); // 1-index &#125; &#125;&#125; dinic; ISAP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const int maxn = "Edit";struct ISAP &#123; int n, m, s, t; //结点数，边数（包括反向弧），源点编号和汇点编号 vector&lt;Edge&gt; edges; //边表。edges[e]和edges[e^1]互为反向弧 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示结点i的第j条边在e数组中的序号 bool vis[maxn]; // BFS使用 int d[maxn]; //起点到i的距离 int cur[maxn]; //当前弧下标 int p[maxn]; //可增广路上的一条弧 int num[maxn]; //距离标号计数 void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.emplace_back(from, to, cap, 0); edges.emplace_back(to, from, 0, 0); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int Augumemt() &#123; int x = t, a = INF; while (x != s) &#123; Edge&amp; e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; &#125; x = t; while (x != s) &#123; edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a; x = edges[p[x]].from; &#125; return a; &#125; void BFS() &#123; for (int i = 0; i &lt;= n; i++) vis[i] = 0; for (int i = 0; i &lt;= n; i++) d[i] = 0; queue&lt;int&gt; q; q.push(t); d[t] = 0; vis[t] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); int len = G[x].size(); for (int i = 0; i &lt; len; i++) &#123; Edge&amp; e = edges[G[x][i] ^ 1]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.from] = 1; d[e.from] = d[x] + 1; q.push(e.from); &#125; &#125; &#125; &#125; int Maxflow(int s, int t) &#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; BFS(); for (int i = 0; i &lt;= n; i++) num[i] = 0; for (int i = 0; i &lt; n; i++) if (d[i] &lt; INF) num[d[i]]++; int x = s; for (int i = 0; i &lt;= n; i++) cur[i] = 0; while (d[s] &lt; n) &#123; if (x == t) &#123; flow += Augumemt(); x = s; &#125; int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) &#123; ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; &#125; &#125; if (!ok) // Retreat &#123; int m = n - 1; for (int i = 0; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) m = min(m, d[e.to]); &#125; if (--num[d[x]] == 0) break; // gap优化 num[d[x] = m + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; &#125; &#125; return flow; &#125;&#125; isap; 最小费用最大流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct Edge&#123; int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) &#123;&#125;&#125;;struct MCMF&#123; int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; //是否在队列中 int d[maxn]; //bellmanford 到源点距离 int p[maxn]; //上一条弧 int a[maxn]; //可改进量 void init(int n)&#123; this-&gt; n = n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost)&#123; edges.push_back(Edge(from,to,cap,0,cost)); edges.push_back(Edge(to,from,0,0,-cost)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BellmanFord(int s,int t,int&amp; flow,ll&amp; cost)&#123; for(int i=0;i&lt;=n;i++) d[i] = INF; memset(inq,0,sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); inq[u] = 0; for(int i=0;i&lt;G[u].size();i++)&#123; Edge&amp; e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to]) &#123;Q.push(e.to); inq[e.to] = 1;&#125; &#125; &#125; &#125; if(d[t] == INF) return false; // 当没有可增广的路时退出 flow += a[t]; cost += (ll)d[t] * (ll)a[t]; for(int u=t; u!= s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; return true; &#125; int MincostMaxflow(int s,int t,ll&amp; cost)&#123; int flow = 0; cost = 0; while(BellmanFord(s,t,flow,cost)); return flow; &#125;&#125; mcmf; 无向图全局最小割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// O(n^3) 1-index// 不能有负权边 （可以改成加偏移的，不过有点烦struct StoerWagner &#123; int n; int mask[maxn]; // 因为有删点的操作，所以用mask[i]来表示第i个位置是几号点 int G[maxn][maxn]; // 邻接矩阵 int d[maxn]; // 表示集合到各个点的距离 bool vis[maxn]; // 该点是否加入了集合 void init(int n) &#123; this-&gt;n = n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] = 0; &#125; void addedge(int u, int v, int c) &#123; G[u][v] += c; G[v][u] += c; &#125; int solve() &#123; int res = INF; for (int i = 1; i &lt;= n; i++) mask[i] = i; while (n &gt; 1) &#123; int k, pre = 1; // 默认1号点是集合的第一个点 for (int i = 1; i &lt;= n; i++) vis[mask[i]] = 0, d[mask[i]] = 0; vis[mask[pre]] = true; for (int i = 2; i &lt;= n; i++) &#123; k = -1; for (int j = 1; j &lt;= n; j++) &#123; // 寻找距离最远的点加入集合 if (!vis[mask[j]]) &#123; d[mask[j]] += G[mask[pre]][mask[j]]; if (k == -1 || d[mask[k]] &lt; d[mask[j]]) k = j; &#125; &#125; vis[mask[k]] = true; // 加入集合 if (i == n) &#123; // 只剩一个点 res = min(res, d[mask[k]]); for (int j = 1; j &lt;= n; j++) &#123; // 修改边权 G[mask[pre]][mask[j]] += G[mask[j]][mask[k]]; G[mask[j]][mask[pre]] += G[mask[j]][mask[k]]; &#125; mask[k] = mask[n--]; // 去掉最后加入的点 &#125; pre = k; &#125; &#125; return res; &#125;&#125; sw; 数据结构树状数组1234567891011121314151617181920212223242526// 数组下标必须从1开始// 单点更新区间查询int BIT[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l,int r)&#123; int ret = 0; for(int i=l-1;i&gt;0;i-=lowb(i)) ret -= BIT[i]; for(int i=r;i&gt;0;i-=lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x,int y,int n)&#123; for(int i=x;i&lt;=n;i+=lowb(i)) BIT[i] += y;&#125;//区间更新单点查询int diff[maxn];inline int lowb(int x) &#123;return x &amp;(-x);&#125;inline int query(int x)&#123; int ret = 0; for(int i=x;i&gt;0;i-=lowb(i)) ret += diff[i]; return ret;&#125;inline void update(int l,int r,int val,int n)&#123; for(int i=l;i&lt;=n;i+=lowb(i)) diff[i] += val; for(int i=r+1;i&lt;=n;i+=lowb(i)) diff[i] -= val;&#125; 线段树1234567// 左闭右闭#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)const int maxn = "Edit";int seg[maxn &lt;&lt; 2]; 单点更新，区间查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 左闭右闭 [l,r]void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] = num[l]; // cin &gt;&gt; seg[rt]; //建立的时候直接输入叶节点 return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int p, int add, int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] += add; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, add,l,m,lson); else update(p, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; // L R 是要查询的区间 if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) s += query(L, R, l,m,lson); if (m &lt; R) s += query(L, R, m+1,r,rson); return ret;&#125;// update interval// lazy[rt]用于存放懒惰标记，注意PushDown时标记的传递const int maxn = "Edit";int lazy[maxn &lt;&lt; 2], seg[maxn &lt;&lt; 2];void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void pushdown(int rt, int len) &#123; if (lazy[rt] == 0) return; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; seg[lson] += lazy[rt] * lson_len; seg[rson] += lazy[rt] * rson_len; lazy[rt] = 0;&#125;void build(int l, int r, int rt) &#123; lazy[rt] = 0; if (l == r) &#123; seg[rt] = num[l]; //cin &gt;&gt; seg[rt]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int L, int R, int add, int l, int r, int rt) &#123; // L R 是要更新的区间 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; lazy[rt] += add; seg[rt] += add * (r - l + 1); return; &#125; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, add, l,m,lson); if (m &lt; R) update(L, R, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) ret += query(L, R, l,m,lson); if (m &lt; R) ret += query(L, R, m+1,r,rson); return ret;&#125;// interval mergestruct Seg&#123; int mx,lmx,rmx;&#125;;void pushup(int rt,int len)&#123; seg[rt].mx = max(seg[lson].mx, max(seg[rson].mx, seg[lson].rmx + seg[rson].lmx)); seg[rt].lmx = seg[lson].lmx; seg[rt].rmx = seg[rson].rmx; if(seg[rt].lmx == lson_len) seg[rt].lmx += seg[rson].lmx; if(seg[rt].rmx == rson_len) seg[rt].rmx += seg[lson].rmx;&#125; 单调栈12345678910111213141516171819202122232425int L[maxn], R[maxn];int a[maxn];// 找到左边第一个大于它的元素位置l-1，和右边第一个大于它的元素位置r+1// [l,r]void init(int n) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; n; i++) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) L[i] = 0; else L[i] = st.top() + 1; st.push(i); &#125; while (!st.empty()) st.pop(); for (int i = n - 1; i &gt;= 0; i--) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) R[i] = n-1; else R[i] = st.top() - 1; st.push(i); &#125;&#125; 单调队列12345678deque&lt;pii&gt; dq; // (pos, val)for(int i=1;i&lt;=n;i++)&#123; while(dq.size() &amp;&amp; 队首过期) dq.pop_front(); while(dq.size() &amp;&amp; 加入当前元素后队列不单调) dq.pop_back(); dq.push_back(当前元素) 队首进行决策&#125; 树链剖分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 1000000;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn],rk[maxn]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u,int v)&#123; G[u].pb(v); G[v].pb(u); &#125; void build() &#123; dfs(1, 1, 1); link(1, 1); &#125; void dfs(int u,int fa,int d)&#123; dep[u] = d; par[u] = fa; sz[u] = 1; for(auto &amp;v:G[u])&#123; if(v == fa) continue; dfs(v,u,d+1); sz[u] += sz[v]; if(son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u,int t)&#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if(son[u] == -1) return ; link(son[u],t); // 保证重链的dfs序是连续的 for(auto &amp;v:G[u])&#123; if(v != son[u] &amp;&amp; v != par[u]) link(v,v); &#125; &#125; void update(int u,int v,int w) &#123;&#125; // 数据结构 int query(int u,int v) &#123;&#125; // 数据结构 void update_path(int u,int v,int w)&#123; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); update(id[top[u]],id[u],w); u = par[top[u]]; &#125; // if(u == v) return; // 边权 if(dep[u] &gt; dep[v]) swap(u,v); update(id[u],id[v],w); // 点权 // update(id[u] + 1,id[v],w); // 边权 &#125; int query_path(int u,int v)&#123; int ret = 0; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); ret += query(id[top[u]],id[u]); u = par[top[u]]; &#125; // if(u == v) return ret; // 边权 if(dep[u] &gt; dep[v]) swap(u,v); ret += query(id[u],id[v]); // 点权 // ret += query(id[u] + 1,id[v]); // 边权 return ret; &#125;&#125; hld; 主席树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int maxn = 100;const int N = maxn + Qlog(n);int root[maxn]; // 记录每个版本的根节点int sum[N], lch[N], rch[N];int dfn = 0;// 单点修改，区间查询inline void pushup(int rt) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; if (l == r) &#123; sum[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old];&#125;void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++dfn; newnode(old, k); if (l == r) &#123; sum[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (p &lt;= m) update(lch[old], lch[k], l, m, p, x); if (p &gt; m) update(rch[old], rch[k], m + 1, r, p, x); pushup(k);&#125;int query(int k1, int k2, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k2] - sum[k1]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R); if(m &lt; R) ret += query(rch[k],m+1,r,L,R); return ret;&#125;// 区间更新 区间查询int lazy[N];inline void pushup(int rt, int len) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]] + len * lazy[sum];&#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; lazy[k] = 0; if (l == r) &#123; cin &gt;&gt; sum[k]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k, r - l + 1);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old]; lazy[k] = lazy[old];&#125;void update(int old, int &amp;k, int l, int r, int L, int R, int x) &#123; k = ++dfn; newnode(old, k); if (L &lt;= l &amp;&amp; R &gt;= r) &#123; sum[k] += x * (r - l + 1); lazy[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (m &gt;= L) update(lch[old], lch[k], l, m, L, R, x); if (m &lt; R) update(rch[old], rch[k], m + 1, r, L, R, x); pushup(k, r - l + 1);&#125;int query(int k, int l, int r, int L, int R, int x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k] + x * (r - l + 1); x += lazy[k]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R,x); if(m &lt; R) ret += query(rch[k],m+1,r,L,R,x); return ret;&#125; Todo动态开点线段树SplayLCT珂朵莉 动态规划RMQ一维 RMQ1234567891011121314151617// nlog(n) 预处理， log(n) 查询// 起始下标为1const int maxn = 100;int dp[maxn][maxn];int a[maxn];void rmq_init(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int k = 1; (1 &lt;&lt; k) &lt;= n; k++) &#123; for (int i = 1; i + (1 &lt;&lt; k) &lt; n; i++) &#123; dp[i][k] = min(dp[i][k - 1], dp[i + (1 &lt;&lt; (k - 1))][k - 1]); &#125; &#125;&#125;int rmq(int l, int r) &#123; int k = 31 - __builtin_clz(r - l + 1); // 前导零的个数 return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; 二维 RMQ123456789101112131415161718192021222324252627282930313233343536373839// dp[r][c][i][k]: 表示(r,c)为左上角,(r + 2^i - 1, c + 2^k - 1)为右下角的矩阵中的最小值// 预处理 n*m*log(n)*log(m)， 查询 log(nm)// 起始下标为1const int maxn = 100;int dp[maxn][maxn][maxn][maxn];int a[maxn][maxn];void rmq_init(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int k = 1; k &lt;= m; k++) &#123; dp[i][k][0][0] = a[i][k]; &#125; &#125; for (int i = 0; (1 &lt;&lt; i) &lt;= n; i++) &#123; for (int k = 0; (1 &lt;&lt; k) &lt;= m; k++) &#123; if (!i &amp;&amp; !k) continue; for (int r = 1; r + (1 &lt;&lt; i) - 1 &lt;= n; r++) &#123; for (int c = 1; c + (1 &lt;&lt; k) - 1 &lt;= m; c++) &#123; if (!k) dp[r][c][i][k] = min(dp[r][c][i - 1][k], dp[r + (1 &lt;&lt; (i - 1))][c][i - 1][k]); else dp[r][c][i][k] = min(dp[r][c][i][k - 1], dp[r][c + (1 &lt;&lt; (k - 1))][i][k - 1]); &#125; &#125; &#125; &#125;&#125;int rmq(int x1, int y1,int x2,int y2) &#123; int kx = 31 - __builtin_clz(x2 - x1 + 1); int ky = 31 - __builtin_clz(y2 - y1 + 1); int m1 = dp[x1][y1][kx][ky]; int m2 = dp[x2 - (1 &lt;&lt; kx) + 1][y1][kx][ky]; int m3 = dp[x1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; int m4 = dp[x2 - (1 &lt;&lt; kx) + 1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; return min(&#123;m1,m2,m3,m4&#125;);&#125; 子集 DP12345678// O(3^n)for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; for (int j = i; j; j = (j - 1) &amp; i) &#123; /* j为i的子集 */ &#125;&#125; 12345678910// O(n2^n)for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; if (j &amp; (1 &lt;&lt; i)) &#123; /* j ^ (1 &lt;&lt; i) 为 j 的子集 */ &#125; &#125;&#125; 博弈SG 函数123456789101112131415161718192021222324252627282930313233343536373839// sg[] = 0 必败，其余必胜const int maxn = 100;int f[N];int SG[maxn]; //int S[maxn]; // x 的后继状态void getSG(int n) &#123; SG[0] = 0; // clr(SG,0); for (int i = 1; i &lt; maxn; i++) &#123; clr(S, 0); for (int k = 0; f[k] &lt;= i &amp;&amp; k &lt; n; k++) S[SG[i - f[k]]] = 1; for (int k = 0;; k++) &#123; if (!S[k]) &#123; SG[i] = k; break; &#125; &#125; &#125;&#125;// 单点SG查询void init()&#123; clr(SG,-1);&#125;int getSG(int n, int foo) &#123; if (SG[foo] != -1) return SG[foo]; // int S[N] = &#123;0&#125;; set&lt;int&gt; S; for (int k = 0; f[k] &lt;= foo &amp;&amp; k &lt; n; k++) &#123; int bar = getSG(n, foo - f[k]); S.insert(bar); // S[bar] = 1; &#125; for (int k = 0;; k++) &#123; if (S.find(k) == S.end()) &#123; return SG[foo] = k; &#125; &#125;&#125; 其它三分整数三分1234567891011121314151617// 求极大值 [l,r]int find(int l, int r) &#123; int m1, m2, val = 0, ret; while (r - l &gt;= 3) &#123; m1 = l + (r - l) / 3; m2 = r - (r - l) / 3; if (work(m1) &gt; work(m2)) r = m2; else l = m1; &#125; for (int i = l; i &lt;= r; i++) &#123; int res = work(i); if (val &lt; res) val = res, ret = i; &#125; return ret;&#125; 浮点三分123456789101112131415// 求极小值double find(double l, double r) &#123; double m1, m2; while (r - l &gt;= eps) &#123; m1 = l + (r - l) / 3; m2 = r - (r - l) / 3; // m1 = l + r &gt;&gt; 1; // m2 = m1 + r &gt;&gt; 1; if (work(m1) &gt; work(m2)) l = m1; else r = m2; &#125; return (m1 + m2) / 2;&#125; 三维前缀和12345678910111213141516171819int a[maxn][maxn][maxn];int sum(int x1, int y1, int z1, int x2, int y2, int z2) &#123; return a[x2][y2][z2] - a[x1 - 1][y2][z2] - a[x2][y1 - 1][z2] - a[x2][y2][z1 - 1] + a[x1 - 1][y1 - 1][z2] + a[x1 - 1][y2][z1 - 1] + a[x2][y1 - 1][z1 - 1] - a[x1 - 1][y1 - 1][z1 - 1];&#125;void init(int n) &#123; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i - 1][k][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k - 1][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k][t - 1];&#125; 离散化1234567891011vector&lt;int&gt; a,b;for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i]; b[i] = a[i];&#125;b.sort(b.begin(),b.end());b.resize(distance(b.begin(),unique(b.begin(),b.end())));inline int getid(int x)&#123; return lower_bound(b.begin(),b.end(),x) - b.begin() + 1;&#125; 12345678for(int i=0;i&lt;n;i++)&#123; A[i] = B[i];&#125;sort(B,B+n);int size = unique(B,B+n) - B;for(int i=0;i&lt;n;++)&#123; A[i] = lower_bound(B,B+size,A[i]) - B + 1;&#125; 分数类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586template &lt;class _EuclideanRingElement&gt;_EuclideanRingElement lcm(_EuclideanRingElement a, _EuclideanRingElement b) &#123; _EuclideanRingElement g = __gcd(a, b); if (g == 0) return a * b; return a / g * b;&#125;class Rational &#123; public: Rational(const long long&amp; n = 0, const long long&amp; d = 1) &#123; numerator = d &lt; 0 ? -n : n; denominator = d &lt; 0 ? -d : d; reduce(); &#125; Rational(const long long&amp; t) : numerator(t), denominator(1) &#123; reduce(); &#125; Rational(const int&amp; t) : numerator(t), denominator(1) &#123; reduce(); &#125; Rational operator+(const Rational&amp; a) const &#123; Rational t; t.denominator = lcm(a.denominator, denominator); t.numerator = a.numerator * (t.denominator / a.denominator) + (t.denominator / denominator) * numerator; if (denominator != 0) t.reduce(); return t; &#125; Rational operator-(const Rational&amp; s) const &#123; Rational t; t.denominator = lcm(s.denominator, denominator); t.numerator = numerator * (t.denominator / denominator) - (t.denominator / s.denominator) * s.numerator; if (denominator != 0) t.reduce(); return t; &#125; Rational operator*(const Rational&amp; m) const &#123; Rational t; t.numerator = m.numerator * numerator; t.denominator = m.denominator * denominator; if (denominator != 0) t.reduce(); return t; &#125; Rational operator/(const Rational&amp; v) const &#123; Rational t; t.numerator = v.denominator * numerator; t.denominator = denominator * v.numerator; if (denominator != 0) t.reduce(); return t; &#125; int cmp() &#123; if (numerator == 0) return 0; return numerator &lt; 0 ? -1 : 1; &#125; bool operator&lt;(const Rational&amp; s) const &#123; return ((*this) - s).cmp() &lt; 0; &#125; bool operator==(const Rational&amp; s) &#123; return ((*this) - s).cmp() == 0; &#125; void print() &#123; reduce(); if (denominator == 0) &#123; cout &lt;&lt; endl &lt;&lt; "DIVIDE BY ZERO ERROR!!!" &lt;&lt; endl; exit(-1); &#125; else if (numerator == 0) printf("%d\n", 0); else if (denominator == 1) printf("%lld\n", numerator); else printf("%lld/%lld\n", numerator, denominator); &#125; long long numerator; long long denominator; void reduce() &#123; if (denominator &lt; 0) denominator = -denominator, numerator = -numerator; long long n = numerator &lt; 0 ? -numerator : numerator; long long d = denominator; long long gcd = __gcd(n, d); if (gcd != 0) &#123; numerator /= gcd; denominator /= gcd; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN与NAT]]></title>
    <url>%2F2019%2F03%2F26%2FVPN%E4%B8%8ENAT%2F</url>
    <content type="text"><![CDATA[虚拟专用网VPNVPN：Virtual Private Nerwork. 专用网由于IP地址的紧缺，一个机构所能申请到的IP地址数量可能达不到本地主机数量。为了方便机构内部的通信，我们可以自行分配IP地址，这些IP地址只在机构的内部有效，也称为本地地址。那么对应的，从互联网管理机构申请的全球唯一的IP地址就是全球地址。很明显这些本地地址是不能够在互联网上通信的。接下里是如何选择本地地址：如果随机选择本地地址，可能会出现某个主机的本地地址和互联网中的某个IP重合，这样路由器就不知道该把数据报传给谁了。为了解决这个问题，RFC 1918指明了一些专有地址，这些地址只能用于机构内部的通信，在互联网中的路由器，对目的地址是专有地址的数据报一律不进行转发。专有地址： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 采用专有地址的互连网称为专用互联网或本地互联网。 何为虚拟？虚拟就是指通信双方并无直接的通信链路相连。一般要通过互联网进行数据传输。两个专有网通过互联网进行相连，对于用户来说就是一个专有网。那么通过互联网连接的两个专有网，他们各自都要至少有一台联接互联网的路由器。通信的过程大致如下： 发现目的地址不在本地的专有网中，就把数据报传送到路由器 路由器将原始数据报进行加密，再加上新的目的地址（另一个专有网的路由器地址），然后发送。 对方的路由器收到数据报后进行解密，提取到原来的目的地址，然后发送到指定主机。 从中发现，要构建一个VPN，每个专有网都需要知道所有其它专有网的地址。 在学校中经常会使用到VPN去连接校园网，它的原理大概也就能猜出来：填写好VPN软件的配置信息（包括目的网络的IP地址和端口号），然后加密解密的协议要统一，同时还要告诉目的网络你的信息(地址，端口，账户，密码），授权成功之后，应该就算连接建立成功，就可以通信了。 网络地址转换NATNAT：Network Address Translation 专有网中的主机想要连接互联网，并且没有足够的全球地址怎么办？通过在连接了互联网的路由器上安装NAT软件即可实现，它的原理是这样的：专有网中的主机发送一个数据报到互联网上的某个地址，那么这个数据报会先到那个连接了互联网的路由器那里。此时路由器会记录发送者的专有地址（见下表），然后把数据报的源地址改为路由器的地址再发送出去。当路由器收到了来自互联网的数据报，他会根据之前的记录查找数据报上的目的地址对应的专有网的专有地址。这样路由器中的一个全球地址就可以形成一条专有网到互联网的链路。 NAT地址转换表举例：|方向|字段|旧的IP|新的IP||—|—|—|—||出|源IP地址|192.168.0.3（专有地址）|172.38.1.5（路由器IP）||入|目的IP地址|172.38.1.5|192.168.0.3| 网络地址与端口号转换NAPTNAPT：Network Address and Port Translation 在NAT的基础上加了一个端口号，这样就可以实现专有网中多个主机公用一个路由器IP。直接看它的地址转换表： 方向 字段 旧的IP和端口 新的IP和端口 出 源IP地址:TCP源端口 192.168.0.3:30000（专有地址） 172.38.1.5:40001（路由器IP） 出 源IP地址:TCP源端口 192.168.0.4:30000（专有地址） 172.38.1.5:40002（路由器IP） 入 目的IP地址:TCP源端口 172.38.1.5:40001 192.168.0.3:30000]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>VPN</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang学习]]></title>
    <url>%2F2019%2F03%2F22%2FGolang%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Blank Identifier1234Go defines a special identifier _, called the blank identifier. The blank identifier can be used in a declaration to avoid declaring a name, and it can be used in an assignment to discard a value. This definition makes it useful in a variety of contexts. 参考博客 第三方包下载到https://github.com/golang?page=1 找到要下载的包然后克隆到GOPATH/src/golang.org/x/下即可 多变量赋值1x,y = y,x 在赋值操作之前会先对等号右边所有表达式求值，然后再同一更新左边的变量。这也是为什么上面的代码可以这么写。 Golang中的自动垃圾回收机制Garbage Collection(GC)的大致工作原理：Go采用了一种标记-清扫的办法来进行垃圾回收。程序运行一段时间或垃圾达到一定阈值后，系统会运行STW(stop the world)程序，使所有程序休眠。然后gc会从所有的包变量和当前运行函数的局部变量开始搜索，查找所有与之关联的变量。对于那些不可达的变量会进行内存回收。 对程序编写的直观改变就是对于申请内存，无需手动delete。 但是gc也无疑会增加程序的运行时间，这个留到以后遇到问题再进行深入研究。 数组的传递在Golang中，数组作为参数传递时，函数接收到的是一个副本，并不是原数组的引用。所以如果想要在函数中直接修改数组，则需要传入数组的指针。 for range12The range expression x is evaluated once before beginning the loop, with one exception: if at most one iteration variable is present and len(x) is constant, the range expression is not evaluated. 参考博客 12345678910111213arr := []int&#123;1, 2, 3&#125;var a []intvar b []*intfor _, i := range arr &#123; a = append(a, i) b = append(b, &amp;i)&#125;for _, i := range a &#123; fmt.Println(i)&#125;for _, i := range b &#123; fmt.Println(i)&#125; 输出：1234561230xc00005a0580xc00005a0580xc00005a058 我们发现循环变量$i$的地址是不变的。实际上的循环实现大致如下：1234567Arrange to do a loop appropriate for the type. We will producefor INIT ; COND ; POST &#123; ITER_INIT INDEX = INDEX_TEMP VALUE = VALUE_TEMP // If there is a value original statements&#125; VALUE是重复使用的一个临时变量，它的地址是不会改变的。这也解释了为什么输出的地址都是一样的。 Defer1234A &quot;defer&quot; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. 被延迟的函数，它的执行会在它的surrounding function返回之前执行。具体来说123456789func main() &#123; fmt.Println(f())&#125;func f() (result int) &#123; defer func() &#123; result++ &#125;() return 0&#125; 输出：11 匿名函数的执行会在f()返回时执行。f()的返回分为两步： result = 0 return result 而被延迟的函数就会在第一步执行完后开始执行。因此输出为1 如果surrounding function中有多个defer的函数，那么它们的执行顺序满足先进后出。 Defer可以用于标识那些surrounding function结束之前必须要执行的操作 参考文献 方法方法和函数的区别方法声明的时候会在func后加上接收器123type fuck struct&#123;&#125;func (f fuck) set()&#123;&#125; // 方法func set()&#123;&#125; // 函数 在方法中修改接收器的值调用方法时，接收器的传递是值传递，如果想要修改接收器的值，必须传入指针。123456789101112131415161718192021222324package mainimport "fmt"type fuck struct &#123; x, y int&#125;func (f fuck) set1() &#123; f.x = 1 f.y = 2&#125;func (f *fuck) set2() &#123; (*f).x = 1 (*f).y = 2&#125;func main() &#123; a := fuck&#123;3, 4&#125; fmt.Println(a.x, a.y) a.set1() fmt.Println(a.x, a.y) a.set2() // 不需要 (&amp;a).set2() 编译器会优化 fmt.Println(a.x, a.y)&#125; 输出：1233 43 41 2]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp中的正推与逆推]]></title>
    <url>%2F2019%2F03%2F01%2Fdp%E4%B8%AD%E7%9A%84%E6%AD%A3%E6%8E%A8%E4%B8%8E%E9%80%86%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[简介在写dp的题目中常常会涉及到状态转移方程的写法，一般常见的有两种： 正推：由$i$推$i+1$，即去算$i$对之后状态的贡献。 逆推：$i$是由$i-1$推来的，即当前状态是由之前状态推得的。 这两种本质上是没有区别的，但是在写法上略有区别对于正推，我们要注重它的起点，以及当前的贡献要满足什么条件才能加到之后的状态中去对于逆推，我们要注重它的边界，一般需要预处理一些边界，还要注意之前的状态能否转移到当前状态 例题牛牛数括号题目链接 题目描述给你两个括号序列，不保证合法，求有多少种不同的方法可以将两个括号序列合并成一个合法的括号序列合并的时候不能改变各自序列原先的顺序 输入描述输入两行包含两个字符串s1,s2 1 ≤ |s1|,|s2| ≤ 2500 输出描述输出一个整数，魔$10^9+7$ 解法首先我们定义x序列为：有可能通过在尾部添加)使得序列合法，注意这里并不只是要满足左括号数量多于右括号，对于)((这样的序列也是不合法的。 设$dp[i][j]$表示$s1$中前$i$个和$s2$中前$j$个，组成x序列的个数如果i,j都非零，且总左括号数量大于等于右括号数量，那么dp[i][j] &gt; 0 最后的答案：如果两个字符串中左括号的总数等于右括号的总数，那么dp[i][j]就是答案，不然就是0. 正推：1234567dp[0][0] = 1;for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(dp[i][j] &gt; 0)&#123; 如果(i+1, j)是满足左括号数量减去右括号数量大于0的，那么dp[i+1][j] += dp[i][j]; 如果(i, j+1)是满足左括号数量减去右括号数量大于0的，那么dp[i][j+1] += dp[i][j]; &#125; 逆推：123456789要预处理所有的dp[i][0]和dp[0][i]要注意并不是左括号数量大于等于右括号数量就为1，)( 这种情况也是不合法的！！！for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if((i,j) 满足总左括号数量大于总右括号数量)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; // 不需要再去判断之前的状态是否合法，因为如果不合法，其dp值一定是0 &#125;]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Colab 在线训练深度学习模型]]></title>
    <url>%2F2019%2F02%2F28%2FGoogle-Colab-%E5%9C%A8%E7%BA%BF%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简介Google Colab是一个可以在线编译python的平台，用户程序运行在虚拟环境，并且提供一块GPU（Tesla K80）使用。但是一个页面只能运行12个小时，超过后会重启虚拟环境，之前的程序之类的就都没了。而且这块GPU是共享的，可能是采用轮循的方式吧。一般是和云盘结合起来用，把数据放到云盘上，然后通过将云盘挂载到虚拟环境下，利用Colab在线运行。云盘的大小是15GB，给钱的话可以升级容量。 将Colab与谷歌云盘结合！第一步：授权访问123456789101112!apt-get install -y -qq software-properties-common python-software-properties module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; 第二步：挂载云盘将谷歌云盘看作是虚拟机中的一个硬盘挂载12!mkdir -p drive!google-drive-ocamlfuse drive 第三步：更换目录123import osos.chdir(&apos;drive&apos;)!ls Colab里面不能用cd更换目录，只能用上述方法。drive是我们将云盘挂载到Colab的盘进入到drive中就可以看到云盘中的文件啦！ 模型的断线保护因为这个12小时强制重启的操作，我们必须要时刻保存训练的中间过程，这样在我们下一次重新训练的时候可以接着上一次成果继续。 Keras中的ModelCheckpoint函数就可以实现在每个epoch训练完后保存模型12checkPoint = keras.callbacks.ModelCheckpoint( model_name, monitor='val_loss', verbose=0, save_best_only=True, mode='auto', period=1) 具体的参数解释可以去看文档这里的保存是model.save() 这样下一次重新训练的时候只要加载上一次训练好的模型就可以啦！ 参考文献：官方新手教程参考文章：云盘挂载参考文章：断线保护]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Google Colab</tag>
        <tag>深度学习</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法]]></title>
    <url>%2F2019%2F02%2F12%2F%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简单句 -&gt; 复合句 -&gt; 简化复合句目的：用更少的词的表达出更多的意思 简单句五种基本句型五种基本句型的的划分是根据不同动词的特性。 句型 备注 S + V John died. 不及物动词 S + V + O John killed three enemy soldiers. 及物动词 S + V + C Shaun is a doctor. Shaun is smart. 动词为”是”，即连缀动词(Linking Verb) S + V + O + C I find the dress pretty. 补语用来描述宾语,省略了宾语与补语之间的连缀动词 S + V + O + O Shaun gave me a dog. dog并不是用来描述me的 S：主语， V：动词， O：宾语， C：补语 补语： 并不是修饰词，而是一种不可缺少的成分。 John died in World War Two. 最后的介词短语是用来修饰的，是可有可无的，它并不是补语补语一般用在连缀动词之后，因为连缀动词本身并无意义，因此补语是对主语的描述。补语可以是名词，也可以是形容词。 连缀动词look, seem, appear, sound, feel, taste, trun, prove, become, make等等 动词时态简单式完成式过去式： did现在式： do/does未来式： will do过去式： had done现在式： have/has done未来式： will have done 区别在于：有没有刻意强调”完成“的状态 不定词短语不定词是助动词的变化不定词： 不一定是什么词类，可以当名词，形容词，副词使用。 不定词做名词时，常常带有will，can，或不确定的意味。比如 I like to be the first. (can)They plan to marry next month. (will)He seems to be right. (推测) 对于本身带有否定意味的动词，后面常常用动名词。 I avoid making the same mistake twice. 动名词动名词相对于普通名词，保留着”动作”的意味，而且有”持续性”的暗示。 Drinking is his only vice. Idon't likeJohn's calling my girlfriend day after day. Being invited hereisa great honor. 分词作形容词 现在分词：有一种”正在”的暗示 A barking dog doesn’t bite. 过去分词：用一种”被动”（及物动词）或”已经”（不及物动词）的感觉 Boiled water is safe to drink. (被动)It is gone. (已经) 从句简化 Toys made in China are much better now.Toys which are made in China are much better now. 因为从句的主语Which和Toys重复，动词是无意义的be动词，因此可以省略。 Wounded in war,the soldier was sent home.After he was wounded in war …. 简化的原因同上。 Having finished the day’s work, the secretary went home.She had finished the day’s work… 形容词比较级变化对于单音节词，适合在词尾进行变化 tall -&gt; taller -&gt; tallesr 对于三音节及以上的词，如果再在词尾进行变化则不好发音，因此分成两个词来处理 expensive -&gt; more expensive -&gt; most expensive 对于两个音节的词，有以下原则可供参考：如果词尾是典型的形容词词尾，应用两个词处理crowdedlovinghelpfuluselessfamousactive 其余的变化没有限制 often -&gt; oftener(more often) -&gt; oftenest(most often) 最高级要加定冠词？冠词应该是跟着名词走，出现在名词短语中的形容词，才有可能需要定冠词。 Yangmingshan is most crowded in March.Yangmingshan is the most crowded of Taibei’s scenic spots. as…as John is not quite as good a student as his sister. 为什么是 as good a student 呢？因为as后面是形容词或副词，而如果是a good student就是名词了good-student呢？ 这是复合名词作形容词，但是good是形容词，这么用是不对的。 副词形容词用来修饰名词，而副词可以修饰任何词。 修饰名词： Vegetables,especially spinach, are good for you. 修饰动词： He kept quiet resolutely. 修饰形容词： You’re utterly insane! 修饰副词： I know your father rather well. 修饰句子： Therefore, the file is less than perfect. 位置：离要修饰的词越近越好，一般是放在修饰词后面，但是有时候为了突出主谓宾补这种主要元素，副词会往后挪。当离得太远的时候可以将副词放到修饰词的前面。 条件语气助动词的出现，使得句子产生不确定语气，成为条件语气。助动词can/could,will/would,may/might拼法的变化并不表示时态，而是表示语气的变化。因此在表示对过去的猜测时，应该使用完成式。 It may rain any minute now.It may have rained a little last night. 虚拟语气需要从“真假”和“时间”两个角度去判断。 现在时间过去时间未来世界往后推一个时间，变成过去式 If I were you, I wouldn’t do it. (虚拟语气中，be动词都用were)过去式 -&gt; 过去完成式 If I had known earlier, I might have done something. If an asteroid should hit hte earth, man could die out.]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA基础]]></title>
    <url>%2F2019%2F02%2F11%2FJAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第一个JAVA程序12345public class FirstSample&#123; public static void main(String[] args)&#123; System.out.println("Fuk the world!"); &#125;&#125; public: 访问修饰符 访问修饰符PublicPrivateProtected对于类： 类外可用对于方法： 类外可用对于变量： 类外可用对于类： 类内可用. 一般用于内部类，即这个类创建在一个类的内部，且不希望被外部访问。对于方法： 类内可用对于变量： 类内可用. 建议所有的变量都设置为private对于类： 类内和子类可用对于方法： 类内和子类可用对于变量： 类内和子类可用 class: 类定义的关键字。 JAVA中，一切都是对象，所有的代码都必须在某个类中。 源代码的文件名必须与公共类的名字相同，并用.java作为扩展名因此上述代码的文件名必须为FirstSample.java 运行命令javac FirstSample进行编译，编译后会生成相应的.class文件这时候运行命令java FirstSample即可运行 main： 每个类都可以有一个$main$函数，当我们按上述方式运行时，JAVA虚拟机将从指定类中的$main$方法开始执行。 Static静态变量：类的多个实体之间共同拥有的属性。静态方法：修改静态变量的唯一途径，不需要通过实体即可调用。 非静态的方法，都需要通过实体来调用1System.out.println("Fuk the world!"); $System$是一个类，$out$是一个实体，$println$是类的方法 注释：自动生成文档以/**开始，以*/结束 1234567891011/** * @author 标识一个类的作者 * @version 指定类的版本 * @param 方法的参数 * @return 返回值描述 * @exception 可能抛出的异常 * @throws 同上 * @see 参考 * @since 用于标识编译该文件所需要的JDK环境 * @deprecated 指名一个过期的类，成员或方法 */ 数据类型在JAVA中，一共有8种数据类型，除此之外全是对象。 类型 字节数 备注 int 4 short 2 long 8 byte 1 float 4 有效位数在6～7位。通常以后缀加F或f表示 double 8 有效位数15位。浮点数默认类型 char 2 Unicode。 避免使用char。 小心\u,即使是注释中的 boolean 单独使用占4个字节，数组的话是1个字节 三种特殊的浮点数值正无穷大：正整数除以0的结果负无穷大：正无穷大取负NaN：0/0或负数的平方根 常量Double.POSITIVE_INFINITY,Double.NEGATIVE_INFINITY和Double.NaN来分别表示这三个特殊的值 判断方法：12if(x == Double.NaN) // not ok! is never true.if(Double.isNaN(x)) // right! boolean类型: 整数值和布尔值之间不能进行相互转化。 常量： 用$final$ 表示常量，只能被赋值一次。 字符串$String$ 属于不可变字符串。 判断字符串相等：1s.equals(t);]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next 主题配置]]></title>
    <url>%2F2019%2F01%2F26%2FNext-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https://donlex.cn/archives/55e73569.html 修改标签效果修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 网站底部字数统计安装$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>工作环境配置</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VPS上配置SS]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%9C%A8VPS%E4%B8%8A%E9%85%8D%E7%BD%AESS%2F</url>
    <content type="text"><![CDATA[购买VPS在Vultr这个网站上购买相应的VPS，我的选择是ubuntu18.04， 3.5美元每月。 SSH连接购买完成后，会给你服务器的IP，用户名和密码。 对于Linux或Mac用户，可以直接在终端用ssh连接服务器 ssh root@服务器的IP地址 之后输入服务器的密码就可以啦 对于Windows用户，可以下载Xshell，从而实现远程控制。 端口号默认是22 （可以改 配置SS服务器端远程连接的目的就是为了配置SS，方法有很多种。 这个方法出自：链接 git clone https://github.com/Flyzy2005/ss-fly ss-fly/ss-fly.sh -i 密码 端口 指定服务器端的密码和端口号 客户端ubuntu下：链接 sudo pip install shadowsocks 然后创建一个.json文件，里面放一些配置信息，这样就不用每次输命令了。 123456789&#123; "server":"1.1.1.1", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"your passwd", "timeout":300, "method":"aes-256-cfb"&#125; 运行命令： sslocal -c /home/Desktop/ss.json 还可以设置开机启动：1234# 打开图形化开机启动项管理界面gnome-session-properties# 添加(Add) -&gt; 名称(name)和描述(comment)随便填，命令(Command)填写如下： sslocal -c /etc/ss.json 配置代理：全局模式： 在 系统-&gt;网络 中设置手动代理，将ip地址和端口设置为127.0.0.1 和 之前设置的端口号。 PAC模式： 我们选择在本地生成.pac文件 sudo pip install genpac genpac –proxy=”SOCKS5 127.0.0.1:9696” –gfwlist-proxy=”SOCKS5 127.0.0.1:9696” -o autoproxy.pac –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; 然后在 系统-&gt;网络 中设置自动代理，URL填写生成的.pac文件的路径即可 Windows 下： 下载相应的SS客户端即可。 IOS 下： 去app商店里，找一个可以进行ss连接的软件即可。]]></content>
      <categories>
        <category>工作环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[增量最小生成树]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%A2%9E%E9%87%8F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义每次加入一个新边后，最小生成树的权值是多少？ 解法维护当前的MST的边集，对于新加的一条边，重新计算MST，然后将多余的那条边删掉。 这样每次计算MST的复杂度就是$O(nlogn)$ （手动排序的话就是$O(n)$，因为只有新加的那条边是无序的） 假如一共要加$m$条边，那么时间复杂度为$O(mnlogn)$ 例题题意就是上述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// LightOJ 1123// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 205;int par[maxn];vector&lt;int&gt; G[maxn];struct Edge &#123; int u, v, w; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;Edge&gt; edges;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;inline bool merge(int x, int y) &#123; x = find(x); y = find(y); if (x == y) return false; par[x] = y; return true;&#125;int kruskal(vector&lt;Edge&gt; &amp;tmp, int n) &#123; int ret = 0; for (int i = 0; i &lt;= n; i++) par[i] = i; sort(tmp.begin(), tmp.end()); int pos = -1; for (int i = 0; i &lt; tmp.size(); i++) &#123; Edge &amp;e = tmp[i]; if (merge(e.u, e.v)) ret += e.w; else pos = i; &#125; if (pos != -1) tmp.erase(tmp.begin() + pos); if (tmp.size() == n - 1) return ret; else return -1;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 0; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); edges.clear(); printf("Case %d:\n", ++kase); for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edges.push_back(&#123;u, v, w&#125;); printf("%d\n", kruskal(edges, n)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM/ICPC</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GYM101667E]]></title>
    <url>%2F2018%2F10%2F18%2FGYM101667E%2F</url>
    <content type="text"><![CDATA[题目链接 题目一张无向图$G$，定义$H(e)$为如果$e$这条边属于$G$的最小生成树，那么最少要在原图上删除边的数量。 求$G$中所有边的$H(e)$和 $1 \leq n \leq 100, 1 \leq m \leq 500$ 分析如何计算$H(e)$呢？ 首先的想法是枚举边，假设当前边已经在最小生成树上了，然后再重新跑一边最小生成树的算法，计算要删的边的个数。当然这么做是有问题的，因为 考虑将所有权值小于$e$的重新构图。 对于$e$的两个端点跑一个最小割，割边的数量就是$H(e)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 105;struct Edge &#123; int from, to, cap, flow;&#125;;struct EdmonsKarp &#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int a[maxn], p[maxn]; void init(int n) &#123; for (int i = 0; i &lt;= n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.push_back(&#123;from, to, cap, 0&#125;); edges.push_back(&#123;to, from, cap, 0&#125;); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int MaxFlow(int s, int t) &#123; int flow = 0; for (;;) &#123; memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (auto &amp;id : G[x]) &#123; Edge &amp;e = edges[id]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; p[e.to] = id; a[e.to] = min(a[x], e.cap - e.flow); Q.push(e.to); &#125; &#125; if (a[t]) break; &#125; if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) &#123; edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;;EdmonsKarp wss;struct _Edge &#123; int u, v, w; bool operator&lt;(const _Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;_Edge&gt; edges;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v, w; i &lt; m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); edges.push_back(&#123;u, v, w&#125;); &#125; sort(edges.begin(), edges.end()); int ans = 0; for (auto &amp;e : edges) &#123; wss.init(n); for (auto &amp;tmp : edges) &#123; if (tmp.w &gt;= e.w) break; wss.AddEdge(tmp.u, tmp.v, 1); &#125; ans += wss.MaxFlow(e.u, e.v); &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3925]]></title>
    <url>%2F2018%2F10%2F17%2Fbzoj3925%2F</url>
    <content type="text"><![CDATA[题意给定一个n点m边的无向图，没有重边和自环，每条边的权值为[0,1]之间的随机变量。设S是使n个点连通的一个边集，求S中最大边的期望权值。 $n \leq 10, m \leq \frac{n(n-1)}{2}$ 分析结论：对于$n$个$[0,1]$之间的随机变量$x_1,x_2,…,x_n$，第$k$小的那个的期望值是$\frac{k}{(n+1)}$。 证明稍后给出。 大致思路： 我们需要算的其实是：恰好选择k条边 使得图连通 恰好： 选k-1条边时不连通，选了第k条才连通。 那如何算呢？ 设$con[S][i]$表示在集合$S$中选$i$条边，使得$S$连通的方案数。（不一定是恰好选$i$边连通） $disc[S][i]$表示在集合$S$中选$i$条边，使得$S$不连通的方案数。 $edges[S]$表示集合$S$中的边数。 那么有关系：$con[S][i] + disc[S][i] = C(edges[S], i)$ 重点来了： 如何计算恰好选$i$条边时连通呢？ $$ans[S][i] = con[S][i] - con[S][i-1]$$ 那么$ans[S][i]$ 就是在集合$S$中选$i$条边，使得$S$恰好连通的方案数. 那么最终的答案就是 $$\sum \frac{ans[S][i]}{C(edges[S], i)} \times \frac{i}{m+1} $$ 如何计算$con[S][i]$ ? $con[S][i] = C(edges[S], i) - disc[S][i]$ 如何计算$disc[S][i]$ ? 我们可以在集合$S$中找一个标志点$p$，那么$S$就可以分为两部分：一部分是包含$p$的集合$A$，另一部分是不包含$p$的集合$B$。 我们设包含$p$的集合是连通的，而另一个结合是无所谓的。 那么$$disc[S][j + k] = \sum con[A][j] \times C(edges[B], k)$$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 1 &lt;&lt; 11;const int maxm = 46;ll con[maxn][maxm], disc[maxn][maxm], edges[maxn], C[maxm][maxm];int G[15][15];void init() &#123; C[0][0] = 1; for (int i = 1; i &lt; maxm; i++) &#123; C[i][0] = C[i][i] = 1; for (int j = 1; j &lt; i; j++) C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("2.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); init(); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v; i &lt; m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); --u, --v; G[u][v] = G[v][u] = 1; &#125; int S = 1 &lt;&lt; n; for (int i = 0; i &lt; S; i++) for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j)) for (int k = j + 1; k &lt; n; k++) if (i &amp; (1 &lt;&lt; k)) edges[i] += G[j][k]; for (int i = 1, s; i &lt; S; i++) &#123; if (__builtin_popcount(i) == 1) &#123; // 集合里只有一个点 con[i][0] = 1; continue; &#125; s = i &amp; (-i); for (int sub = i &amp; (i - 1); sub; sub = (sub - 1) &amp; i) if (sub &amp; s) for (int j = 0; j &lt;= edges[sub]; j++) for (int k = 0; k &lt;= edges[i ^ sub]; k++) disc[i][j + k] += con[sub][j] * C[edges[i ^ sub]][k]; for (int j = 0; j &lt;= edges[i]; j++) con[i][j] = C[edges[i]][j] - disc[i][j]; &#125; double ans = 0; for (int i = 1; i &lt;= m; i++) ans += 1.0 * con[S - 1][i] / C[edges[S - 1]][i]; ans /= (m + 1); ans = 1.0 * con[S - 1][m] / C[edges[S - 1]][m] - ans; printf("%.6lf\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>子集dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[子集dp]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%AD%90%E9%9B%86dp%2F</url>
    <content type="text"><![CDATA[子集枚举对全集$S$的每个子集$K$,进行子集的枚举 复杂度:$O(3^n)$ 1234567for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; for (int j = i; j; j = (j - 1) &amp; i) &#123; /* j为i的子集 */ &#125;&#125; 证明： 设全集有$n$个元素。 对于一个含有$k$个元素的集合来说，它的方案有$C^k_n$。每个集合的子集有$2^k$ 所以对所有含有$k$个元素的集合，它的总子集数为$C^k_n \times 2^k$ 那么对全集的每个子集进行子集枚举的复杂度为$\sum_{k=1}^{n} C^k_n \times 2^k$ 由二项式定理$(x+y)^n = \sum_{k=0}^{n} C_n^{k} x ^ k y ^ {n-k}$ 所以子集枚举的复杂度为$(2+1)^n = 3^n$ 复杂度:$O(n2^n)$ 123456789for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; (1 &lt;&lt; n); j++) &#123; if (j &amp; (1 &lt;&lt; i)) &#123; /* j ^ (1 &lt;&lt; i) 为 j 的子集 */ &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>子集dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj2560]]></title>
    <url>%2F2018%2F10%2F16%2Fbzoj2560%2F</url>
    <content type="text"><![CDATA[题意n个不同的点，标号(1~n)，$c[i][j]$:表示$i$与$j$两点之间的不同的边数。 现在问有多少种连边方案可以使得n个点连通？ 答案模$1e^9+7$ 两点之间最多连一条边。 $n \leq 20$ 分析即求无向连通图的个数 大致思路： 设$S$表示一些点的集合，$all[S]$表示当前集合内所有连边的可能性。$dp[S]$表示当前集合内的所有点是一个联通块的连边方案数。 那么用$all[S]$减去$S$中不连通的情况就是$dp[S]$。 那么怎么求$S$中不连通的情况数呢？ 为了防止重复，我们规定$S$中的某个点为标志点，那么剩下的点可以分为两部分：一部分和标志点连通记为$A$，另一部分和标志点不连通记为$B$。 那么$dp[S] = all[S] - dp[A] * all[B]$ 即与标志位连通的集合的方案数和与标志不连通的集合的所有可能情况。 复杂度:$O(3^n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double PI = acos(-1.0);const int maxn = 1 &lt;&lt; 21;const int mod = 1e9 + 7;ll a[20][20], all[maxn], dp[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;a[i][j]); for (int i = 1; i &lt; (1 &lt;&lt; n); i++) &#123; all[i] = 1; for (int j = 0; j &lt; n; j++) if (i &amp; (1 &lt;&lt; j)) for (int k = j + 1; k &lt; n; k++) if (i &amp; (1 &lt;&lt; k)) all[i] = all[i] * (a[j][k] + 1) % mod; int s; // 标志点 for (int j = n - 1; j &gt;= 0; j--) if (i &amp; (1 &lt;&lt; j)) &#123; s = j; break; &#125; dp[i] = all[i]; s = i ^ (1 &lt;&lt; s); // 不包含标志点的集合 for (int j = s; j; j = (j - 1) &amp; s) &#123; // 子集枚举 dp[i] = (dp[i] - all[j] * dp[i ^ j] % mod + mod) % mod; &#125; &#125; printf("%lld\n", dp[(1 &lt;&lt; n) - 1]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>子集dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown & Latex 公式]]></title>
    <url>%2F2018%2F10%2F02%2FMarkdown-Latex-%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[大括号$$f(x) = \begin{cases} x_1 = x_{1,0} + \frac{a_2}{(a_1,a_2)}\times t\\ {x_2 = x_{2,0} - \frac{a_1}{(a_1,a_2)}\times t} \end{cases}$$ 1234$$f(x) = \begin&#123;cases&#125; x_1 = x_&#123;1,0&#125; + \frac&#123;a_2&#125;&#123;(a_1,a_2)&#125;\times t\\\\ &#123;x_2 = x_&#123;2,0&#125; - \frac&#123;a_1&#125;&#123;(a_1,a_2)&#125;\times t&#125; \end&#123;cases&#125;$$ 公式推导$$\begin{aligned}a &amp;= b \\&amp;= c\end{aligned}$$ 1234$$\begin&#123;aligned&#125;a &amp;= b \\\\&amp;= c\end&#123;aligned&#125;$$ 其中 &amp; 为对齐位置的标记。 颜色$\color{black}{Hello World!}$$\color{gray}{Hello World!}$$\color{silver}{Hello World!}$$\color{white}{Hello World!}$$\color{maroon}{Hello World!}$$\color{red}{Hello World!}$$\color{yellow}{Hello World!}$$\color{lime}{Hello World!}$$\color{olive}{Hello World!}$$\color{green}{Hello World!}$$\color{teal}{Hello World!}$$\color{aqua}{Hello World!}$$\color{blue}{Hello World!}$$\color{navy}{Hello World!}$$\color{purple}{Hello World!}$$\color{fuchsia}{Hello World!}$12345678910111213141516$\color&#123;black&#125;&#123;Hello World!&#125;$ $\color&#123;gray&#125;&#123;Hello World!&#125;$ $\color&#123;silver&#125;&#123;Hello World!&#125;$ $\color&#123;white&#125;&#123;Hello World!&#125;$ $\color&#123;maroon&#125;&#123;Hello World!&#125;$ $\color&#123;red&#125;&#123;Hello World!&#125;$ $\color&#123;yellow&#125;&#123;Hello World!&#125;$ $\color&#123;lime&#125;&#123;Hello World!&#125;$ $\color&#123;olive&#125;&#123;Hello World!&#125;$ $\color&#123;green&#125;&#123;Hello World!&#125;$ $\color&#123;teal&#125;&#123;Hello World!&#125;$ $\color&#123;aqua&#125;&#123;Hello World!&#125;$ $\color&#123;blue&#125;&#123;Hello World!&#125;$ $\color&#123;navy&#125;&#123;Hello World!&#125;$ $\color&#123;purple&#125;&#123;Hello World!&#125;$ $\color&#123;fuchsia&#125;&#123;Hello World!&#125;$ 矩阵$$ \left[ \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right] \tag{3}$$ 123456789$$ \left[ \begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \end&#123;matrix&#125; \right] \tag&#123;3&#125;$$ $$ \left| \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right| \tag{3}$$$$ \left( \begin{matrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end{matrix} \right) \tag{3}$$]]></content>
      <categories>
        <category>Markdown &amp; Latex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态开点线段树]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思想动态开点线段树与主席树有一点区别。 如果想开n个线段树，每个线段树彼此独立，那么用动态开点线段树就行。 相同点： 每次只更新一条链。 不同点： 主席树每次更新的时候是从原来树的基础上“牵”出一条新的链， 相当于建了一棵新树。 动态开点线段树并不会保留原来树的信息， 而是在“完善”当前这颗树。例题 题目CF1046A; 有N个机器人，每个机器人有一个位置x, 一个视线半径r, 一个智商值q。 现在询问有多少对机器人可以相互看见，并且智商差的绝对值小于等于K $1 \leq N \leq 1e5, 1 \leq k \leq 20$ 分析如何解决相互可以看见的问题： 将机器人按半径排序，用线段树维护每个机器人的位置。 依次插入机器人，查询其视线范围机器人的数量。 因为是半径大的先插，所以后插的能看见之前插的，那么之前插的也一定能看见后插的。 解决智商差的问题： 因为 $k$ 只有 $20$， 设当前机器人智商为 $q$， 那么我们只要暴力查 [q - k, q + k] 智商内的，并且再其视线范围内的即可。 但是我们不能对每个智商都去开一个线段树，所以我们可以选择动态开点或者主席树。 （主席树差一点点就T了） （突然发现并不需要对x坐标进行离散化，当然肯定不能去build） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int maxm = maxn * 40;struct Node &#123; int x, r, q; bool operator&lt;(const Node &amp;A) const &#123; return r &gt; A.r; &#125;&#125;;Node a[maxn];map&lt;int, int&gt; Hashq;ll sum[maxm];int lch[maxm], rch[maxm], root[maxn];int dfn;void update(int &amp;k, int l, int r, int p, int x) &#123; if (!k) k = ++dfn; sum[k] += x; if (l == r) return; int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update(lch[k], l, mid, p, x); if (mid + 1 &lt;= p) update(rch[k], mid + 1, r, p, x);&#125;ll query(int k, int l, int r, int L, int R) &#123; if (!k) return 0; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k]; int mid = l + r &gt;&gt; 1; ll ret = 0; if (L &lt;= mid) ret += query(lch[k], l, mid, L, R); if (mid + 1 &lt;= R) ret += query(rch[k], mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int Max = 1e9 + 1; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf("%d%d%d", &amp;a[i].x, &amp;a[i].r, &amp;a[i].q); sort(a, a + n); // r dfn = 0; int tot = 1; ll ans = 0; for (int i = 0; i &lt; n; i++) &#123; int base = max(0, a[i].q - m); int top = a[i].q + m; int l = max(0, a[i].x - a[i].r); int r = min(a[i].x + a[i].r, Max); for (int j = base; j &lt;= top; j++) &#123; if (Hashq.find(j) == Hashq.end()) continue; ans += query(root[Hashq[j]], 0, Max, l, r); &#125; if (Hashq[a[i].q] == 0) Hashq[a[i].q] = tot++; update(root[Hashq[a[i].q]], 0, Max, a[i].x, 1); &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[珂朵莉树-ODT]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91-ODT%2F</url>
    <content type="text"><![CDATA[原文链接 珂朵莉树 ： Old Driver Tree. ODT 是一种基于随机数据的暴力数据结构 主要是应用于维护区间信息。 通过不断地分裂与合并，可证明其均摊复杂度是$log$的 可以解决区间赋值，区间查询等问题。 当然前提是数据随机。 注意 不能随意删除添加区间， 因为odt必须保证所有区间内所有元素都在集合中。 题目cf896C 操作： 区间赋值 区间加 区间第k大 区间幂和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;int a[maxn];int n, m, seed, vmax;ll Pow(ll a, ll b, int p) &#123; ll ret = 1; a %= p; // !!! while (b) &#123; if (b &amp; 1) ret = ret * a % p; a = a * a % p; b &gt;&gt;= 1; &#125; return ret;&#125;inline int rnd() &#123; ll ret = seed; seed = ((seed * 7LL) + 13) % mod; return ret;&#125;struct Node &#123; int l, r; mutable ll val; Node(int l = 0, int r = 0, ll val = 0) : l(l), r(r), val(val) &#123;&#125; bool operator&lt;(const Node&amp; A) const &#123; return l &lt; A.l; &#125;&#125;;set&lt;Node&gt; odt;set&lt;Node&gt;::iterator split(int pos) &#123; auto it = odt.lower_bound(Node(pos)); if (it != odt.end() &amp;&amp; it-&gt;l == pos) return it; --it; int L = it-&gt;l, R = it-&gt;r; ll v = it-&gt;val; odt.erase(it); odt.insert(Node(L, pos - 1, v)); return odt.insert(Node(pos, R, v)).first;&#125;void assign(int l, int r, int val) &#123; auto itl = split(l), itr = split(r + 1); odt.erase(itl, itr); odt.insert(Node(l, r, val));&#125;void add(int l, int r, int val) &#123; auto itl = split(l), itr = split(r + 1); for (; itl != itr; itl++) itl-&gt;val += val;&#125;ll Rank(int l, int r, int k) &#123; vector&lt;pair&lt;ll, int&gt;&gt; vp; auto itl = split(l), itr = split(r + 1); vp.clear(); for (; itl != itr; itl++) vp.push_back(mp(itl-&gt;val, itl-&gt;r - itl-&gt;l + 1)); sort(vp.begin(), vp.end()); for (auto&amp; it : vp) &#123; k -= it.second; if (k &lt;= 0) return it.first; &#125;&#125;ll sum(int l, int r, int x, int p) &#123; auto itl = split(l), itr = split(r + 1); ll ret = 0; for (; itl != itr; itl++) ret = (ret + 1LL * (itl-&gt;r - itl-&gt;l + 1) * Pow(itl-&gt;val, x, p) % p) % p; return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d%d%d", &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i = 1; i &lt;= n; i++) &#123; a[i] = (rnd() % vmax) + 1; odt.insert(Node(i, i, a[i])); &#125; odt.insert(Node(n + 1, n + 1, 0)); for (int i = 1, op, l, r, x, y; i &lt;= m; i++) &#123; op = (rnd() % 4) + 1; l = (rnd() % n) + 1; r = (rnd() % n) + 1; if (l &gt; r) swap(l, r); if (op == 3) x = (rnd() % (r - l + 1)) + 1; else x = (rnd() % vmax) + 1; if (op == 4) y = (rnd() % vmax) + 1; // --- if (op == 1) add(l, r, x); else if (op == 2) assign(l, r, x); else if (op == 3) printf("%lld\n", Rank(l, r, x)); else printf("%lld\n", sum(l, r, x, y)); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>珂朵莉树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU5726-GCD]]></title>
    <url>%2F2018%2F09%2F19%2FHDU5726-GCD%2F</url>
    <content type="text"><![CDATA[题意给一个长度为$N$的序列，每次查询整个序列有多少子段的gcd与$[l,r]$的gcd相同？ $1 \leq N \leq 1e5, 1 \leq a_i \leq 1e9$ 分析区间GCD可以由线段树或者ST表来维护。 整个序列的GCD可以预处理出来， 因为GCD不会很多…. $dp[i]$ 表示到第i个位置并以第i个位置结尾的gcd集合 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];int seg[maxn &lt;&lt; 2];inline void pushup(int rt) &#123; seg[rt] = __gcd(seg[lson], seg[rson]); &#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return seg[rt]; int ret = 0; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) ret = __gcd(ret, query(lson, l, mid, L, R)); if (R &gt;= mid + 1) ret = __gcd(ret, query(rson, mid + 1, r, L, R)); return ret;&#125;map&lt;int, ll&gt; dp[maxn]; // 到i 所组成的gcd的集合和数量int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 0; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), dp[i].clear(); build(1, 1, n); //--- map&lt;int, ll&gt; cnt; for (int i = 1; i &lt;= n; i++) &#123; cnt[a[i]]++; dp[i][a[i]]++; for (auto &amp;v : dp[i - 1]) &#123; int gcd = __gcd(a[i], v.first); cnt[gcd] += v.second; dp[i][gcd] += v.second; &#125; &#125; //--- scanf("%d", &amp;m); int l, r; printf("Case #%d:\n", ++kase); while (m--) &#123; scanf("%d%d", &amp;l, &amp;r); int gcd = query(1, 1, n, l, r); printf("%d %lld\n", gcd, cnt[gcd]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZOJ4053-Couleur权值主席树+启发式合并]]></title>
    <url>%2F2018%2F09%2F18%2FZOJ4053-Couleur%E6%9D%83%E5%80%BC%E4%B8%BB%E5%B8%AD%E6%A0%91-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题意给一段长度为N的排列$a_i$, 每次删除一个元素（一整段会分为两段），询问所有段中逆序对最多的数量。一直删除到没有元素为止。要求强制在线。 $1 \leq n \leq 1e5, 1 \leq a_i \leq n$ 分析考虑如何维护分裂之后得到的两个新段的逆序对的数量。 假设原始段是$A$，分裂之后的段是$a_1,a_2(a_1 \leq a_2)$ 假设$A$中逆序对的数量是已知的，如果知道$a_1,a_2$其中一段的数量，能否推算出另一段的数量？ $$|a2| = |A| - |a_1| - W$$ 其中$W$是逆序对中的元素分别在两个段的数量。 这个可以通过一个权值主席树来计算。 所以我们只要暴力算出$a_1$中的逆序对数量即可。 复杂度$O(n(logn)^2)$ $pre[i]$: 表示前i个元素的逆序对的个数。 暴力算的时候不要重新建树,利用$pre$和之前建好的权值主席树即可。（否则会爆内存） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;ll a[maxn], p[maxn], pre[maxn];struct SEG &#123; int l, r; ll cnt; bool operator&lt;(const SEG &amp;A) const &#123; return r &lt; A.r; &#125;&#125;;set&lt;SEG&gt; seg; // 当前所有的段multiset&lt;ll&gt; val; // 当前所有段的逆序对的数量ll sum[maxn * 30];int root[maxn * 30];int lch[maxn * 30], rch[maxn * 30];int n, dfn;inline void pushup(int k) &#123; sum[k] = sum[lch[k]] + sum[rch[k]]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; if (l == r) &#123; sum[k] = 0; return; &#125; int mid = l + r &gt;&gt; 1; build(lch[k], l, mid); build(rch[k], mid + 1, r); pushup(k);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old];&#125;void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++dfn; newnode(old, k); if (l == r) &#123; sum[k] += x; return; &#125; int mid = l + r &gt;&gt; 1; if (p &lt;= mid) update(lch[old], lch[k], l, mid, p, x); if (p &gt;= mid + 1) update(rch[old], rch[k], mid + 1, r, p, x); pushup(k);&#125;ll query(int k, int l, int r, int L, int R) &#123; if (L &gt; R) return 0; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k]; int mid = l + r &gt;&gt; 1; ll ret = 0; if (L &lt;= mid) ret += query(lch[k], l, mid, L, R); if (R &gt;= mid + 1) ret += query(rch[k], mid + 1, r, L, R); return ret;&#125;void work(int l, int k, int r, ll fa_cnt) &#123; if (l == r) return; else if (r - l == 1) &#123; val.insert(0); if (l == k) &#123; seg.insert(&#123;k + 1, r, 0&#125;); val.insert(0); &#125; else &#123; seg.insert(&#123;l, k - 1, 0&#125;); val.insert(0); &#125; &#125; else &#123; if (l == k) &#123; ll cnt = fa_cnt; cnt -= query(root[r], 1, n, 1, a[l] - 1) - query(root[l - 1], 1, n, 1, a[l] - 1); seg.insert(&#123;l + 1, r, cnt&#125;); val.insert(cnt); &#125; else if (r == k) &#123; ll cnt = fa_cnt; cnt -= query(root[r], 1, n, a[r] + 1, n) - query(root[l - 1], 1, n, a[r] + 1, n); seg.insert(&#123;l, r - 1, cnt&#125;); val.insert(cnt); &#125; else &#123; if (k - l &lt; r - k) &#123; ll cnt = pre[k - 1] - pre[l - 1]; for (int i = l; i &lt; k; i++) &#123; cnt -= query(root[l - 1], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;l, k - 1, cnt&#125;); val.insert(cnt); // --- cnt = fa_cnt - cnt; for (int i = l; i &lt;= k; i++) &#123; cnt -= query(root[r], 1, n, 1, a[i] - 1); cnt += query(root[k - 1], 1, n, 1, a[i] - 1); &#125; seg.insert(&#123;k + 1, r, cnt&#125;); val.insert(cnt); &#125; else &#123; ll cnt = pre[r] - pre[k]; for (int i = k + 1; i &lt;= r; i++) &#123; cnt -= query(root[k], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;k + 1, r, cnt&#125;); val.insert(cnt); // --- cnt = fa_cnt - cnt; for (int i = k; i &lt;= r; i++) &#123; cnt -= query(root[k], 1, n, a[i] + 1, n); cnt += query(root[l - 1], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;l, k - 1, cnt&#125;); val.insert(cnt); &#125; &#125; &#125;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lld", a + i); for (int i = 1; i &lt;= n; i++) scanf("%lld", p + i); ll cnt = 0; val.clear(); seg.clear(); //---- dfn = 0; build(root[0], 1, n); for (int i = 1; i &lt;= n; i++) &#123; update(root[i - 1], root[i], 1, n, a[i], 1); pre[i] = pre[i - 1] + query(root[i], 1, n, a[i] + 1, n); &#125; seg.insert(&#123;1, n, pre[n]&#125;); val.insert(pre[n]); //--- vector&lt;ll&gt; ans; ans.pb(pre[n]); for (int i = 1; i &lt; n; i++) &#123; ll k = p[i] ^ (ans.back()); auto it = seg.lower_bound(&#123;0, k, 0&#125;); // 找到要分裂的段 val.erase(val.find(it-&gt;cnt)); seg.erase(it); int l = it-&gt;l; int r = it-&gt;r; work(l, k, r, it-&gt;cnt); ans.push_back(*(val.rbegin())); &#125; for (int i = 0; i &lt; ans.size(); i++) &#123; if (i) printf(" %lld", ans[i]); else printf("%lld", ans[i]); &#125; puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线段树成长之路-LV.1]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-LV-1%2F</url>
    <content type="text"><![CDATA[染色相关区间内不同种类的颜色题意给定长度为$N$的序列， $M$次操作，每次可以修改一段区间的颜色，或者查询某段中的颜色的不同种类数。 颜色种类小于64 分析用位来记录当前段所有的颜色。 合并的时候直接用或操作即可。 相关例题 POJ2777 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int n, m, Q;const int maxn = 1e5 + 5;int seg[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2];void pushup(int rt) &#123; seg[rt] = seg[lson] | seg[rson]; &#125;void pushdown(int rt) &#123; if (lazy[rt] == -1) return; seg[lson] = seg[rson] = lazy[rson] = lazy[lson] = lazy[rt]; lazy[rt] = -1;&#125;void build(int rt, int l, int r) &#123; lazy[rt] = -1; if (l == r) &#123; seg[rt] = 1; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R, int c) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; lazy[rt] = seg[rt] = 1 &lt;&lt; (c - 1); return; &#125; pushdown(rt); int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R, c); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R, c); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (l &gt;= L &amp;&amp; r &lt;= R) &#123; return seg[rt]; &#125; pushdown(rt); int ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret |= query(lson, l, mid, L, R); if (mid + 1 &lt;= R) ret |= query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d%d", &amp;n, &amp;m, &amp;Q); char op[2]; build(1, 1, n); for (int i = 0, x, y, z; i &lt; Q; i++) &#123; scanf("%s", op); if (op[0] == 'C') &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (x &gt; y) swap(x, y); update(1, 1, n, x, y, z); &#125; else &#123; scanf("%d%d", &amp;x, &amp;y); if (x &gt; y) swap(x, y); int tmp = query(1, 1, n, x, y); int cnt = 0; for (int i = 0; i &lt; 31; i++) &#123; if (tmp &amp; (1 &lt;&lt; i)) cnt++; &#125; printf("%d\n", cnt); &#125; &#125;&#125; 区间内有多少”段”题意给定长度为$N$的序列， $M$次操作，每次可以修改一段区间的颜色，或者查询区间内有多少段？ 颜色种类数没有限制 分析线段树每个节点维护三个值，区间内段的数量，最左边的颜色，最右边的颜色。 合并的时候如果交点的颜色相同，则数量要减一 矩形面积相关矩形面积并分析将每个矩形的上下两条边取出来。 从下往上扫描。 遇到下边界，则将[l,r)区间覆盖 遇到上边界，则将[l,r)区间撤销 每次查询被覆盖区间的长度。 具体怎么维护呢？1234struct Node&#123; int cnt_cover; // 区间被覆盖次数 double length; // 区间覆盖长度&#125;; 所以如果 cnt_cover &gt; 0 , 则length = 区间长度 cnt_cover == 0 &amp;&amp; l == r, 则length = 0 不然的话 length = 左耳子的length + 右儿子的length 注意 因为维护的是线段，因此区间都是左闭右开的。 具体实现可以参照代码，不同的地方都有注释标记。 维护线段和维护点是不一样的。 假如你要维护[1,2,3] 你查询的时候应该查到2，但实际上你会查到1，[1,2] 和 [3,3], 所以是不一样的。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;map&lt;double, int&gt; Hash;map&lt;int, double&gt; rHash;struct line &#123; double l, r, h; int val; line(double l = 0, double r = 0, double h = 0, int val = 0) : l(l), r(r), h(h), val(val) &#123;&#125; bool operator&lt;(const line &amp;A) const &#123; return h &lt; A.h; &#125;&#125;;struct Node &#123; int cover; double len;&#125;;const int maxn = 1000;Node seg[maxn &lt;&lt; 2];void build(int rt, int l, int r) &#123; seg[rt].cover = seg[rt].len = 0; if (l == r) return; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r);&#125;void pushup(int rt, int l, int r) &#123; if (seg[rt].cover &gt; 0) seg[rt].len = rHash[r + 1] - rHash[l]; // [l,r) else if (l == r) seg[rt].len = 0; else seg[rt].len = seg[lson].len + seg[rson].len;&#125;void update(int rt, int l, int r, int L, int R, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].cover += val; pushup(rt, l, r); return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R, val); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R, val); pushup(rt, l, r);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, kase = 0; while (~scanf("%d", &amp;n)) &#123; if (!n) break; double x1, x2, y1, y2; vector&lt;line&gt; a; set&lt;double&gt; xval; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a.emplace_back(x1, x2, y1, 1); a.emplace_back(x1, x2, y2, -1); xval.insert(x1); xval.insert(x2); &#125; // 离散化 Hash.clear(); rHash.clear(); int cnt = 0; for (auto &amp;v : xval) &#123; Hash[v] = ++cnt; rHash[cnt] = v; &#125; sort(a.begin(), a.end()); build(1, 1, cnt); double ans = 0; for (int i = 0; i &lt; a.size() - 1; i++) &#123; update(1, 1, cnt, Hash[a[i].l], Hash[a[i].r] - 1, a[i].val); //[l,r) ans += (a[i + 1].h - a[i].h) * seg[1].len; &#125; printf("Test case #%d\n", ++kase); printf("Total explored area: %.2lf\n\n", ans); &#125;&#125; 矩形面积交分析维护两个值 $len1$ 表示覆盖次数大于0的区间长度 $len2$ 表示覆盖次数大于1的区间长度 那么$pushup$的时候就要分类讨论了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// ybmj// hdu 1255#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;map&lt;double, int&gt; Hash;map&lt;int, double&gt; rHash;struct Lines &#123; double l, r, h; int val; bool operator&lt;(const Lines &amp;A) const &#123; return h &lt; A.h; &#125;&#125;;struct Node &#123; int cnt; // 覆盖次数 double len1; // 覆盖次数大于0的长度 double len2; // 覆盖次数大于1的长度&#125;;Node seg[maxn &lt;&lt; 2];void build(int rt, int l, int r) &#123; seg[rt].cnt = seg[rt].len1 = seg[rt].len2 = 0; if (l == r) return; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r);&#125;inline void pushup(int rt, int l, int r) &#123; if (seg[rt].cnt &gt; 1) seg[rt].len1 = seg[rt].len2 = rHash[r + 1] - rHash[l]; else if (seg[rt].cnt == 1) &#123; seg[rt].len1 = rHash[r + 1] - rHash[l]; if (l == r) seg[rt].len2 = 0; else seg[rt].len2 = seg[lson].len1 + seg[rson].len1; &#125; else &#123; if (l == r) seg[rt].len1 = seg[rt].len2 = 0; else &#123; seg[rt].len1 = seg[lson].len1 + seg[rson].len1; seg[rt].len2 = seg[lson].len2 + seg[rson].len2; &#125; &#125;&#125;void update(int rt, int l, int r, int L, int R, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].cnt += val; pushup(rt, l, r); return; &#125; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) update(lson, l, mid, L, R, val); if (R &gt;= mid + 1) update(rson, mid + 1, r, L, R, val); pushup(rt, l, r);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); double x1, x2, y1, y2; vector&lt;Lines&gt; line; set&lt;double&gt; X; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y1, &amp;x2, &amp;y2); line.push_back(&#123;x1, x2, y1, 1&#125;); line.push_back(&#123;x1, x2, y2, -1&#125;); X.insert(x1); X.insert(x2); &#125; sort(line.begin(), line.end()); int cnt = 0; Hash.clear(); rHash.clear(); for (auto &amp;v : X) Hash[v] = ++cnt, rHash[cnt] = v; build(1, 1, cnt); double area = 0; for (int i = 0; i &lt; line.size() - 1; i++) &#123; update(1, 1, cnt, Hash[line[i].l], Hash[line[i].r] - 1, line[i].val); area += seg[1].len2 * (line[i + 1].h - line[i].h); &#125; printf("%.2lf\n", area); &#125;&#125; 区间更新的一些骚操作将区间元素都变成其根号题意 区间求和 将区间每个元素都变成其根号分析 因为一个数不断的取根号，很快就变成了1. 因此我们在区间更新的时候，只要这个区间的最大值小于等于1（因为有0），那么就去更新到叶。否则就不需要更新。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// ybmj// bzoj3211#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;struct Node &#123; ll sum; int Max;&#125;;Node seg[maxn &lt;&lt; 2];int a[maxn];inline void pushup(int rt) &#123; seg[rt].Max = max(seg[lson].Max, seg[rson].Max); seg[rt].sum = seg[lson].sum + seg[rson].sum;&#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt].Max = a[l]; seg[rt].sum = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R) &#123; if (seg[rt].Max &lt;= 1) return; if (l == r) &#123; seg[rt].Max = sqrt(seg[rt].Max); seg[rt].sum = sqrt(seg[rt].sum); return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) update(lson, l, mid, L, R); if (mid + 1 &lt;= R) update(rson, mid + 1, r, L, R); pushup(rt);&#125;ll query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].sum; &#125; ll ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret += query(lson, l, mid, L, R); if (mid + 1 &lt;= R) ret += query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); scanf("%d", &amp;m); build(1, 1, n); while (m--) &#123; int x, l, r; scanf("%d%d%d", &amp;x, &amp;l, &amp;r); if (x == 1) &#123; printf("%lld\n", query(1, 1, n, l, r)); &#125; else &#123; update(1, 1, n, l, r); &#125; &#125;&#125; 区间gcd，区间加题意 求区间的gcd 区间加val分析Gcd性质 12gcd(a,b) = gcd(a,b-a);gcd(a,b,c,d) = gcd(a,b-a,c-b,d-c) 维护一个a数组的差分序列，称作b 那么区间[l,r]加v， 实际上就等于$b[l] + v, b[r+1] - v$. 查询[l,r]的gcd，等于 $Gcd(a[l], Gcd(b[l+1] .. b[r]))$ 所以我们要维护原来的a数组，以及差分后的b数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// ybmj// CH 4302#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e5 + 5;ll seg[maxn &lt;&lt; 2];ll a[maxn], b[maxn];inline void pushup(int rt) &#123; seg[rt] = gcd(seg[lson], seg[rson]); &#125;void build(int rt, int l, int r) &#123; if (l == r) &#123; seg[rt] = b[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update_gcd(int rt, int l, int r, int pos, ll x) &#123; if (l == r) &#123; seg[rt] += x; return; &#125; int mid = l + r &gt;&gt; 1; if (mid &gt;= pos) update_gcd(lson, l, mid, pos, x); else update_gcd(rson, mid + 1, r, pos, x); pushup(rt);&#125;ll query_gcd(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return seg[rt]; ll ret = 0; int mid = l + r &gt;&gt; 1; if (mid &gt;= L) ret = __gcd(ret, query_gcd(lson, l, mid, L, R)); if (mid + 1 &lt;= R) ret = __gcd(ret, query_gcd(rson, mid + 1, r, L, R)); return ret;&#125;ll bit[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;ll query(int x) &#123; ll ret = 0; for (int i = x; i &gt; 0; i -= lowb(i)) ret += bit[i]; return ret;&#125;void update(int l, int r, ll val, int n) &#123; for (int i = l; i &lt;= n; i += lowb(i)) bit[i] += val; for (int i = r + 1; i &lt;= n; i += lowb(i)) bit[i] -= val;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%lld", a + i); for (int i = 1; i &lt;= n; i++) b[i] = a[i] - a[i - 1]; build(1, 1, n); char op[2]; int l, r; ll val; while (m--) &#123; scanf("%s", op); if (op[0] == 'Q') &#123; scanf("%d%d", &amp;l, &amp;r); if (l == r) printf("%lld\n", a[l] + query(l)); else printf("%lld\n", __gcd(a[l] + query(l), abs(query_gcd(1, 1, n, l + 1, r)))); &#125; else &#123; scanf("%d%d%lld", &amp;l, &amp;r, &amp;val); update_gcd(1, 1, n, l, val); if (r &lt; n) update_gcd(1, 1, n, r + 1, -val); update(l, r, val, n); &#125; &#125;&#125; 维护循环节题意You have $N$ integers $A_1,A_2,…,A_N$. You are asked to write a program to receive and execute two kinds of instructions: $C$ $a$ $b$ means performing $A_i=(A_i^2mod2018)$ for all Ai such that $a≤i≤b$. $Q$ $a$ $b$ means query the sum of $A_a,A_{a+1},…,A_b$. Note that the sum is not taken modulo 2018. $1 \leq n, Q \leq 50000$ 分析每个数模2018的最大周期是6. 所以更新6次之后一定进入循环节。 所以对于每个结点，我们要维护一个长度为6的循环节。 如果更新不足6次，则直接暴力更新到叶子结点。 更新到第6次，说明进入循环节，此时维护循环节即可。 需要注意的是在$pushup$的时候要更新 “次数”。 详见代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj// 2018 ACM/ICPC 上海大都会赛H题#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;const int mod = 2018;int a[maxn];int sum[maxn &lt;&lt; 2][6], p[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2], cnt[maxn &lt;&lt; 2];inline void pushup(int rt) &#123; cnt[rt] = min(cnt[lson], cnt[rson]); // 记得更新次数 if (cnt[rt] &lt; 5) &#123; sum[rt][0] = sum[lson][p[lson]] + sum[rson][p[rson]]; // 如果cnt[i] &lt; 5, 那么p[i] = 0 return; &#125; p[rt] = 0; for (int i = 0; i &lt; 6; i++) // 更新整个循环节 sum[rt][i] = sum[lson][(p[lson] + i) % 6] + sum[rson][(p[rson] + i) % 6];&#125;inline void pushdown(int rt) &#123; if (!lazy[rt]) return; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; (p[lson] += lazy[rt]) %= 6; (p[rson] += lazy[rt]) %= 6; lazy[rt] = 0;&#125;void build(int rt, int l, int r) &#123; p[rt] = lazy[rt] = cnt[rt] = 0; if (l == r) &#123; sum[rt][0] = a[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(lson, l, mid); build(rson, mid + 1, r); pushup(rt);&#125;void update(int rt, int l, int r, int L, int R) &#123; if (l == r) &#123; // 进循环节前暴力更新到叶子 cnt[rt]++; if (cnt[rt] &lt; 5) &#123; sum[rt][0] = sum[rt][0] * sum[rt][0] % mod; &#125; else if (cnt[rt] == 5) &#123; sum[rt][0] = sum[rt][0] * sum[rt][0] % mod; for (int i = 1; i &lt; 6; i++) sum[rt][i] = sum[rt][i - 1] * sum[rt][i - 1] % mod; &#125; else (++p[rt]) %= 6; return; &#125; if (L &lt;= l &amp;&amp; R &gt;= r &amp;&amp; cnt[rt] &gt;= 5) &#123; // 进入循环节后才可以直接返回 lazy[rt]++; (++p[rt]) %= 6; return; &#125; pushdown(rt); int mid = l + r &gt;&gt; 1; if (L &lt;= mid) update(lson, l, mid, L, R); if (R &gt;= mid + 1) update(rson, mid + 1, r, L, R); pushup(rt);&#125;int query(int rt, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[rt][p[rt]]; pushdown(rt); int ret = 0; int mid = l + r &gt;&gt; 1; if (L &lt;= mid) ret += query(lson, l, mid, L, R); if (R &gt;= mid + 1) ret += query(rson, mid + 1, r, L, R); return ret;&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); build(1, 1, n); int Q; scanf("%d", &amp;Q); char op[2]; int l, r; printf("Case #%d:\n", kase++); while (Q--) &#123; scanf("%s%d%d", op, &amp;l, &amp;r); if (op[0] == 'Q') printf("%d\n", query(1, 1, n, l, r)); else update(1, 1, n, l, r); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1176]]></title>
    <url>%2F2018%2F09%2F14%2Fbzoj1176%2F</url>
    <content type="text"><![CDATA[题意维护一个W*W的矩阵，初始值均为S.每次操作可以增加某格子的权值,或询问某子矩阵的总权值.修改操作数M&lt;=160000,询问数Q&lt;=10000,W&lt;=2000000. 分析维护矩阵和的基本思想还是不变的，即利用二维前缀和。 困难在于W过大，无法直接开数组。 考虑分治 设$solve(l,r)$ 为只考虑第l个到第r个操作/询问内，所有操作对询问的影响。 那么我们分治步骤即为 将数组按x坐标排序 计算solve(l,r) , 按坐标mid将数组分为两块 $solve(l,mid)$ 计算[l,mid]操作对[mid+1,r]的询问产生的影响 $solve(mid+1,r)$ 将数组还原成按x排序的 那么如何做步骤4呢？ 我们按照x坐标排序，用权值线段树或者权值树状数组来维护y方向的权值。 当然这么写常数比较大。 我们可以在分治之前先解决步骤4， 这样就不需要步骤6了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const int maxm = 2e6 + 5;struct P &#123; int op, x, y, val, id, qid; bool operator&lt;(const P&amp; A) const &#123; return x &lt; A.x; &#125;&#125;;P a[maxn &lt;&lt; 2], tmp[maxn &lt;&lt; 2];int ans[maxn];int BIT[maxm];int n, s, w;inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l, int r) &#123; int ret = 0; for (int i = l - 1; i &gt; 0; i -= lowb(i)) ret -= BIT[i]; for (int i = r; i &gt; 0; i -= lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x, int y) &#123; for (int i = x; i &lt;= w; i += lowb(i)) BIT[i] += y;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = l + r &gt;&gt; 1; int l1 = l, l2 = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (a[i].id &lt;= mid) tmp[l1++] = a[i]; else tmp[l2++] = a[i]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; solve(l, mid); l1 = l; for (int i = mid + 1; i &lt;= r; i++) &#123; while (l1 &lt;= mid &amp;&amp; a[l1].x &lt;= a[i].x) &#123; if (a[l1].op == 1) update(a[l1].y, a[l1].val); l1++; &#125; if (a[i].op == 1) continue; ans[a[i].qid] += a[i].val * query(1, a[i].y); &#125; for (int i = l; i &lt; l1; i++) &#123; if (a[i].op == 1) update(a[i].y, -a[i].val); &#125; solve(mid + 1, r); l1 = l, l2 = mid + 1; int l3 = l; while (l1 &lt;= mid &amp;&amp; l2 &lt;= r) &#123; if (a[l1].x &gt; a[l2].x) tmp[l3++] = a[l2++]; else tmp[l3++] = a[l1++]; &#125; while (l1 &lt;= mid) tmp[l3++] = a[l1++]; while (l2 &lt;= r) tmp[l3++] = a[l2++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d", &amp;s, &amp;w); clr(ans, -1); int op, x1, x2, y1, y2, val; n = 0; int cnt = 0; while (true) &#123; scanf("%d", &amp;op); if (op == 3) break; if (op == 1) &#123; scanf("%d%d%d", &amp;x1, &amp;y1, &amp;val); a[++n] = &#123;op, x1, y1, val, n, -1&#125;; &#125; else &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); ++cnt; ans[cnt] = 0; a[++n] = &#123;op, x2, y2, 1, n, cnt&#125;; a[++n] = &#123;op, x1 - 1, y2, -1, n, cnt&#125;; a[++n] = &#123;op, x2, y1 - 1, -1, n, cnt&#125;; a[++n] = &#123;op, x1 - 1, y1 - 1, 1, n, cnt&#125;; &#125; &#125; sort(a + 1, a + n + 1); solve(1, n); for (int i = 1; i &lt;= cnt; i++) &#123; if (ans[i] == -1) continue; else printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1492-Cash-CDQ分治入门题]]></title>
    <url>%2F2018%2F09%2F05%2Fbzoj1492-Cash-CDQ%E5%88%86%E6%B2%BB%E5%85%A5%E9%97%A8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意股市中有两种金券A和B，每天都会有个成交价格$a_i,b_i$ 每天可以做无限次操作。 操作分为两类： 按当天固定比例$c_i$购买金券。 即每天都会有个比例$c_i$，若要买k元的金卷，那么保证购入的A卷的数量比B卷的数量等于$c_i$ 按任意相同比例卖出金卷，即同时要卖出百分之x的金卷。 如果你一开始有S元，那么请问n天后，最多能获得多少钱？ 拥有的卷的数量为实数。 $1 \leq n \leq 1e5$ 分析$dp[i]$:表示第i天所能获得的最大金钱。 $x[i]$表示第i天最多能获得的A卷数量， $y[i]$表示第i天最多能获得的B卷数量 $$dp[i] = Max(x[j] a[i] + y[j] b[i]), j \in [1,i-1]$$ 如果决策k优于决策j，那么 $$(x[j] - x[k])a[i] &lt; (y[k] - y[j])b[i]$$ 不妨设$x[k] &gt; x[j]$,那么 $$\frac{y[k] - y[j]}{x[k] - x[j]} &gt; -\frac{a[i]}{b[i]}$$ 因此根据斜率优化dp的知识，我们知道需要维护一个$x[i]$递增的，并且斜率递减的队列。 同时由于不等式右边并没有单调性，因此我们需要在队列里二分。 但这个队列有点难维护（貌似还要手写平衡树 （ 我会补的！ ） 因此我们的CDQ分治就要登场啦！ 定义$solve(l,r)$是计算出$[l,r]$的答案(dp值)。 那么我先计算$solve(l,mid)$ 然后用$[l,mid]$的结果算一下对$[mid+1,r]$的贡献 然后再计算$solve(mid+1,r)$ 是不是就是$solve(l,r)$了呢？ （这大概就是cdq分治了 那么$[l,mid]$对$[mid+1,r]$的贡献怎么算呢？ 我们将$[l,mid]$的元素按$x$排序，保证了$x$的递增 然后将$[mid+1,r]$的元素按$-\frac{a[i]}{b[i]}$从小到大排序，这样保证了不等式右边的单调性。 这样的话我们就可以用单调队列优化了！ 维护一个斜率递减的单调队列，$O(nlogn)$即可解决问题。 看了一下网上别人的代码，发现还可以优化。 不需要排序，可以将$O(nlogn)$降为$O(n)$ 一开始就将数组按$-\frac{a[i]}{b[i]}$排序， 然后在$solve(mid+1,r)$解决之后，再将$[l,r]$按$x$从小到大排序。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double eps = 1e-8;const int maxn = 1e5 + 5;struct P &#123; double a, b, r, k, x, y; int id; bool operator&lt;(const P &amp;A) const &#123; return k &gt; A.k; &#125;&#125;;P p[maxn], cpy[maxn];double dp[maxn];int q[maxn];inline double slope(int j, int k) &#123; if (fabs(p[j].x - p[k].x) &lt; eps) &#123; if (p[k].y - p[j].y &gt; 0) return 1e10; else return -1e9; &#125; return (p[j].y - p[k].y) / (p[j].x - p[k].x);&#125;void solve(int l, int r) &#123; if (l == r) &#123; dp[l] = max(dp[l - 1], dp[l]); p[l].y = dp[l] / (p[l].a * p[l].r + p[l].b); p[l].x = p[l].y * p[l].r; return; &#125; int m = l + r &gt;&gt; 1; int l1 = l, l2 = m + 1; for (int i = l; i &lt;= r; i++) &#123; if (p[i].id &lt;= m) cpy[l1++] = p[i]; else cpy[l2++] = p[i]; &#125; for (int i = l; i &lt;= r; i++) p[i] = cpy[i]; solve(l, m); int L = l, R = l - 1; for (int i = l; i &lt;= m; i++) &#123; while (L &lt; R &amp;&amp; slope(q[R - 1], q[R]) &lt; slope(q[R], i)) R--; q[++R] = i; &#125; for (int i = m + 1, id; i &lt;= r; i++) &#123; while (L &lt; R &amp;&amp; slope(q[L], q[L + 1]) &gt; p[i].k) L++; id = q[L]; dp[p[i].id] = max(dp[p[i].id], p[id].x * p[i].a + p[id].y * p[i].b); &#125; solve(m + 1, r); l1 = l, l2 = m + 1; int cur = l; while (l1 &lt;= m &amp;&amp; l2 &lt;= r) &#123; if (p[l1].x &lt; p[l2].x + eps) cpy[cur++] = p[l1++]; else cpy[cur++] = p[l2++]; &#125; while (l1 &lt;= m) cpy[cur++] = p[l1++]; while (l2 &lt;= r) cpy[cur++] = p[l2++]; for (int i = l; i &lt;= r; i++) p[i] = cpy[i];&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; double s; scanf("%d%lf", &amp;n, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf%lf%lf", &amp;p[i].a, &amp;p[i].b, &amp;p[i].r); p[i].id = i; p[i].k = -p[i].a / p[i].b; &#125; sort(p + 1, p + 1 + n); dp[0] = s; solve(1, n); printf("%.3lf\n", dp[n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>分治</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[staircase nim-楼梯游戏]]></title>
    <url>%2F2018%2F09%2F05%2Fstaircase-nim-%E6%A5%BC%E6%A2%AF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[定义有一个n阶楼梯，从下到上编号为0~n，游戏开始时有若干硬币任意分布在楼梯上。Alice和Bob轮流操作。每次操作可以选择一阶楼梯上的若干硬币（至少一个），然后移到下一阶楼梯上。最后不能移动的人输。 结论奇数阶楼梯上的石子异或和为零，则先手必胜。 证明首先明确 最后的状态是奇数阶梯上的石子异或和为零。 那么对于奇数阶楼梯上的石子异或和不为零的情况： 先手可以移动若干石子，使得奇数阶梯上的石子异或和为零。 不管后手怎么移动，一定会使得奇数阶梯上的石子异或和不为零。 因此最后一定是先手必胜。 对于奇数阶梯上的石子异或和为零的情况： 不管先手如何移动，都会使得奇数阶梯上的石子异或和不为零。 而后手可以修正，使得奇数阶梯上的石子异或和为零。 因此后手必胜。]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj3675-序列分割]]></title>
    <url>%2F2018%2F09%2F04%2Fbzoj3675-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题意一个长度为n的非负整数序列，要求分割成k+1段，每次分割获得的价值是：分割后两端和的乘积。求获得的最大价值 $1 \leq n \leq 1e5, 1 \leq k \leq 200$ 分析最终答案和分割的次序是没有关系的。 证明可以考虑分割结束后重新合并的过程，发现合并的次序并没有影响，因此分割时的次序也不影响答案。 因为 $k$ 只有 $200$，所以很容易想到一个 $O(nk)$ 的 $dp$。 $dp[k][i]$ 表示第 $k$ 次分割前 $n$ 个元素可获得的最大价值。 $$dp[k][i] = Max( dp[k-1][j] + pre[j] \times ( pre[i] - pre[j])), j \in [k-1,i-1]$$ 继续化简即可得到一个斜率不等式，而且是可以用单调队列优化的那种噢！ 如果对斜率优化不清楚的话，可以参考我的另一篇博客：优化方法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (random_shuffle(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];ll pre[maxn], dp[2][maxn];// inline double slope(int j, int k, int i) &#123;// double mj = dp[(i &amp; 1) ^ 1][j] - pre[j] * pre[j];// double mk = dp[(i &amp; 1) ^ 1][k] - pre[k] * pre[k];// if (pre[j] == pre[k]) return (mj - mk) &gt; 0 ? 10000 : -1e9 - 5;// return (mj - mk) / (pre[j] - pre[k]);// &#125;bool check1(int j, int k, int i, int t) &#123; ll mj = dp[(i &amp; 1) ^ 1][j] - pre[j] * pre[j]; ll mk = dp[(i &amp; 1) ^ 1][k] - pre[k] * pre[k]; return (mj - mk) &lt;= pre[t] * (pre[k] - pre[j]);&#125;bool check2(int j, int k, int f, int i) &#123; ll mj = dp[(i &amp; 1) ^ 1][j] - pre[j] * pre[j]; ll mk = dp[(i &amp; 1) ^ 1][k] - pre[k] * pre[k]; ll mf = dp[(i &amp; 1) ^ 1][f] - pre[f] * pre[f]; return (mj - mk) * (pre[f] - pre[k]) &gt;= (mk - mf) * (pre[k] - pre[j]);&#125;int main() &#123; /*#ifndef ONLINE_JUDGEfreopen("1.in", "r", stdin);freopen("1.out", "w", stdout);#endif */ std::ios::sync_with_stdio(false); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), pre[i] = pre[i - 1] + a[i]; for (int i = 1; i &lt;= m; i++) &#123; int l = 1, r = 1; vector&lt;int&gt; q(n + 2); q[1] = i - 1; for (int t = i; t &lt;= n; t++) &#123; while (l &lt; r &amp;&amp; check1(q[l], q[l + 1], i, t)) l++; int idx = q[l]; dp[i &amp; 1][t] = dp[(i &amp; 1) ^ 1][idx] + pre[idx] * (pre[t] - pre[idx]); while (l &lt; r &amp;&amp; check2(q[r - 1], q[r], t, i)) r--; // while (l &lt; r &amp;&amp; slope(q[r - 1], q[r], i) &lt; slope(q[r], t, i)) r--; q[++r] = t; &#125; &#125; printf("%lld\n", dp[m &amp; 1][n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj1010-玩具装箱]]></title>
    <url>%2F2018%2F09%2F03%2Fbzoj1010-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[题意n个玩具，每个玩具长度为$c[i]$，制造一个长度为x的容器需要$(x - L) ^ 2$元，可以将下标连续的玩具放在同一个容器中，两两玩具之间需要加一个长度为1的垫子（容器的头和尾不用）。 问将所有玩具装到容器中的最小价值。 $1 \leq n \leq 50000, 1 \leq L,c[i] \leq 10000000$ 分析$dp[i]$ 表示装前i个玩具需要的最小代价$$dp[i] = Min(dp[j] + (pre[i] - pre[j] + i - j - 1 - L) ^ 2), j \in [1,i-1]$$ 其中$pre[i]$为长度的前缀和。 设$a[i] = pre[i] + i, b = 1 + L$ $M[i][j] = dp[j] + (pre[i] - pre[j] + i - j - 1 - L) ^ 2$ 对于两个决策j和k(j &lt; k)，若k决策优于j决策，则有$M[i][j] &gt; M[i][k]$ 我们来继续化简一下这个式子。 可以得到$$\frac{(dp[j] + a[j]^2) - (dp[k] + a[k])^2}{a[j] - a[k]} &lt; 2a[i] - 2b$$ 设$C[i] = 2a[i] - 2b$，把不等式左边看成一个斜率$slope(j,k)$ 所以我们只要维护一个$slope$单调递增的队列，为什么呢? 如果$slope(q[i-1],q[i]) &gt; slope(q[i],q[i+1])$ ，那么当q[i]比q[i-1]优的时候，q[i+1]一定比q[i]优，所以q[i]就没有存在的必要了。 所以我们需要维护的是一个递增的队列。 假设队列中的i位置的值是决策点， 那么有$$\begin{cases} slope(q[i-1],q[i]) &lt; C[i]\\ slope(q[i],q[i+1]) &gt;= C[i] \end{cases}$$ 一般情况下只要二分这个i值就可以了，但是本题中$C[i]$是单调不降的，所以对于决策j,k(j &lt; k), k优于j决策的话，那么对于$i \in [k+1,n]$都适用，因此j决策就没有存在的必要了，因此我们可以用单调队列进行优化 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;ll pre[maxn], a[maxn], c[maxn], dp[maxn];inline double slope(int i, int k) &#123; return 1.0 * ((dp[i] + a[i] * a[i]) - (dp[k] + a[k] * a[k])) / (a[i] - a[k]);&#125;int main() &#123; // /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, L; scanf("%d%d", &amp;n, &amp;L); for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]), pre[i] = pre[i - 1] + c[i], a[i] = pre[i] + i; int b = 1 + L; int l = 1, r = 1; vector&lt;int&gt; dq(n + 2); dq[1] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (l &lt; r &amp;&amp; slope(dq[l], dq[l + 1]) &lt; 2 * a[i] - 2 * b) l++; int k = dq[l]; dp[i] = dp[k] + (a[i] - a[k] - b) * (a[i] - a[k] - b); while (l &lt; r &amp;&amp; slope(dq[r], i) &lt; slope(dq[r - 1], dq[r])) r--; dq[++r] = i; &#125; printf("%lld\n", dp[n]);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj4836-分治FFT]]></title>
    <url>%2F2018%2F08%2F31%2Fbzoj4836-%E5%88%86%E6%B2%BBFFT%2F</url>
    <content type="text"><![CDATA[题意$$x \ opt \ y = \begin{cases} x+y&amp;, &amp;x&lt;y \\ x-y&amp;,&amp;x≥y \end{cases}$$ 现在给定一个长为 n 的数列 a 和一个长为 m 的数列 b ，接下来有 q 次询问。每次询问给定一个数字 c 你需要求出有多少对 (i, j) 使得 $a_i\ opt\ b_j=c$ 分析对于 x+y 的操作，有可能会算到 $x \leq y$的情况，所以我们选择分治 $x \in [l,mid]$ 的情况和$y \in (mid,r]$ 会有贡献 对于x-y的操作，则不会算到x &lt; y的情况， 所以算一遍就可以啦 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)const double PI = acos(-1.0);const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;namespace fft &#123;typedef double db;struct cp &#123; db x, y; cp() &#123; x = y = 0; &#125; cp(db x, db y) : x(x), y(y) &#123;&#125;&#125;;inline cp operator+(cp a, cp b) &#123; return cp(a.x + b.x, a.y + b.y); &#125;inline cp operator-(cp a, cp b) &#123; return cp(a.x - b.x, a.y - b.y); &#125;inline cp operator*(cp a, cp b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;inline cp conj(cp a) &#123; return cp(a.x, -a.y); &#125;int base = 1;vector&lt;cp&gt; roots;vector&lt;int&gt; rev;const db PI = acosl(-1.0);void init() &#123; roots.pb(cp(0, 0)); roots.pb(cp(1, 0)); rev.pb(0); rev.pb(1);&#125;void ensure_base(int nbase) &#123; if (nbase &lt;= base) return; rev.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); for (int i = 0; i &lt; (1 &lt;&lt; nbase); i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1)); roots.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); while (base &lt; nbase) &#123; db angle = 2 * PI / (1 &lt;&lt; (base + 1)); for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) &#123; roots[i &lt;&lt; 1] = roots[i]; db angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base)); roots[(i &lt;&lt; 1) + 1] = cp(cos(angle_i), sin(angle_i)); &#125; base++; &#125;&#125;void fft(vector&lt;cp&gt;&amp; a, int n = -1) &#123; if (n == -1) n = a.size(); assert((n &amp; (n - 1)) == 0); int zeros = __builtin_ctz(n); ensure_base(zeros); int shift = base - zeros; for (int i = 0; i &lt; n; i++) if (i &lt; (rev[i] &gt;&gt; shift)) swap(a[i], a[rev[i] &gt;&gt; shift]); for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += 2 * k) for (int j = 0; j &lt; k; j++) &#123; cp z = a[i + j + k] * roots[j + k]; a[i + j + k] = a[i + j] - z; a[i + j] = a[i + j] + z; &#125;&#125;vector&lt;cp&gt; fa, fb;vector&lt;ll&gt; multiply(vector&lt;ll&gt;&amp; a, vector&lt;ll&gt;&amp; b) &#123; int need = a.size() + b.size() - 1; int nbase = 0; while ((1 &lt;&lt; nbase) &lt; need) nbase++; ensure_base(nbase); int sz = 1 &lt;&lt; nbase; if (sz &gt; (int)fa.size()) fa.resize(static_cast&lt;unsigned long&gt;(sz)); for (int i = 0; i &lt; sz; i++) &#123; ll x = (i &lt; (int)a.size() ? a[i] : 0); ll y = (i &lt; (int)b.size() ? b[i] : 0); fa[i] = cp(x, y); &#125; fft(fa, sz); cp r(0, -0.25 / sz); for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) &#123; int j = (sz - i) &amp; (sz - 1); cp z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r; if (i != j) &#123; fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r; &#125; fa[i] = z; &#125; fft(fa, sz); vector&lt;ll&gt; res(static_cast&lt;unsigned long&gt;(need)); for (int i = 0; i &lt; need; i++) &#123; res[i] = fa[i].x + 0.5; &#125; return res;&#125;&#125;; // namespace fftll a[maxn], b[maxn], c[maxn &lt;&lt; 3];const int offset = maxn;void solve(int l, int r) &#123; if (l == r) &#123; c[0] += a[l] * b[r]; return; &#125; int m = l + r &gt;&gt; 1; vector&lt;ll&gt; s1(r - l + 1), s2(r - l + 1); for (int i = 0; i &lt;= m - l; i++) s1[i] = a[i + l]; for (int i = 1; i &lt;= r - m; i++) s2[i] = b[i + m]; vector&lt;ll&gt; ret = fft::multiply(s1, s2); for (int i = 1; i &lt;= r - l; i++) c[i + l + m + offset] += ret[i]; solve(l, m); solve(m + 1, r);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); fft::init(); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); clr(c, 0); clr(a, 0); clr(b, 0); for (int i = 0, x; i &lt; n; i++) &#123; scanf("%d", &amp;x); a[x]++; &#125; for (int i = 0, x; i &lt; m; i++) &#123; scanf("%d", &amp;x); b[x]++; &#125; vector&lt;ll&gt; s1(maxn), s2(maxn + offset); for (int i = 0; i &lt; maxn; i++) s1[i] = a[i]; for (int i = 0; i &lt; maxn; i++) s2[offset - i] = b[i]; vector&lt;ll&gt; ret = fft::multiply(s1, s2); for (int i = 0; i &lt; maxn; i++) c[i + offset] += ret[i + offset]; solve(0, 50000); for (int i = 0, x; i &lt; q; i++) &#123; scanf("%d", &amp;x); printf("%lld\n", c[x + offset]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bzoj 3527]]></title>
    <url>%2F2018%2F08%2F31%2Fbzoj-3527%2F</url>
    <content type="text"><![CDATA[题意给你一个长度为n的序列$a+i$,让求出$E_i$ $E_i = \sum_{k&lt;i} \frac{a_k}{(i-k)^2} - \sum_{k&gt;i} \frac{a_k}{(i-k)^2}$ n≤100000 分析把$i-k$记做$d$ 设$A[i] = a_i$, $B[d] = \frac{1}{d^2}$ 那么前面那个式子直接卷积就可以了。 后面的式子因为是负数，所以要偏移一下 $A[i + N] = a_i$, $B[-d + N] = \frac{-1}{d^2}$ 然后卷一下就好了。 主要学习一下这个偏移的操作。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];double sum[maxn &lt;&lt; 2];double a[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%lf", a + i); int len = 1; while (len &lt; n * 4) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0), sum[i] = 0; for (int i = 0; i &lt; n; i++) x1[i + n].x = a[i]; for (int i = 1; i &lt; n; i++) x2[i + n].x = 1.0 / (1.0 * i * i); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += x1[i].x; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); for (int i = 0; i &lt; n; i++) x1[i + n].x = a[i]; for (int i = 1; i &lt; n; i++) x2[n - i].x = -1.0 / (1.0 * i * i); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += x1[i].x; for (int i = 0; i &lt; n; i++) &#123; printf("%.3lf\n", sum[i + 2 * n]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三维前缀和]]></title>
    <url>%2F2018%2F08%2F31%2F%E4%B8%89%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819int a[maxn][maxn][maxn];int sum(int x1, int y1, int z1, int x2, int y2, int z2) &#123; return a[x2][y2][z2] - a[x1 - 1][y2][z2] - a[x2][y1 - 1][z2] - a[x2][y2][z1 - 1] + a[x1 - 1][y1 - 1][z2] + a[x1 - 1][y2][z1 - 1] + a[x2][y1 - 1][z1 - 1] - a[x1 - 1][y1 - 1][z1 - 1];&#125;void init(int n) &#123; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i - 1][k][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k - 1][t]; for (int i = 0; i &lt; n; i++) for (int k = 0; k &lt; n; k++) for (int t = 0; t &lt; n; t++) a[i][k][t] += a[i][k][t - 1];&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf528D-Fuzzy Search]]></title>
    <url>%2F2018%2F08%2F28%2Fcf528D-Fuzzy-Search%2F</url>
    <content type="text"><![CDATA[题意给你两个串a,b,和一个数字k, 对于b[i] 它可以匹配 a中[i-k,i+k]任意一个位置的字符（a中每个字符可以重复匹配）。 问b在a中可以有几次匹配？ $1 \leq b \leq a \leq 2e5, 0 \leq k \leq 2e5$ 分析如果 b[i] 可以匹配 a[i-k,i+k], 不妨把a[i-k,i+k]的字符都放到 a[i]这个位置上（前提是ａ中每个字符是可以重复匹配的）。 这样的话问题又变成了传统套路题。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int ok[maxn][5];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); map&lt;char, int&gt; id; id['A'] = 1; id['G'] = 2; id['C'] = 3; id['T'] = 4; int len1, len2, k; scanf("%d%d%d%s%s", &amp;len1, &amp;len2, &amp;k, a, b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; deque&lt;int&gt; dq; for (int i = 0; i &lt; k &amp;&amp; i &lt; len1; i++) &#123; dq.push_back(id[a[i]]); sum[id[a[i]]]++; &#125; for (int i = 0; i &lt; len1; i++) &#123; if (i + k &lt; len1) dq.pb(id[a[i + k]]), sum[id[a[i + k]]]++; if (i &gt; k) &#123; sum[dq.front()]--; dq.pop_front(); &#125; for (int j = 1; j &lt; 5; j++) if (sum[j]) ok[i][j]++; &#125; for (int i = 1; i &lt; 5; i++) sum[i] = 0; for (int c = 1; c &lt; 5; c++) &#123; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); for (int i = 0; i &lt; len1; i++) if (ok[i][c]) x1[i] = Complex(1, 0); for (int i = 0; i &lt; len2; i++) if (id[b[i]] == c) x2[len2 - i - 1] = Complex(1, 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) sum[i] += (int)(x1[i].x + 0.5); &#125; ll ans = 0; for (int i = len2 - 1; i &lt; len1; i++) &#123; if (sum[i] == len2) ans++; &#125; printf("%lld\n", ans);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu5885-XM Reserves]]></title>
    <url>%2F2018%2F08%2F27%2Fhdu5885-XM-Reserves%2F</url>
    <content type="text"><![CDATA[题意n*m的矩形，每个点有p(i,j)，你可以选择一个点(x,y)，那么在该点可以得到的价值val为1234rep(i,1,n) rep(j,1,m) &#123; dis=(i,j)与(x,y)欧几里得距离 if(dis&lt;R) val+=p(i,j)/(dis+1)&#125; 要求选取一个点，使val最大，输出val (1≤n,m≤500), (0≤r≤300). 分析FFT建模 首先观察这个式子$$\frac{p(i,j)}{\sqrt{(dx^2+dx^2)} + 1}$$ 它对$(i + dx, j + dy)$有贡献 发现分子分母之间没有联系，所以是可以分开的。 不妨设$A[i][j] = p(i,j)$, $B[dx][dy] = \frac{1}{\sqrt{(dx^2+dx^2)} + 1}$ 所以$C[i+dx][j+dy] = A[i][j] * B[dx][dy]$ 这个卷积式已经够明显了吧。 接下来要做的就是降维。 dx的范围是[-r,r] , dy的范围是[-r,r]. 所以需要进行下标的偏移，行的长度变为 m + 2r, 列的长度变为 n + 2r. 注意限制条件 $dx^2 + dy^2 &lt; R^2$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e6+6;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/* * 进行FFT和IFFT前的反转变换。 * 位置i和 （i二进制反转后位置）互换 * len必须取2的幂 */void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/* * 做FFT * len必须为2^k形式， * on==1时是DFT，on==-1时是IDFT * DFT:系数表示法-&gt;点值表示法 * IDFT:点值表示法-&gt;系数表示法 */void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; double R; while (~scanf("%d%d%lf", &amp;n, &amp;m, &amp;R)) &#123; int r = ceil(R); int M = max(n, m) + 2 * r; int len = 1; while (len &lt; M * M * 2) len &lt;&lt;= 1; for (int i = 0; i &lt; len; i++) x1[i] = Complex(0, 0), x2[i] = Complex(0, 0); double u; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; m; k++) scanf("%lf", &amp;u), x1[i * M + k] = Complex(u, 0); &#125; for (int i = -r; i &lt;= r; i++) &#123; for (int k = -r; k &lt;= r; k++) &#123; if (i * i + k * k &lt; R * R) x2[(i + r) * M + k + r] = Complex(1.0 / (sqrt(i * i + k * k) + 1), 0); &#125; &#125; fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); double ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; m; k++) &#123; ans = max(ans, x1[(i + r) * M + r + k].x); &#125; &#125; printf("%.3lf\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu4609-3-idiots]]></title>
    <url>%2F2018%2F08%2F27%2Fhdu4609-3-idiots%2F</url>
    <content type="text"><![CDATA[题意给定n个长度为ai的木棍求，任选三个使其能够组成三角形的概率 $(3≤n≤10^5)$. $(1≤a_i≤105)$ 分析长度比较小，考虑$c[i]$表示长度为i的木棒的个数。$d[i + k] = c[i] * c[k]$ 表示两根木棒组合长度为i+k的种数。 这样可以通过枚举第三边，求得答案。 问题是如何求得d数组， 可以观察到这是一个卷积的形式， 所以可以FFT加速一下。 这些方案里需要去除一些不满足要求(ai为最长边)的 （先排序） 另外两条边两条均&gt;ai，ans-=(n-i)*(n-i-1)/2 另外两条边一条&gt;ai，一条&lt;ai,ans-=(n-i)*(i-1) 另外两条边一条=ai，另一条随意,ans-=n-1代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/* * 进行FFT和IFFT前的反转变换。 * 位置i和 （i二进制反转后位置）互换 * len必须取2的幂 */void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/* * 做FFT * len必须为2^k形式， * on==1时是DFT，on==-1时是IDFT * DFT:系数表示法-&gt;点值表示法 * IDFT:点值表示法-&gt;系数表示法 */void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x[maxn &lt;&lt; 2];ll sum[maxn &lt;&lt; 2], c[maxn], a[maxn], pre[maxn &lt;&lt; 2];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n; scanf("%d", &amp;n); clr(sum,0); for (int i = 0, x; i &lt; n; i++) scanf("%lld", a + i), ++sum[a[i]]; sort(a, a + n); int len1 = a[n-1] + 1; int len = 1; while (len &lt; len1 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for (int i = 0; i &lt; len1; i++) x[i] = Complex(sum[i], 0); for (int i = len1; i &lt; len; i++) x[i] = Complex(0, 0); fft(x, len, 1); for (int i = 0; i &lt; len; i++) x[i] = x[i] * x[i]; fft(x, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = ll(x[i].x + 0.5); &#125; len = a[n-1] * 2; for(int i=0;i&lt;n;i++) sum[a[i] &lt;&lt; 1]--; for(int i=0;i&lt;=len;i++) sum[i] &gt;&gt;= 1; pre[0] = sum[0]; for (int i = 1; i &lt;= len; i++) &#123; pre[i] = pre[i - 1] + sum[i]; &#125; ll ans = 0; for (int i = 0; i &lt; n; i++) &#123; ans += pre[len] - pre[a[i]]; ans -= n - 1; ans -= 1LL * (n - i - 1) * (i); ans -= 1LL * (n - i - 1) * (n - i - 2) / 2; &#125; ll tmp = 1LL * (n) * (n-1) * (n-2) / 6; printf("%.7lf\n",1.0 * ans/tmp); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计蒜客26219-Rock Paper Scissors Lizard Spock]]></title>
    <url>%2F2018%2F08%2F27%2F%E8%AE%A1%E8%92%9C%E5%AE%A226219-Rock-Paper-Scissors-Lizard-Spock%2F</url>
    <content type="text"><![CDATA[题意给两个只包含大写字母的字符串$s1,s2, (1 \leq s2 \leq s1 \leq 10^6)$，以及一些克制关系。 你需要从$s1$中找一子串$t$，使得$t$与$s2$匹配所得分数最大。 匹配的意思是 :12for(i : 0 -&gt; t.size()) if(s2[i] 克制 t[i]) 分数++ 分析FFT解决字符串匹配的套路题 枚举克制关系 比如A克制B， 那么我将$s1$中所有字符为B的位置都设为1，其余为0。 再将$s2$中所有字符为A的位置都设为1，其余为0 然后跑一遍fft，得到的结果就是sum[i] 就是$s1$中以第i个位置结尾的子串与$s2$的在当前克制关系下的分数。 然后枚举克制关系，把所有的分数加起来，最后再扫一遍取最大值即可（注意i的范围是[s2-1, s1-1]) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e6 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn],b[maxn];int sum[maxn];int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); while(~scanf("%s%s",a,b))&#123; map&lt;char,pair&lt;char,char&gt; &gt; hash; hash['R'] = mp('K','P'); hash['L'] = mp('R','S'); hash['K'] = mp('L','P'); hash['P'] = mp('L','S'); hash['S'] = mp('R','K'); int len1 = strlen(a); int len2 = strlen(b); int len = 1; while(len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; for(int i=0;i&lt;len;i++) sum[i] = 0; for(auto &amp;u:hash)&#123; for(int i=0;i&lt;len;i++) x1[i] = Complex(0,0), x2[i] = Complex(0,0); for(int i=0;i&lt;len1;i++) if(a[i] == u.first) x1[len1 - i - 1] = Complex(1,0); for(int i=0;i&lt;len2;i++) if(b[i] == u.second.first || b[i] == u.second.second) x2[i] = Complex(1,0); fft(x1,len,1); fft(x2,len,1); for(int i=0;i&lt;len;i++) x1[i] = x1[i] * x2[i]; fft(x1,len,-1); for(int i=0;i&lt;len;i++) sum[i] += int(x1[i].x + 0.5); &#125; int ans = 0; for(int i=0;i&lt;len;i++) ans = max(ans, sum[i]); printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu1402 大数相乘]]></title>
    <url>%2F2018%2F08%2F26%2Fhdu1402-%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[题意大数相乘 分析FFT模板题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%s%s", &amp;a, &amp;b)) &#123; int len1 = strlen(a); int len2 = strlen(b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for (int i = 0; i &lt; len1; i++) x1[i] = Complex(a[len1 - 1 - i] - '0', 0); for (int i = len1; i &lt; len; i++) x1[i] = Complex(0, 0); for (int i = 0; i &lt; len2; i++) x2[i] = Complex(b[len2 - 1 - i] - '0', 0); for (int i = len2; i &lt; len; i++) x2[i] = Complex(0, 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = int(x1[i].x + 0.5); &#125; for (int i = 0; i &lt; len; i++) &#123; sum[i + 1] += sum[i] / 10; sum[i] %= 10; &#125; len = len1 + len2 - 1; while (sum[len] == 0 &amp;&amp; len &gt; 0) len--; for (int i = len; i &gt;= 0; i--) printf("%d", sum[i]); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FFT]]></title>
    <url>%2F2018%2F08%2F26%2FFFT%2F</url>
    <content type="text"><![CDATA[FFT基本形式$h(n) = \sum_{i=0}^{n}f(i)g(n-i)$ 表示多项式$f$和$g$相乘后，$n$次项的系数为$h(n)$。 A[0] A[1] A[2] … A[n] $f(0)$ $f(1)$ $f(2)$ … $f(n)$ B[0] B[1] B[2] … B[n] $g(0)$ $g(1)$ $g(2)$ … $g(n)$ $h(n) = C[n]$ 变式1$h(n) = \sum_{i=k}^{n}f(i)g(n-i)$ A[0] A[1] A[2] … A[n-k] $f(k)$ $f(k+1)$ $f(k+2)$ … $f(n)$ B[0] B[1] B[2] … B[n-k] $g(0)$ $g(1)$ $g(2)$ … $g(n-k)$ $h(n) = C[n-k]$ 2$h(n) = \sum_{i=0}^{n}f(i)g(i+a)$ 设$z(n-i) = f(i)$ 则原式变为$h(n+a) = \sum_{i=0}^{n}z(n-i)g(i+a)$ A[0] A[1] A[2] … A[n] $z(0)$ $z(1)$ $z(2)$ … $z(n)$ B[0] B[1] B[2] … B[n] $g(a)$ $g(a+1)$ $g(a+2)$ … $g(a+n)$ $h(n+a) = C[n]$ 3$h(n) = \sum_{i=k}^{n}f(i)g(i+a)$ 设$z(n-i) = f(i)$ 则原式变为$h(n+a) = \sum_{i=k}^{n}z(n-i)g(i+a)$ A[0] A[1] A[2] … A[n-k] $z(0)$ $z(1)$ $z(2)$ … $z(n-k)$ B[0] B[1] B[2] … B[n-k] $g(k+a)$ $g(k+a+1)$ $g(k+a+2)$ … $g(a+n)$ $h(n+a) = C[n-k]$ 4$h(n) = \sum_{i=1}^{n}\sum_{j=1}^{n}x^{ij}$ 其中 $x$ 为常数。 $$\begin{aligned}h(n) &amp;= \sum_{i=1}^{n}\sum_{j=1}^{n}x^{ij} \\&amp;= \sum_{i=1}^{n}\sum_{j=1}^{n}x^{\frac{1}{2}\times (i^2 + j^2 - (i-j)^2)} \\&amp;= \sum_{i=1}^{n}x^{\frac{1}{2} \times i^2}\sum_{j=1}^{n}x^{\frac{1}{2} \times j^2} x^{-\frac{1}{2} \times (i-j)^2} \\&amp;= \sum_{i=1}^{n}x^{\frac{1}{2} \times i^2}\sum_{j=1}^{n}f_jg_{i-j}\end{aligned}$$ 模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace fft &#123;typedef double db;struct cp &#123; db x, y; cp() &#123; x = y = 0; &#125; cp(db x, db y) : x(x), y(y) &#123;&#125;&#125;;inline cp operator+(cp a, cp b) &#123; return cp(a.x + b.x, a.y + b.y); &#125;inline cp operator-(cp a, cp b) &#123; return cp(a.x - b.x, a.y - b.y); &#125;inline cp operator*(cp a, cp b) &#123; return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);&#125;inline cp conj(cp a) &#123; return cp(a.x, -a.y); &#125;int base = 1;vector&lt;cp&gt; roots = &#123;&#123;0, 0&#125;, &#123;1, 0&#125;&#125;;vector&lt;int&gt; rev = &#123;0, 1&#125;;const db PI = acosl(-1.0);void ensure_base(int nbase) &#123; if (nbase &lt;= base) return; rev.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); for (int i = 0; i &lt; (1 &lt;&lt; nbase); i++) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1)); roots.resize(static_cast&lt;unsigned long&gt;(1 &lt;&lt; nbase)); while (base &lt; nbase) &#123; db angle = 2 * PI / (1 &lt;&lt; (base + 1)); for (int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) &#123; roots[i &lt;&lt; 1] = roots[i]; db angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base)); roots[(i &lt;&lt; 1) + 1] = cp(cos(angle_i), sin(angle_i)); &#125; base++; &#125;&#125;void fft(vector&lt;cp&gt;&amp; a, int n = -1) &#123; if (n == -1) n = a.size(); assert((n &amp; (n - 1)) == 0); int zeros = __builtin_ctz(n); ensure_base(zeros); int shift = base - zeros; for (int i = 0; i &lt; n; i++) if (i &lt; (rev[i] &gt;&gt; shift)) swap(a[i], a[rev[i] &gt;&gt; shift]); for (int k = 1; k &lt; n; k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += 2 * k) for (int j = 0; j &lt; k; j++) &#123; cp z = a[i + j + k] * roots[j + k]; a[i + j + k] = a[i + j] - z; a[i + j] = a[i + j] + z; &#125;&#125;vector&lt;cp&gt; fa, fb;vector&lt;int&gt; multiply(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int need = a.size() + b.size() - 1; int nbase = 0; while ((1 &lt;&lt; nbase) &lt; need) nbase++; ensure_base(nbase); int sz = 1 &lt;&lt; nbase; if (sz &gt; (int)fa.size()) fa.resize(static_cast&lt;unsigned long&gt;(sz)); for (int i = 0; i &lt; sz; i++) &#123; int x = (i &lt; (int)a.size() ? a[i] : 0); int y = (i &lt; (int)b.size() ? b[i] : 0); fa[i] = cp(x, y); &#125; fft(fa, sz); cp r(0, -0.25 / sz); for (int i = 0; i &lt;= (sz &gt;&gt; 1); i++) &#123; int j = (sz - i) &amp; (sz - 1); cp z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r; if (i != j) &#123; fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r; &#125; fa[i] = z; &#125; fft(fa, sz); vector&lt;int&gt; res(static_cast&lt;unsigned long&gt;(need)); for (int i = 0; i &lt; need; i++) &#123; res[i] = fa[i].x + 0.5; &#125; return res;&#125;&#125;; // namespace fft 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;const double PI = acos(-1.0);//复数结构体struct Complex &#123; double x, y; //实部和虚部 x+yi Complex(double _x = 0.0, double _y = 0.0) &#123; x = _x, y = _y; &#125; Complex operator-(const Complex&amp; b) const &#123; return Complex(x - b.x, y - b.y); &#125; Complex operator+(const Complex&amp; b) const &#123; return Complex(x + b.x, y + b.y); &#125; Complex operator*(const Complex&amp; b) const &#123; return Complex(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;/** 进行FFT和IFFT前的反转变换。* 位置i和 （i二进制反转后位置）互换* len必须取2的幂*/void change(Complex y[], int len) &#123; for (int i = 1, j = len / 2; i &lt; len - 1; i++) &#123; if (i &lt; j) swap(y[i], y[j]); //交换互为小标反转的元素，i&lt;j保证交换一次 // i做正常的+1，j左反转类型的+1,始终保持i和j是反转的 int k = len / 2; while (j &gt;= k) j -= k, k /= 2; if (j &lt; k) j += k; &#125;&#125;/** 做FFT* len必须为2^k形式，* on==1时是DFT，on==-1时是IDFT* DFT:系数表示法-&gt;点值表示法* IDFT:点值表示法-&gt;系数表示法*/void fft(Complex y[], int len, int on) &#123; change(y, len); for (int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); // 计算当前的单位复根 for (int j = 0; j &lt; len; j += h) &#123; Complex w(1, 0); // 计算当前的单位复根 for (int k = j; k &lt; j + h / 2; k++) &#123; Complex u = y[k]; Complex t = w * y[k + h / 2]; y[k] = u + t, y[k + h / 2] = u - t; w = w * wn; &#125; &#125; &#125; if (on == -1) for (int i = 0; i &lt; len; i++) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char a[maxn], b[maxn];int sum[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%s%s", &amp;a, &amp;b)) &#123; int len1 = strlen(a); int len2 = strlen(b); int len = 1; while (len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1; // len &gt; len1 + len2 for(int i=0;i&lt;len;i++)&#123; sum[i] = 0; x1[i] = Complex(0, 0); x2[i] = Complex(0, 0); &#125; for (int i = 0; i &lt; len1; i++) x1[i] = Complex(a[i] - '0', 0); for (int i = 0; i &lt; len2; i++) x2[i] = Complex(b[i] - '0', 0); fft(x1, len, 1); fft(x2, len, 1); for (int i = 0; i &lt; len; i++) x1[i] = x1[i] * x2[i]; fft(x1, len, -1); for (int i = 0; i &lt; len; i++) &#123; sum[i] = int(x1[i].x + 0.5); &#125; while (sum[len] == 0 &amp;&amp; len &gt; 0) len--; for (int i = 0; i &lt;= len; i++) printf("%d", sum[i]); puts(""); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>FFT</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分数规划]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[借鉴博客 01分数规划问题有一堆物品，每一个物品有一个收益$ai$，一个代价$bi$，我们要求一个方案使选择的$\frac{\sum a_i}{\sum b_i}$ 最大 思想式子变形后得 $\sum a_i - x \times \sum b_i \geq 0$ 那么可以二分$x$, 然后排序check即可。 最优比率生成树问题图上每条边有两个权值$cost, len$, 求一个生成树，使得$\frac{\sum cost_i}{\sum len_i} \geq x$ 思想二分答案，每条边的边权变为$cost - x \times len$, 跑最小生成树check 最优比率生成环问题图上有点权和边权,求一个回路使得点权和比边权和最大 思想把边权看做花费，点权看做收入。 然后二分答案建图，判正环。 判正环可以转化为权值取负判负环。]]></content>
      <categories>
        <category>ACM</category>
        <category>分数规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018牛客多校赛第五场]]></title>
    <url>%2F2018%2F08%2F03%2F2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%BA%94%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[A-gpa题意有n个课程，每个课程的学分是s[i],相应的绩点是c[i], 现在要去掉k门课，使得$\frac{\sum s[i]c[i]}{\sum s[i]}$ 最大 1≤ n≤ 105 0≤ k &lt; n 1≤ s[i],c[i] ≤ 103 分析分数规划问题 二分答案D，那么对于D有 $\sum si \geq 0$ 浮点数二分这个答案，然后nlogn检查 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const double eps = 1e-6;int c[maxn], s[maxn], id[maxn];int n, k;double ans;bool check(double x) &#123; vector&lt;double&gt; foo(n); for (int i = 0; i &lt; n; i++) foo[i] = s[i] * (c[i] - x); sort(foo.begin(), foo.end(), greater&lt;double&gt;()); double ret = 0; for (int i = 0; i &lt; n - k; i++) &#123; ret += foo[i]; &#125; return ret &gt; 0;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); scanf("%d%d", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;s[i]); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;c[i]); double l = 0, r = 1e3 + 4; while (fabs(r - l) &gt; eps) &#123; // 这里也可以写成循环50次 double mid = (l + r) / 2; if (check(mid)) &#123; ans = mid; l = mid; &#125; else r = mid; &#125; printf("%.8lf\n", ans);&#125; B-div题意一个数 n 是好的，当且仅当 n^4 在 [n^2+1,n^2+2n] 之间有一个约数给定 m，求&gt;=m 的最小的好的 n 1&lt;=m&lt;=10^(1000) 分析代码123456789101112131415# your code goes herem = int(input())a = [0,2,0]i = 1while(a[i] &lt; m): i = (i + 1) % 3 a[i] = a[(i-1 + 3) % 3] * 6 - a[(i-2+3) % 3]ans = a[i]i = 1a = [0,6,0]while(a[i] &lt; m): i = (i + 1) % 3 a[i] = a[(i-1 + 3) % 3] * 14 - a[(i-2+3) % 3]ans = min(ans,a[i])print(ans) I-vcd题意有 n 个点，一个点集 S 是好的，当且仅当对于他的每个子集 T，存在一个右边无限长的矩形，使得这个矩形包含了 T，但是和 S-T 没有交求这 n 个点里有几个好的点集 1&lt;=n&lt;=10^5 分析对于 |S|=1，他显然是好的 对于 |S|=2，只要两个点的 y 坐标不相同，那么这个集合也是好的 对于 |S|=3，三个点的形状必须是 &lt; 型 对于 |S|&gt;3，不可能任何三个点都是 &lt; 型，所以一定不是好的 主要是对于|S|=3情况的统计 对于一个点(x,y),我们需要知道{(x1,y1) | x1 &gt; x, y1 &gt; y}的个数，和{(x1,y1) | x1 &gt; x, y1 &lt; y}的个数 这两个数相乘就是(x,y)对答案的贡献。 其实这个只要倒着统计，因为倒着统计就可以保证(x1 &gt; x) 这个条件，然后用权值树状数组每次查大于y的数量和小于y的数量。 注意横坐标相等的情况是不合法的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 998244353;struct P &#123; int x, y; bool operator&lt;(const P&amp; A) const &#123; if (x == A.x) return y &lt; A.y; return x &lt; A.x; &#125;&#125;;P p[maxn];int BIT[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l, int r) &#123; int ret = 0; for (int i = l - 1; i &gt; 0; i -= lowb(i)) ret -= BIT[i]; for (int i = r; i &gt; 0; i -= lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x, int y, int n) &#123; for (int i = x; i &lt;= n; i += lowb(i)) BIT[i] += y;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (~scanf("%d", &amp;n)) &#123; vector&lt;int&gt; x(n), y(n), tx(x), ty(n); map&lt;int, int&gt; cnt; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;x[i], &amp;y[i]); tx[i] = x[i]; ty[i] = y[i]; &#125; my_sort_unique(x); my_sort_unique(y); for (int i = 0; i &lt; n; i++) &#123; p[i].x = lower_bound(x.begin(), x.end(), tx[i]) - x.begin() + 1; p[i].y = lower_bound(y.begin(), y.end(), ty[i]) - y.begin() + 1; cnt[p[i].y]++; &#125; ll ans = 0; for (auto&amp; v : cnt) &#123; ans += 1LL * (n - v.second) * v.second; &#125; ans /= 2; ans = (ans + n) % mod; clr(BIT, 0); sort(p, p + n); int last = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; int l = query(1, p[i].y - 1); int r = (n - i - 1 - query(1, p[i].y)); if (i &lt; n - 1 &amp;&amp; p[i].x == p[i + 1].x) last++; else last = 0; ans += 1LL * l * (r - last); ans %= mod; // while (ans &gt;= mod) ans -= mod; update(p[i].y, 1, maxn - 1); &#125; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2018hdu多校第四场]]></title>
    <url>%2F2018%2F08%2F02%2F2018hdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[B. Harvest of Apples题意There are n apples on a tree, numbered from 1 to n. Count the number of ways to pick at most m apples. $1 \leq T \leq 1e5, 1 \leq n,m \leq 1e5$ 分析设$S(n,m) = \sum_{i=1}^{m}C(n,i)$ 然后有转移$S(n,m) = 2S(n-1,m) - C(n-1,m) = S(n,m-1) + C(n,m)$ 然后就莫队瞎搞搞… 注意分块排序时候的m要从小到大，不然会有n &lt; m的情况出现。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;int S;struct Node &#123; int n, m, id; ll ans;&#125;;bool cmp(const Node&amp; A, const Node&amp; B) &#123; if (A.n / S == B.n / S) return A.m &lt; B.m; // 注意大小 return A.n / S &lt; B.n / S;&#125;Node a[maxn];ll f[maxn], inv[maxn];ll Pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;void CalFact() &#123; f[0] = 1; for (int i = 1; i &lt; maxn; i++) f[i] = (f[i - 1] * i) % mod; inv[maxn - 1] = Pow(f[maxn - 1], mod - 2); for (int i = maxn - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;&#125;inline ll C(int n, int m) &#123; return f[n] * inv[m] % mod * inv[n - m] % mod; &#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); CalFact(); int n; scanf("%d", &amp;n); S = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].n, &amp;a[i].m); a[i].id = i; &#125; sort(a + 1, a + n + 1, cmp); int nn = 1, mm = 0; ll ans = 1; for (int i = 1; i &lt;= n; i++) &#123; while (nn &lt; a[i].n) &#123; ans = (2 * ans % mod - C(nn, mm) + mod) % mod; nn++; &#125; while (nn &gt; a[i].n) &#123; nn--; ans = (ans + C(nn, mm)) * inv[2] % mod; &#125; while (mm &lt; a[i].m) &#123; mm++; ans = (ans + C(nn, mm)) % mod; &#125; while (mm &gt; a[i].m) &#123; ans = (ans - C(nn, mm) + mod) % mod; mm--; &#125; a[i].ans = ans; &#125; sort(a + 1, a + 1 + n, [](const Node&amp; A, const Node&amp; B) &#123; return A.id &lt; B.id; &#125;); for (int i = 1; i &lt;= n; i++) &#123; printf("%lld\n", a[i].ans); &#125;&#125; D. Nothing is Impossible出题人锅了，虽然后面改了题意，但也不想再看了… 贴一发当时AC的代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 105;struct P&#123; int x,y; bool operator &lt; (const P&amp; A) const&#123; return y &lt; A.y; &#125;&#125;;P a[maxn];int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d",&amp;T); while(T--)&#123; ll n, m; scanf("%lld%lld",&amp;n,&amp;m); int ans = 0; for(int i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;a[i].x, &amp;a[i].y); if(a[i].y == 0 &amp;&amp; a[i].x != 0) ans++; &#125; sort(a,a+n); ll foo = 1; for(int i=0;i&lt;n;i++)&#123; if(a[i].x == 0 || a[i].y == 0) continue; foo *= (a[i].y + 1); if(foo &gt; m) break; ans++; &#125; printf("%d\n",ans); &#125;&#125; E. Matrix from Arrays题意1234567int cursor = 0;for (int i = 0; ; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; M[j][i - j] = A[cursor]; cursor = (cursor + 1) % L; &#125;&#125; 用上述方法构造一个无限大的矩阵，然后若干个查询，每次查询求子矩阵的和。 分析比赛时是打表发现了规律，即对于L为奇数，那么它纵向和横向都存在循环节，且循环节长度为L。对于L为偶数，同样存在循环节，只不过长度为2L。 然后就可以预处理前缀和，然后计算子矩阵的和。 小技巧是可以把循环节长度统一定为2L,这样就不用分类讨论了。 题解里面推导了一下 $M[i][k] = A[\frac{(1+i+k)(i+k)}{2} + 2 \quad mod \quad L] = M[i+2L][k] = M[i][k+2L]$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 150;int A[30];int M[maxn][maxn];ll sum[maxn][maxn];void init(int L) &#123; int sz = 100, p = 0; for (int i = 0; i &lt; sz; i++) &#123; for (int k = 0; k &lt;= i; k++) &#123; M[k][i - k] = A[p]; p = (p + 1) % L; &#125; &#125; for (int i = 1; i &lt;= L * 2; i++) &#123; for (int k = 1; k &lt;= L * 2; k++) &#123; sum[i][k] = M[i - 1][k - 1] + sum[i - 1][k] + sum[i][k - 1] - sum[i - 1][k - 1]; &#125; &#125;&#125;ll solve(int x, int y, int L) &#123; ll ret = 0; ret += sum[L][L] * (x / L) * (y / L); ret += sum[L][y % L] * (x / L); ret += sum[x % L][L] * (y / L); ret += sum[x % L][y % L]; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int L, Q; scanf("%d", &amp;L); for (int i = 0; i &lt; L; i++) scanf("%d", A + i); init(L); L &lt;&lt;= 1; scanf("%d", &amp;Q); int x0, y0, x1, y1; while (Q--) &#123; scanf("%d%d%d%d", &amp;x0, &amp;y0, &amp;x1, &amp;y1); x0++, y0++, x1++, y1++; ll ans = 0; ans += solve(x1, y1, L); ans -= solve(x1, y0 - 1, L); ans -= solve(x0 - 1, y1, L); ans += solve(x0 - 1, y0 - 1, L); printf("%lld\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uva11796-Dog Distance-两点运动时的最短距离与最长距离]]></title>
    <url>%2F2018%2F08%2F02%2Fuva11796-Dog-Distance-%E4%B8%A4%E7%82%B9%E8%BF%90%E5%8A%A8%E6%97%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9C%80%E9%95%BF%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题意甲和乙两条狗分别沿着不同的折线奔跑。两只狗的速度未知，但已知它们同时出发，同时到达，并且都是匀速奔跑。 你的任务是求出甲和乙在奔跑过程中的最远距离和最近距离的差。 分析先将问题简化，甲和乙的路线是一条线段。 因为运动是相对的，所以可以把甲看做静止，这样问题就转化成了点到线段的最短距离与最长距离。 接下来要做的就是模拟整个过程。设现在甲的位置是Pa，刚经过编号为Sa的拐点； 乙同理。 那么我们只需要谁先到达拐点，在这个时间点之前的问题其实就是问题的简化版。 求解完后要分别更新甲和乙的位置，如果正好到达下一个拐点，还要更新Sa或Sb。 时间复杂度O(n) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 100;const double eps = 1e-10;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double DistanceToSegment(Point P, Point A, Point B) &#123; if (A == B) return Length(P - A); Vec v1 = B - A, v2 = P - A, v3 = P - B; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;Point a[maxn], b[maxn];double Min, Max;void update(Point P, Point A, Point B) &#123; Min = min(Min, DistanceToSegment(P, A, B)); Max = max(Max, Length(P - A)); Max = max(Max, Length(P - B));&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T, kase = 1; scanf("%d", &amp;T); while (T--) &#123; int A, B; scanf("%d%d", &amp;A, &amp;B); for (int i = 0; i &lt; A; i++) scanf("%lf%lf", &amp;a[i].x, &amp;a[i].y); for (int i = 0; i &lt; B; i++) scanf("%lf%lf", &amp;b[i].x, &amp;b[i].y); double LenA = 0, LenB = 0; for (int i = 0; i &lt; A - 1; i++) LenA += Length(a[i + 1] - a[i]); for (int i = 0; i &lt; B - 1; i++) LenB += Length(b[i + 1] - b[i]); int Sa = 0, Sb = 0; Point Pa = a[0], Pb = b[0]; Min = 1e9, Max = 1e-9; while (Sa &lt; A - 1 &amp;&amp; Sb &lt; B - 1) &#123; double La = Length(a[Sa + 1] - Pa); double Lb = Length(b[Sb + 1] - Pb); double T = min(La / LenA, Lb / LenB); // 速度假设为LenA，LenB Vec Va = (a[Sa + 1] - Pa) / La * T * LenA; // 位移向量 Vec Vb = (b[Sb + 1] - Pb) / Lb * T * LenB; update(Pa, Pb, Pb + Vb - Va); Pa = Pa + Va; Pb = Pb + Vb; if (Pa == a[Sa + 1]) Sa++; if (Pb == b[Sb + 1]) Sb++; &#125; printf("Case %d: %.0f\n", kase++, Max - Min); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uvalive3263-That Nice Euler Circuits-欧拉定理]]></title>
    <url>%2F2018%2F08%2F02%2Fuvalive3263-That-Nice-Euler-Circuits-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[题意平面上有一个包含n个端点的一笔画，第n个端点总是与第一个端点重合，因此图案是一条闭合的折线。线段之间可以相交，但是不会重叠。求这些线段将平面分成几个部分？ 分析欧拉定理：顶点数 + 面数 = 边数 + 2 那么只要求顶点数和边数即可。 需要注意的是： 对于重复的点不能算，比如三线共点 点增加了，边也会增加。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double eps = 1e-10;const int maxn = 305;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;bool OnSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;Point p[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, kase = 1; while (~scanf("%d", &amp;n)) &#123; if (!n) break; set&lt;Point&gt; vtx; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); vtx.insert(p[i]); &#125; for (int i = 0; i &lt; n - 1; i++) &#123; for (int k = i + 1; k &lt; n - 1; k++) &#123; if (SegmentProperIntersection(p[i], p[i + 1], p[k], p[k + 1])) &#123; vtx.insert(GetLineItersection(p[i], p[i + 1] - p[i], p[k], p[k + 1] - p[k])); &#125; &#125; &#125; int e = n - 1; for (auto i : vtx) &#123; for (int k = 0; k &lt; n - 1; k++) &#123; if (OnSegment(i, p[k], p[k + 1])) e++; &#125; &#125; int ans = e + 2 - vtx.size(); printf("Case %d: There are %d pieces.\n", kase++, ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uva11178-Morley's Theorem角平分线交点]]></title>
    <url>%2F2018%2F08%2F02%2Fuva11178-Morley-s-Theorem%E8%A7%92%E5%B9%B3%E5%88%86%E7%BA%BF%E4%BA%A4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题意Morley定理：作三角形ABC每个内角的三等分线，相交成三角形DEF，则DEF是等边三角形。 任务是根据A，B，C三点的位置，确定D，E，F的位置。 保证A，B，C面积非0，且按逆时针给出。 分析 求出一个内角 将某条边旋转1/3倍的内角 然后求两直线交点 代码复用要好好学学 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;Vec Rotate(Vec A, double rad) &#123; // 向量绕起点逆时针旋转rad return Vec(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;// 调用前要确保直线P + tv和Q + tw有唯一交点，当且仅当Cross(v,w)!=0Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;Point p[5];Point GetP(int a, int b, int c) &#123; Vec v1 = p[c] - p[b]; double ang = Angle(p[a] - p[b], v1); v1 = Rotate(v1, ang / 3); Vec v2 = p[a] - p[c]; ang = Angle(p[b] - p[c], v2); v2 = Rotate(v2, 2 * ang / 3); return GetLineItersection(p[b], v1, p[c], v2);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; for (int i = 0; i &lt; 3; i++) &#123; scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); &#125; Point D, E, F; D = GetP(0, 1, 2); E = GetP(1, 2, 0); F = GetP(2, 0, 1); printf("%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\n", D.x, D.y, E.x, E.y, F.x, F.y); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
        <category>二维几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算几何基础]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础知识极坐标在平面内取一个定点$O$，叫极点，引一条射线$Ox$，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点$M$，用$ρ$表示线段$OM$的长度（有时也用$r$表示），$θ$表示从$Ox$到$OM$的角度，$ρ$叫做点$M$的极径，$θ$叫做点$M$的极角，有序数对$(ρ,θ)$就叫点$M$的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，$M$的极径坐标单位为$1$（长度单位），极角坐标单位为$rad$（或°）。 与直角坐标的变换 $r = \sqrt{y^2 + x^2}$ $\theta = atan2(y,x)$ atan2是已将象限纳入考量的反正切函数,单位是弧度。 三角形余弦公式$c = \sqrt{a^2 + b^2 - 2ab\times cos(C)}$ $cos(C) = \frac{a^2 + b^2 - c^2}{2ab}$ 正弦公式$\frac{a}{sin(A)} = \frac{b}{sin(B)} = \frac{c}{sin(C)} = 2R = D$ 向量的减法$\vec{c} = \vec{a} + (-\vec{b})$ 数量积(点乘)$\vec{a} \cdot \vec{b} = |\vec{a}| \cdot |\vec{b}| \cdot cos(\theta) = a_x \cdot b_x + a_y \cdot b_y$ $0 \leq \theta \leq \pi $ 作用： 可以用来求两向量的夹角。 $\vec{a} \cdot \vec{b} &lt; 0$ 夹角在$[90,180)$度内 $\vec{a} \cdot \vec{b} = 0$ 两向量垂直 $\vec{a} \cdot \vec{b} &gt; 0$ 夹角在$[0,90)$度内 向量积(叉积)简单地说，两个向量$\vec{v}$和$\vec{w}$的叉积等于$\vec{v}$和$\vec{w}$组成的三角形的有向面积的两倍。 如果$\vec{w}$在$\vec{v}$的左边，那么$cross(v,w) &gt; 0$ $|\vec{a} \times \vec{b}| = x_a \times y_b - x_b \times y_a$ $\vec{c} = \vec{a} \times \vec{b}$ $|\vec{c}| = |\vec{a}| \cdot |\vec{b}| \cdot sin(\theta)$ $0 \leq \theta \leq \pi $ 其中$\vec{c}$垂直于$\vec{a},\vec{b}$所组成的平面，满足右手定则。 几何意义： 以$\vec{a},\vec{b}$为棱的平行四边形面积。 那么多边形面积就可以通过叉积求出。 一般意义上，竖直向上的符号为正。 $\vec{a} \times \vec{b} = \left| \begin{array}{ccc}\vec{i} &amp; \vec{j} &amp; \vec{k}\\a_x &amp; a_y &amp; a_z\\b_x &amp; b_y &amp; b_z\\\end{array} \right|= (a_y \cdot b_z - a_z \cdot b_y) \cdot \vec{i} + (-a_x \cdot b_z + a_z \cdot b_x) \cdot \vec{j} + (a_x \cdot b_y - a_y \cdot b_x) \cdot \vec{k}$ 混合积$\vec{a} \cdot (\vec{b} \times \vec{c}) = \left| \begin{array}{ccc}a_x &amp; a_y &amp; a_z\\b_x &amp; b_y &amp; b_z\\c_x &amp; c_y &amp; c_z\\\end{array} \right|$ 证明： 几何意义为： 以$\vec{a},\vec{b},\vec{c}$为棱的平行六面体的体积。 Pick定理设以整数点为顶点的多边形的面积为S，多边形内部的整数点数为N，多边形边界上的整数点为L，则 S = L/2 + N - 1. 重要定理三点共线定理已知O是AB所在直线外一点，若$\vec{OC} = \lambda \cdot \vec{OA} + \mu \cdot \vec{OB}$, 且$\lambda + \mu = 1$，则A，B，C三点共线。 实际判断其实是用： $\vec{AB} \times \vec{AC} = 0 $，则三点共线 重心判断式在$\Delta ABC$中，若$\vec{GA} + \vec{GB} + \vec{GC} = 0$，则G为$\Delta ABC$的重心。 重心： 三边中线的交点。 垂心判断式在$\Delta ABC$中，若$\vec{HA} \cdot \vec{HB} = \vec{HB} \cdot \vec{HC} = \vec{HC} \cdot \vec{HA}$，则H为$\Delta ABC$的垂心。 将三角形分成了面积相等的三块。 外心判断式在$\Delta ABC$中，若$\vec{OA} = \vec{OB} = \vec{OC} $，则O为$\Delta ABC$的外心。 外心： 垂直平分线的交点。 模板详解判断点是否在线段（直线）上其实就是三点共线的问题，解决办法是判断$\vec{AC} \times \vec{AB} = 0$. 但因为是线段，所以要判断横纵坐标的相应位置。 判断两线段是否相交这里有两个实验：第一个是快速排斥实验，通过判断相应矩形是否相交来快速得到两线段是否相交。 但可以发现，这不能包含所有情况，因为两个矩形相交不一定能推出两条线段相交。 因此就有了跨立实验。 跨立，顾名思义，就是一条线所在的直线能够切开另一条线段。 如上面两个图，Q1，Q2所在直线可以跨立P1，P2线段； 但P1，P2所在直线无法跨立Q1，Q2线段， 因此两条线段不相交。 所以判断两条线段相交需要同时满足两条线段互相跨立的条件。 判断点在多边形中射线法： 设要判断的点为P. 以P点为起点，水平向左做一条射线，根据射线与多边形的交点个数来判断P是否在多边形内部。 如果交点个数是奇数的话，说明P点在多边形内部。 但是！ 会有一些特殊情况：比如图(b),若射线与多边形的交点是顶点的话，需要判断。 总的来说，步骤如下： 遍历多边形的每一条边： 如果P在多边形边上，可直接判断。 如果射线与多边形的边重合，那么可以直接忽略。 如果射线和多边形的一边有交点，那么交点数加一。(不包括顶点) 如果交点是顶点，那么如果这个顶点是该线段上纵坐标较大的顶点，则交点数加一。 否则不作数。 判断线段是否在多边形内不会 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#define zero(x) ((fabs(x) &lt; eps ? 1 : 0))#define sgn(x) (fabs(x) &lt; eps ? 0 : ((x) &lt; 0 ? -1 : 1))struct point&#123; double x, y; point(double a = 0, double b = 0) &#123; x = a, y = b; &#125; point operator-(const point&amp; b) const &#123; return point(x - b.x, y - b.y); &#125; point operator+(const point&amp; b) const &#123; return point(x + b.x, y + b.y); &#125; // 两点是否重合 bool operator==(point&amp; b) &#123; return zero(x - b.x) &amp;&amp; zero(y - b.y); &#125; // 点积(以原点为基准) double operator*(const point&amp; b) const &#123; return x * b.x + y * b.y; &#125; // 叉积(以原点为基准) double operator^(const point&amp; b) const &#123; return x * b.y - y * b.x; &#125; // 绕P点逆时针旋转a弧度后的点 point rotate(point b, double a) &#123; double dx, dy; (*this - b).split(dx, dy); double tx = dx * cos(a) - dy * sin(a); double ty = dx * sin(a) + dy * cos(a); return point(tx, ty) + b; &#125; // 点坐标分别赋值到a和b void split(double&amp; a, double&amp; b) &#123; a = x, b = y; &#125;&#125;;struct line&#123; point s, e; line() &#123;&#125; line(point ss, point ee) &#123; s = ss, e = ee; &#125;&#125;;double dist(point a, point b) &#123; return sqrt((a - b) * (a - b)); &#125;// &lt;0, *&gt; 表示重合; &lt;1, *&gt; 表示平行; &lt;2, P&gt; 表示交点是P;pair&lt;int, point&gt; spoint(line l1, line l2)&#123; point res = l1.s; if (sgn((l1.s - l1.e) ^ (l2.s - l2.e)) == 0) return make_pair(sgn((l1.s - l2.e) ^ (l2.s - l2.e)) != 0, res); double t = ((l1.s - l2.s) ^ (l2.s - l2.e)) / ((l1.s - l1.e) ^ (l2.s - l2.e)); res.x += (l1.e.x - l1.s.x) * t; res.y += (l1.e.y - l1.s.y) * t; return make_pair(2, res);&#125;// 快速排斥实验 + 跨立实验bool segxseg(line l1, line l2)&#123; return max(l1.s.x, l1.e.x) &gt;= min(l2.s.x, l2.e.x) &amp;&amp; max(l2.s.x, l2.e.x) &gt;= min(l1.s.x, l1.e.x) &amp;&amp; max(l1.s.y, l1.e.y) &gt;= min(l2.s.y, l2.e.y) &amp;&amp; max(l2.s.y, l2.e.y) &gt;= min(l1.s.y, l1.e.y) &amp;&amp; sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e-l1.e) ^ (l1.s - l1.e)) &lt;= 0 &amp;&amp; sgn((l1.s - l2.e) ^ (l2.s - l2.e)) * sgn((l1.e-l2.e) ^ (l2.s - l2.e)) &lt;= 0;&#125;//l1是直线,l2是线段bool segxline(line l1, line l2)&#123; return sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e - l1.e) ^ (l1.s - l1.e)) &lt;= 0;&#125;point pointtoline(point P, line L)&#123; point res; double t = ((P - L.s) * (L.e - L.s)) / ((L.e - L.s) * (L.e - L.s)); res.x = L.s.x + (L.e.x - L.s.x) * t, res.y = L.s.y + (L.e.y - L.s.y) * t; return dist(P, res);&#125;point pointtosegment(point p, line l)&#123; point res; double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s)); if (t &gt;= 0 &amp;&amp; t &lt;= 1) res.x = l.s.x + (l.e.x - l.s.x) * t, res.y = l.s.y + (l.e.y - l.s.y) * t; else res = dist(p, l.s) &lt; dist(p, l.e) ? l.s : l.e; return res;&#125;bool PointOnSeg(point p, line l)&#123; return sgn((l.s - p) ^ (l.e-p)) == 0 &amp;&amp; sgn((p.x - l.s.x) * (p.x - l.e.x)) &lt;= 0 &amp;&amp; sgn((p.y - l.s.y) * (p.y - l.e.y)) &lt;= 0;&#125;double area(point p[], int n)&#123; double res = 0; for (int i = 0; i &lt; n; i++) res += (p[i] ^ p[(i + 1) % n]) / 2; return fabs(res);&#125;// 点形成一个凸包, 而且按逆时针排序(如果是顺时针把里面的&lt;0改为&gt;0)// 点的编号 : [0,n)// -1 : 点在凸多边形外// 0 : 点在凸多边形边界上// 1 : 点在凸多边形内int PointInConvex(point a, point p[], int n)&#123; for (int i = 0; i &lt; n; i++) if (sgn((p[i] - a) ^ (p[(i + 1) % n] - a)) &lt; 0) return -1; else if (PointOnSeg(a, line(p[i], p[(i + 1) % n]))) return 0; return 1;&#125;// 射线法,poly[]的顶点数要大于等于3,点的编号0~n-1// -1 : 点在多边形外// 0 : 点在多边形边界上// 1 : 点在多边形内int PointInPoly(point p, point poly[], int n)&#123; int cnt; line ray, side; cnt = 0; ray.s = p; ray.e.y = p.y; ray.e.x = -100000000000.0; // -INF,注意取值防止越界 for (int i = 0; i &lt; n; i++) &#123; side.s = poly[i], side.e = poly[(i + 1) % n]; if (PointOnSeg(p, side)) return 0; //如果平行轴则不考虑 if (sgn(side.s.y - side.e.y) == 0) continue; if (PointOnSeg(sid e.s, ray)) cnt += (sgn(side.s.y - side.e.y) &gt; 0); else if (PointOnSeg(side.e, ray)) cnt += (sgn(side.e.y - side.s.y) &gt; 0); else if (segxseg(ray, side)) cnt++; &#125; return cnt % 2 == 1 ? 1 : -1;&#125;// 线段上整数点个数int OnSegment(line l) &#123; return __gcd(fabs(l.s.x - l.e.x), fabs(l.s.y - l.e.y)) + 1; &#125;//多边形边界上整数点个数int OnEdge(point p[], int n)&#123; int i, ret = 0; for (i = 0; i &lt; n; i++) ret += __gcd(fabs(p[i].x - p[(i + 1) % n].x), fabs(p[i].y - p[(i + 1) % n].y)); return ret;&#125;//多边形内部整数点个数int InSide(point p[], int n)&#123; int i, area = 0; for (i = 0; i &lt; n; i++) area += p[(i + 1) % n].y * (p[i].x - p[(i + 2) % n].x); return (fabs(area) - OnEdge(n, p)) / 2 + 1;&#125;point waixin(point a, point b, point c)&#123; double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2; double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2; double d = a1 * b2 - a2 * b1; return point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 刘老师的板子const double eps = 1e-10;struct Point &#123; double x, y; Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;&#125;;typedef Point Vec;Vec operator+(Vec A, Vec B) &#123; return Vec(A.x + B.x, A.y + B.y); &#125;Vec operator-(Vec A, Vec B) &#123; return Vec(A.x - B.x, A.y - B.y); &#125;Vec operator*(Vec A, double p) &#123; return Vec(A.x * p, A.y * p); &#125;Vec operator/(Vec A, double p) &#123; return Vec(A.x / p, A.y / p); &#125;bool operator&lt;(const Point&amp; a, const Point&amp; b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);&#125;int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;bool operator==(const Point&amp; a, const Point&amp; b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;&#125;double PolarAngle(Point A) &#123; return atan2(A.y, A.x); &#125; // 极角double Dot(Vec A, Vec B) &#123; return A.x * B.x + A.y * B.y; &#125; // 点积double Length(Vec A) &#123; return sqrt(Dot(A, A)); &#125; // 向量长度double Angle(Vec A, Vec B) &#123; // 两向量夹角 return acos(Dot(A, B) / Length(A) / Length(B));&#125;double Cross(Vec A, Vec B) &#123; return A.x * B.y - A.y * B.x; &#125;double Area2(Point A, Point B, Point C) &#123; // 平行四边形面积 return Cross(B - A, C - A);&#125;Vec Rotate(Vec A, double rad) &#123; // 向量绕起点逆时针旋转rad return Vec(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;// 向量的单位法线，即左转90度后把长度归一化（要确保A不是零向量）Vec Normal(Vec A) &#123; double L = Length(A); return Vec(-A.y / L, A.x / L);&#125;// 两直线交点，调用前要确保直线P + tv和Q + tw有唯一交点，当且仅当Cross(v,w)!=0Point GetLineItersection(Point P, Vec v, Point Q, Vec w) &#123; Vec u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t;&#125;// P 到直线AB的距离double DistanceToLine(Point P, Point A, Point B) &#123; Vec v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2) / Length(v1)); // 如果不取绝对值，得到的是有向距离&#125;double DistanceToSegment(Point P, Point A, Point B) &#123; if (A == B) return Length(P - A); Vec v1 = B - A, v2 = P - A, v3 = P - B; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;// 求点与线段距离的交点Point GetLineProjection(Point P, Point A, Point B) &#123; Vec v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125;// 规范相交： 两线段只有一个交点，且不在任何一条线段的断点bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;// 点是否在线段上(不包括端点)bool OnSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;&#125;// 多边形的有向面积double PolygonArea(Point* p, int n) &#123; double area = 0; for (int i = 1; i &lt; n - 1; i++) area += Cross(p[i] - p[0], p[i + 1] - p[0]); return area / 2;&#125; 新模板from dls, jls. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/*inline int sign(int x) &#123; return x &lt; 0 ? -1 : x &gt; 0; &#125;inline int cmp(int x, int y) &#123; return sign(x - y); &#125;struct Point &#123; int x, y; bool operator&lt;(const Point &amp;rhs) const &#123; if (x == rhs.x) return y &lt; rhs.y; return x &lt; rhs.x; &#125; bool operator==(const Point &amp;rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125;&#125;;*/const double eps = 1e-8;inline int sign(double a) &#123; return a &lt; -eps ? -1 : a &gt; eps; &#125;inline int cmp(double a, double b) &#123; return sign(a - b); &#125;struct Point &#123; double x, y; // 是否在第一象限 bool quad() const &#123; return sign(y) == 1 || (sign(y) == 0 &amp;&amp; sign(x) &gt;= 0); &#125; Point operator+(const Point &amp;rhs) const &#123; return &#123;rhs.x + x, rhs.y + y&#125;; &#125; Point operator-(const Point &amp;rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; Point operator*(double rhs) const &#123; return &#123;x * rhs, y * rhs&#125;; &#125; Point operator/(double rhs) const &#123; return &#123;x / rhs, y / rhs&#125;; &#125; bool operator&lt;(const Point &amp;rhs) const &#123; int s = cmp(x, rhs.x); if (s) return s == -1; return cmp(y, rhs.y) == -1; &#125; bool operator==(const Point &amp;rhs) const &#123; return cmp(x, rhs.x) == 0 &amp;&amp; cmp(y, rhs.y) == 0; &#125;&#125;;inline double cross(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.y - a.y * b.x;&#125;inline double cross(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; return cross(b - a, c - a);&#125;inline double dot(const Point &amp;a, const Point &amp;b) &#123; return a.x * b.x + a.y + b.y;&#125;inline double dot(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; return dot(b - a, c - a);&#125;Point intersectLL(const Point &amp;a, const Point &amp;b, const Point &amp;c, const Point &amp;d) &#123; double x = cross(c, d, a), y = -cross(c, d, b); return (a * y + b * x) / (x + y);&#125;// p1 -&gt; p2 左侧vector&lt;Point&gt; ConvexCut(const vector&lt;Point&gt; &amp;ps, Point p1, Point p2) &#123; vector&lt;Point&gt; ret; int n = ps.size(); for (int i = 0; i &lt; n; i++) &#123; auto p3 = ps[i], p4 = ps[(i + 1) % n]; int s1 = sign(cross(p1, p2, p3)), s2 = sign(cross(p1, p2, p4)); if (s1 &gt;= 0) ret.push_back(p3); if (s1 * s2 &lt; 0) ret.push_back(intersectLL(p1, p2, p3, p4)); &#125; return ret;&#125;struct Line &#123; // p[0] -&gt; p[1] Point p[2]; Point &amp;operator[](int k) &#123; return p[k]; &#125; Point dir() &#123; return p[1] - p[0]; &#125; // k 在直线左侧 bool include(Point k) &#123; return sign(cross(p[1] - p[0], k - p[0])) &gt; 0; &#125;&#125;;Point intersectLL(Line &amp;a, Line &amp;b) &#123; return intersectLL(a[0], a[1], b[0], b[1]);&#125;bool parallel(Line k1, Line k2) &#123; return sign(cross(k1.dir(), k2.dir())) == 0; &#125;bool sameDir(Line k1, Line k2) &#123; return parallel(k1, k2) &amp;&amp; sign(dot(k1.dir(), k2.dir())) == 1;&#125;bool cmpAngle(Point a, Point b) &#123; if (a.quad() != b.quad()) return a.quad() &lt; b.quad(); else return sign(cross(a, b)) &gt; 0;&#125;bool operator&lt;(Line k1, Line k2) &#123; if (sameDir(k1, k2)) return k2.include(k1[0]); return cmpAngle(k1.dir(), k2.dir());&#125;// k1 和 k2 的交点在 k3 的左侧int checkpos(Line k1, Line k2, Line k3) &#123; return k3.include(intersectLL(k1, k2));&#125;vector&lt;Line&gt; halfPlaneIS(vector&lt;Line&gt; &amp;L) &#123; // 极角排序 sort(L.begin(), L.end()); deque&lt;Line&gt; q; for (int i = 0; i &lt; L.size(); i++) &#123; if (i &amp;&amp; sameDir(L[i], L[i - 1])) continue; while (q.size() &gt; 1 &amp;&amp; !checkpos(q[q.size() - 2], q[q.size() - 1], L[i])) q.pop_back(); while (q.size() &gt; 1 &amp;&amp; !checkpos(q[1], q[0], L[i])) q.pop_front(); q.push_back(L[i]); &#125; while (q.size() &gt; 2 &amp;&amp; !checkpos(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back(); while (q.size() &gt; 2 &amp;&amp; !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front(); vector&lt;Line&gt; ans; for (int i = 0; i &lt; q.size(); i++) ans.push_back(q[i]); return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018hdu多校第三场]]></title>
    <url>%2F2018%2F07%2F30%2F2018hdu%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[A. Ascending Rating题意给定一个序列 a[1..n]，对于每个长度为 m 的连续子区间，求出区间 a 的最大值以及从左往右扫描该区间时 a 的最大值的变化次数。 $1 \leq n,m\leq 1e7$ 分析滑动窗口最大值是单调队列的经典问题，但是最大值的变化次数怎么求？ 反着扫，队列的大小就是当前区间的最大值变化次数。 为什么呢？ 因为单调队列维护的是一个递减的数列，队首是当前区间的最大值，那么从尾到首，大小是不断递增的。也就是最大值的变化次数。 所以要反过来扫才能求出结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e7 + 7;int a[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m, k, p, q, r, mod; scanf("%d%d%d%d%d%d%d", &amp;n, &amp;m, &amp;k, &amp;p, &amp;q, &amp;r, &amp;mod); for (int i = 1; i &lt;= k; i++) scanf("%d", a + i); for (int i = k + 1; i &lt;= n; i++) a[i] = (1LL * a[i - 1] * p + 1LL * q * i + r) % mod; deque&lt;pii&gt; dq; ll A = 0, B = 0; for (int i = n; i &gt;= 1; i--) &#123; while (dq.size() &amp;&amp; dq.front().second - i &gt;= m) dq.pop_front(); while (dq.size() &amp;&amp; a[i] &gt;= dq.back().first) dq.pop_back(); dq.push_back(mp(a[i], i)); if (i &lt;= n - m + 1) &#123; A += dq.front().first ^ i; B += dq.size() ^ i; &#125; &#125; printf("%lld %lld\n", A, B); &#125;&#125; C. Dynamic Graph Matching题意给定一个 n 个点的无向图，m 次加边或者删边操作。 在每次操作后统计有多少个匹配包含 k = 1, 2, …,n/2 条边。 $1\leq n\leq 10, 1 \leq m \leq 3e4$ 分析$dp[i][k]$:表示第i次操作，所覆盖集合为k的种类数. 对于加边操作12345edge (u,v)int S = (1 &lt;&lt; u) &amp; (1 &lt;&lt; v);if((k &amp; S) == S) dp[i][k] = dp[i-1][k] + dp[i-1][k ^ S]; 对于删边操作12if((k &amp; S) == S) dp[i][k] = dp[i-1][k] - dp[i-1][k ^ S]; 这样即使有重边也不用怕 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1111;const int mod = 1e9+7;int dp[2][maxn];int cnt[maxn], ans[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); char s[10]; int all = 1 &lt;&lt; n; for (int i = 0; i &lt; all; i++) &#123; dp[0][i] = dp[1][i] = 0; cnt[i] = __builtin_popcount(i); &#125; dp[0][0] = 1; for (int i = 1, u, v; i &lt;= m; i++) &#123; scanf("%s%d%d", s, &amp;u, &amp;v); u--, v--; int S = (1 &lt;&lt; u) | (1 &lt;&lt; v); if (s[0] == '+') &#123; for (int k = 0; k &lt; all; k++) &#123; dp[i &amp; 1][k] = dp[i &amp; 1 ^ 1][k]; if ((k &amp; S) == S) (dp[i &amp; 1][k] += dp[i &amp; 1 ^ 1][k ^ S]) %= mod; &#125; &#125; else &#123; for (int k = 0; k &lt; all; k++) &#123; dp[i &amp; 1][k] = dp[i &amp; 1 ^ 1][k]; if ((k &amp; S) == S) (dp[i &amp; 1][k] -= dp[i &amp; 1 ^ 1][k ^ S] - mod) %= mod; &#125; &#125; for (int k = 0; k &lt;= n; k++) ans[k] = 0; for (int k = 0; k &lt; all; k++) (ans[cnt[k]] += dp[i &amp; 1][k]) %= mod; for (int k = 2; k &lt;= n; k += 2) &#123; printf("%d%c", ans[k], k &lt; n ? ' ' : '\n'); &#125; &#125; &#125;&#125; D-Euler Function题意问第k小的n，满足$\phi(n)$为合数, $k \leq 1e9$ 分析对于$n = p_1^{k_1}p_2^{k_2}$, $\phi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)$ 可以发现除了1,2,3,4,6以外都是合数。 代码1234567891011121314151617181920212223242526272829303132333435// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; int k; scanf("%d", &amp;k); printf("%d\n", k + 4 + (k != 1)); &#125;&#125; F-Grab The Tree题意给定一棵 n 个点的树，每个点有权值。两个人玩游戏，先手需要占领若干不相邻的点，然后后手占领剩下所有点。 每个人的得分为占领的点权异或和，分高的获胜。问最优策略下游戏的结果 分析设sum为所有点权的异或和 若sum不为0，那么先手只要选择最高位为1的那个点，选一个就可以啦，然后就赢了。 如果为0，那一定是平局。 如果当前位为0，那么说明这个点权的出现次数一定为偶数次，那么Q拿奇数次，T也会拿奇数次，Q拿偶数次，T也会拿偶数次，始终是一样的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define first fi#define second se#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; ll sum = 0; int n; scanf("%d", &amp;n); for (int i = 0, x; i &lt; n; i++) &#123; scanf("%d", &amp;x); sum ^= x; &#125; for (int i = 0, u, v; i &lt; n - 1; i++) scanf("%d%d", &amp;u, &amp;v); if (!sum) printf("D\n"); else printf("Q\n"); &#125;&#125; L. Visual Cube题意画一个魔方… 分析这种题目，首先要确定关键点的坐标，然后分块作图 分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1000;char maze[maxn][maxn];int a, b, c;void solve(pii lt, pii ld, pii rt, pii rd) &#123; for (int i = 1; i &lt;= ld.first; i++) for (int k = 1; k &lt;= rt.second; k++) maze[i][k] = '.'; // center int flag = 1; for (int i = b * 2 + 1; i &lt;= ld.first; i++) &#123; for (int k = 1; k &lt;= a * 2 + 1; k++) &#123; if (flag) &#123; if (k &amp; 1) maze[i][k] = '+'; else maze[i][k] = '-'; &#125; else &#123; if (k &amp; 1) maze[i][k] = '|'; &#125; &#125; flag ^= 1; &#125; // top flag = 1; for (int i = 1; i &lt; b * 2 + 1; i++) &#123; for (int k = b * 2 + 2 - i; k &lt;= rt.second + 1 - i; k++) &#123; if (flag) &#123; if (k &amp; 1) maze[i][k] = '+'; else maze[i][k] = '-'; &#125; else &#123; if (!(k &amp; 1)) maze[i][k] = '/'; &#125; &#125; flag ^= 1; &#125; // right flag = 1; for (int k = rt.second; k &gt;= rt.second - b * 2; k--) &#123; for (int i = rt.second - k + 1; i &lt;= rt.second - k + 1 + 2 * c ; i++) &#123; if (flag) &#123; if (i &amp; 1) maze[i][k] = '+'; else maze[i][k] = '|'; &#125; else &#123; if (!(i &amp; 1)) maze[i][k] = '/'; &#125; &#125; flag ^= 1; &#125; // out for (int i = 1; i &lt;= ld.first; i++) &#123; for (int k = 1; k &lt;= rt.second; k++) printf("%c", maze[i][k]); puts(""); &#125;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); pii lt = &#123;1, 1&#125;; pii ld = &#123;c * 2 + 1 + b * 2, 1&#125;; pii rt = &#123;1, a * 2 + 1 + b * 2&#125;; pii rd = &#123;c * 2 + 1 + b * 2, a * 2 + 1 + b * 2&#125;; solve(lt, ld, rt, rd); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf600E- Lomsat gelral]]></title>
    <url>%2F2018%2F07%2F22%2Fcf600E-Lomsat-gelral%2F</url>
    <content type="text"><![CDATA[题意给一棵树，问每个节点的子树中出现颜色次数最多的颜色和。 分析因为要记录出现次数最多的颜色和，所以要有一个数组(times)来记录每个节点的子树中颜色出现最多的次数 这样的话当前的节点可以直接从其重儿子转移过来， 然后在计算其它儿子的同时进行更新。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;ll col[maxn], cnt[maxn], sz[maxn], ans[maxn], times[maxn];bool vis[maxn], bigc[maxn];vector&lt;int&gt; G[maxn];ll szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void add(int u, int fa, int x, ll &amp;mx, ll &amp;foo) &#123; cnt[col[u]] += x; if (x != -1) &#123; if (mx &lt; cnt[col[u]]) &#123; mx = cnt[col[u]]; foo = col[u]; &#125; else if (mx == cnt[col[u]]) &#123; foo += col[u]; &#125; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !bigc[v]) add(v, u, x, mx, foo);&#125;void dfs(int u, int fa, bool keep) &#123; ll mx = -1, bc = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) &#123; mx = sz[v]; bc = v; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bc) dfs(v, u, 0); mx = 0; ll foo = 0; if (bc != -1) &#123; dfs(bc, u, 1); bigc[bc] = 1; mx = times[bc]; foo = ans[bc]; &#125; add(u, fa, 1, mx, foo); ans[u] = foo; times[u] = mx; if (bc != -1) bigc[bc] = 0; if (!keep) add(u, fa, -1, mx, foo);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; G[i].clear(); cin &gt;&gt; col[i]; &#125; for (int i = 0, u, v; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].pb(v); G[v].pb(u); &#125; clr(vis, 0); szdfs(1, -1); dfs(1, -1, 0); for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>优雅的暴力</category>
        <category>树上启发式合并(Dsu-on-tree)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dsu-on-tree]]></title>
    <url>%2F2018%2F07%2F22%2FDsu-on-tree-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[简介启发式合并应该比较熟悉，并查集合并的时候为了防止退化，会让高度小的向高度大的合并，这也算一种启发式合并。 树上的启发式合并就是：假设我们现在想知道一棵树上所有节点的子树信息，那么在递归计算的过程中，可以选择保留重儿子的子树上的信息，然后再去重新计算其余儿子的子树信息。这样会使得复杂度由$O(n^2)$降为$O(nlog(n))$ 推荐博客 例题及模板给一棵树，每个节点都有一个颜色，每次查询问某棵子树上颜色为c的节点数。 123456789101112131415161718192021222324252627282930313233343536373839// 推荐使用vector&lt;int&gt; *vec[maxn], G[maxn];int cnt[maxn], sz[maxn], col[maxn];bool vis[maxn], bigc[maxn];int szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void add(int u, int fa, int x) &#123; cnt[col[u]] += x; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !bigc[v]) add(v, u, x);&#125;void dfs(int u, int fa, bool keep) &#123; int mx = -1, bc = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) &#123; mx = sz[v]; bc = v; &#125; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bc) dfs(v, u, 0); // run a dfs on small childs and clear them from cnt if (bc != -1) &#123; dfs(bc, u, 1); bigc[bc] = 1; &#125; // bigChild marked as big and not cleared from cnt add(u, fa, 1); // now cnt[c] is the number of vertices in subtree of vertex v that has // color c. You can answer the queries easily. if (bc != -1) bigc[bc] = 0; if (!keep) add(u, fa, -1);&#125; 1234567891011121314151617181920212223242526272829303132333435// 多组数据就不要用了...指针可能还要delet？vector&lt;int&gt; *vec[maxn], G[maxn];int cnt[maxn], sz[maxn], col[maxn];bool vis[maxn];int szdfs(int u, int fa) &#123; sz[u] = vis[u] = 1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; !vis[v]) sz[u] += szdfs(v, u); return sz[u];&#125;void dfs(int u, int fa, bool keep) &#123; int mx = -1, bigChild = -1; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; sz[v] &gt; mx) mx = sz[v], bigChild = v; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bigChild) dfs(v, u, 0); if (bigChild != -1) dfs(bigChild, u, 1), vec[u] = vec[bigChild]; else vec[u] = new vector&lt;int&gt;(); vec[u]-&gt;push_back(u); cnt[col[u]]++; for (auto &amp;v : G[u]) if (v != fa &amp;&amp; v != bigChild) for (auto x : *vec[v]) &#123; cnt[col[x]]++; vec[u]-&gt;push_back(x); &#125; // now (*cnt[v])[c] is the number of vertices in subtree of vertex v that // has color c. You can answer the queries easily. // note that in this step *vec[v] contains all of the subtree of vertex v. if (keep == 0) for (auto &amp;v : *vec[u]) cnt[col[v]]--;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>优雅的暴力</category>
        <category>树上启发式合并(Dsu-on-tree)</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[普通莫队如果区间 $[l,r]$ 的答案可以在 $O(1)$ 的时间复杂度内转移到 $[l+1,r], [l-1,r], [l, r+1], [l, r-1]$，那么可以通过将区间按平方分块来降低复杂度。 将每个询问按左端点所在块号进行排序，同一个块内的按照右端点进行排序。这样一共只有 $sqrt(n)$ 个块。 我们考虑处理一个块内所有询问的复杂度：假设这个块内有 $q$ 个请求。因为对于一个块内的所有询问都是按右端点进行排序的，那么我们移动右端点的复杂度就是 $O(n)$ 的，移动左端点的复杂度是 $sqrt(n) \times q$。 这也是为什么区间内要按右端点排序的原因，不然的话移动右端点的复杂度就是 $n \times q$。 对于复杂度计算，考虑每个询问都会使左端点移动 $sqrt(n)$；每计算一个块，右端点都会移动 $n$。那么总的时间复杂度就近似为 $Q \times sqrt(n) + n \times sqrt(n)$。 123456789int S = sqrt(n); // 可以根据题目适当调整struct Query&#123; int l,r,id;&#125;;bool cmp(const Query&amp; A,const Query&amp; B)&#123; if(A.l / S == B.l / S) return A.r &lt; B.r; return A.l &lt; B.l;&#125; 一道模板题：bzoj 2038 带修改莫队对于带修改操作的题目，我们要额外记录一维时间戳。那么每个询问可以表示为一个三元组 $(l,r,time)$。 那么它的转移就变成了： $(l+1,r,time)$ $(l-1,r,time)$ $(l,r+1,time)$ $(l,r-1,time)$ $(l,r,time+1)$ $(l,r,time-1)$ 然后它的分块是按照 $n^{\frac{2}{3}}$ 大小为一块，一共分成了 $n^{\frac{1}{3}}$ 块。总的时间复杂度是 $O(n^\frac{5}{3})$。 排序的第一关键字是左端点所在块号；第二关键字是右端点所在块号；第三关键字是时间。 简单证明复杂度： 对于固定的左右端点块，时间移动的复杂度为 $O(n)$，左右端点移动的复杂度为 $O(n^{\frac{2}{3}})$。 左右块的种类数是 $O(n^{\frac{1}{3} \times n^{\frac{1}{3})$。 所以最后的复杂度：$O(n^\frac{5}{3} + n^\frac{4}{3})$ 123456789101112struct Query &#123; int l, r, t, id; bool operator&lt;(const Query &amp;rhs) const &#123; if (l / S == rhs.l / S) &#123; if (r / S == rhs.r / S) return t &lt; rhs.t; else r &lt; rhs.r; &#125; return l &lt; rhs.l; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>其它算法</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018牛客多校赛第一场]]></title>
    <url>%2F2018%2F07%2F19%2F2018%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[D题意给两张简单无向图,点数都是n,G1有m1条边,G2有m2条边, 问G2有多少个子图和G1同构. $1 \leq n \leq 8$ 分析判断同构的话可以通过枚举点的映射关系,然后判断是否可行. 因为n只有8,所以可以枚举全排列. 然后对于一些自同构的图要进行一些处理(因为会多算), 另一种方法是对选取的边进行哈希,放到一个set里面,最后set的大小就是答案. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 10;pii G[maxn][maxn];int main() &#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int n, m1, m2; while (cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2) &#123; set&lt;int&gt; SET; vector&lt;int&gt; maps(n); for (int i = 0; i &lt; n; i++) maps[i] = i; clr(G, 0); vector&lt;pii&gt; edges(m1); for (int i = 0, u, v; i &lt; m1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; u--,v--; edges[i] = &#123;u,v&#125;; &#125; for (int i = 0, u, v; i &lt; m2; i++) &#123; cin &gt;&gt; u &gt;&gt; v; u--,v--; G[u][v] = G[v][u] = &#123;1,i&#125;; &#125; do &#123; int hash = 0,u,v; bool flag = true; for(auto &amp;e:edges)&#123; u = maps[e.first]; v = maps[e.second]; if(G[u][v].first == 0)&#123; flag = false; break; &#125; int i = G[u][v].second; hash |= (1 &lt;&lt; i); &#125; if(!flag) continue; SET.insert(hash); &#125; while (next_permutation(maps.begin(), maps.end())); cout &lt;&lt; SET.size() &lt;&lt; endl; &#125;&#125; E题意给一个长度为n的数列，问去掉m个数之后，不同的序列有多少个？ $1 \leq n \leq 1e5, 1 \leq a_i \leq k, 1 \leq k \leq 10, 1 \leq m \leq 10$ 分析网上看了一圈…大家都只贴了个代码，几个有文字的也只是讲了讲做题时的心路历程..这让我们小白如何是好？？ 其实看到这题有三个限制，大致就是一个三维的dp，一算$n \times a_i \times m$差不多够复杂度… $dp[n][i][j]$表示前n个数里删掉i个，剩下的序列里最后一个数是j的种类数。 考虑第i个数删还是不删 不删：$dp[n][i][j] = \sum_{t = 1}^{k} dp[n-1][i][t]$ 删：$dp[n][i+1][j] = dp[n-1][i][j]$ 要注意的是当$a[n] == a[n-1]$时，这是删或不删其实都是一样的，所以只要算其中一种情况即可。 代码里为什么j从0开始，其实j为0的意思就表示序列为空。 如果理解有误还请大佬指正， 如果有别的做法欢迎一起探讨。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int a[maxn];ll dp[2][20][20];int n, m, k;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); while (~scanf("%d%d%d", &amp;n, &amp;m, &amp;k)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", a + i); clr(dp, 0); dp[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; int u = i &amp; 1; int v = u ^ 1; clr(dp[u], 0); for (int j = 0; j &lt;= m; j++) &#123; for (int t = 0; t &lt;= k; t++) &#123; if (t != a[i]) (dp[u][j + 1][t] += dp[v][j][t]) %= mod; (dp[u][j][a[i]] += dp[v][j][t]) %= mod; &#125; &#125; &#125; ll ans = 0; int u = n &amp; 1; for (int i = 1; i &lt;= k; i++) (ans += dp[u][m][i]) %= mod; printf("%lld\n", ans); &#125;&#125; J题意长度为n的序列,Q个询问(l,r),每次询问$[1,l]\cup [r,n]$ 中有多少不同的数字 $1 \leq n,Q,a_i \leq 1e5$ 分析做法一将区间再复制一份放到尾部,这样就变成了查询$[r,n+l]$中有多少个不同的数字 然后离线树状数组. 可以发现,对于$[1,n]$的一个区间,只要查询的区间是$[i,n], i\in [1,n]$,那么它就有一个”前缀的性质”. 举例说明, 对于区间$[1,2,2,3,5]$来说,只需要记录每个数字最后一次出现的位置即可,若$a[k]$最后一次出现的位置是k,那么就在k位置加一. 上述区间得到的结果是$[1,0,1,1,1]$. 那么对于查询$[i,n]$来说,只要用1的总数减去前i-1个位置中1的个数即可. 当然如果查询的区间右断点不是$n$,那么这个做法不可行. 接下来,我们把查询离线,按右端点从小到大排序,用树状数组来维护即可. 时间复杂度$O(nlog(n))$ 做法二将区间再复制一份放到尾部,这样就变成了查询$[r,n+l]$中有多少个不同的数字 然后主席树,第i个版本维护前i个数中,每个数最后一次出现的位置.(比如某个数最后一次出现的位置是k,那么k位置的value++,这个数上一次最后出现的位置要value–) 这样我再查询区间$[l,r]$有多少不同的数时,只要查询第r个版本时$[l,r]$的和,就是答案. 但是…无情的T了…多交几次也不管用了…可能是写的丑ba 做法三1e5的话就莫队瞎搞搞… 如果超时的话多交几次也许就过了 代码做法一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;int a[maxn], last[maxn], first[maxn], bit[maxn];struct Q &#123; int l, r, id, ans;&#125;;Q q[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;void update(int p, int x, int n) &#123; while (p &lt;= n) &#123; bit[p] += x; p += lowb(p); &#125;&#125;int query(int p) &#123; int ret = 0; while (p &gt; 0) &#123; ret += bit[p]; p -= lowb(p); &#125; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", a + i), a[i + n] = a[i]; n &lt;&lt;= 1; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;q[i].l, &amp;q[i].r); q[i].l += (n &gt;&gt; 1); swap(q[i].l, q[i].r); q[i].id = i; &#125; sort(q, q + m, [](const Q&amp; A, const Q&amp; B) &#123; return A.r &lt; B.r; &#125;); clr(last, -1); clr(bit, 0); for (int i = 0, k = 1; i &lt; m; i++) &#123; int l = q[i].l; int r = q[i].r; while (k &lt;= r) &#123; if (last[a[k]] != -1) update(last[a[k]], -1, n); update(k, 1, n); last[a[k]] = k; k++; &#125; q[i].ans = query(r) - query(l - 1); &#125; sort(q, q + m, [](const Q&amp; A, const Q&amp; B) &#123; return A.id &lt; B.id; &#125;); for (int i = 0; i &lt; m; i++) printf("%d\n", q[i].ans); &#125;&#125; 做法三1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//ybmj// 如果T了就多交几次#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;double,double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5+5;int S;int a[maxn],cnt[maxn];struct P&#123; int l,r,id,ans; bool operator &lt; (const P&amp;A) const&#123; if(l / S == A.l / S) return r &gt; A.r; return l / S &lt; A.l / S; &#125;&#125;;P b[maxn]; int main()&#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; S = sqrt(n); // 如果T了就改几次 clr(cnt,0); for(int i=0;i&lt;n;i++) &#123; scanf("%d",a+i); &#125; for(int i=0;i&lt;m;i++) scanf("%d%d",&amp;b[i].l,&amp;b[i].r), b[i].id = i; sort(b,b+m); int ans = 0; int l = -1 ,r = n; for(int i=0;i&lt;m;i++)&#123; int L = b[i].l - 1; int R = b[i].r - 1; while(l &lt; L)&#123; l++; ans += cnt[a[l]] == 0; cnt[a[l]]++; &#125; while(l &gt; L)&#123; cnt[a[l]]--; ans -= cnt[a[l]] == 0; l--; &#125; while(r &lt; R)&#123; cnt[a[r]]--; ans -= cnt[a[r]] == 0; r++; &#125; while(r &gt; R)&#123; r--; ans += cnt[a[r]] == 0; cnt[a[r]]++; &#125; b[i].ans = ans; &#125; sort(b,b+m,[](const P&amp;A, const P&amp;B)&#123;return A.id &lt; B.id;&#125;); for(int i=0;i&lt;m;i++) printf("%d\n",b[i].ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>训练报告</category>
        <category>2018</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉降幂]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%2F</url>
    <content type="text"><![CDATA[欧拉降幂在模 $p$ 意义下： $$a^b \equiv \begin{cases} a ^{b \% \phi(p)} \quad gcd(a,p) = 1\\ a^b \quad gcd(a,p) \neq 1, b &lt; \phi(p) \\ a ^{b \% \phi(p) + \phi(p)} \quad gcd(a,p) \neq 1, b \geq \phi(p) \end{cases} $$ 对于 $b$ 和 $\phi(p)$ 的相对大小，可以在快速幂的过程中判断。 例题题目链接 题意： 计算 $a^{a^{a^{…}}} \% m $ 的值， 一共有 $b$ 个 $a$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], phi[maxn];void CalPhi() &#123; memset(vis, 0, sizeof(vis)); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;/* 快速幂的时候更改取模方式。 保证在 a^b &lt; p 的时候返回 a^b；在 a^b &gt;=p，返回 a^b % p + p。*/#define Mod(x, p) (x &lt; p ? x : x % p + p);ll Pow(ll a, ll b, ll p) &#123; ll ret = 1; bool ok = false; while (b) &#123; if (b &amp; 1) ret = Mod(ret * a, p); a = Mod(a * a, p); b &gt;&gt;= 1; &#125; return Mod(ret, p);&#125;// --------------------------------------------------------ll cal(int a, int b, int p) &#123; if (b == 1 || p == 1) return a &lt; p ? a : a % p + p; return Pow(a, cal(a, b - 1, phi[p]), p);&#125;int main() &#123; CalPhi(); int T; scanf("%d", &amp;T); while (T--) &#123; int a, b, m; scanf("%d%d%d", &amp;a, &amp;b, &amp;m); if (!b) &#123; printf("%d\n", 1 % m); continue; &#125; ll ans = cal(a, b, m) % m; printf("%lld\n", ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉降幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛22-E-简单数据结构1]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B22-E-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841%2F</url>
    <content type="text"><![CDATA[题意给一个长为n的序列，m次操作，每次操作： $[l,r]$ 加 $x$ 对于$[l,r]$,查询$a[l] ^ {a[l+1] ^ {a[l+2]…}} mod \ P$分析这个欧拉函数的取模好迷啊… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e7+5;ll diff[maxn];#define Mod(x,p) x &lt; p ? x : x % p + pbool vis[maxn];int prime[maxn], phi[maxn];void init() &#123; // 线性筛预处理欧拉函数 clr(vis, 0); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;ll my_pow(ll a,ll b,ll mod)&#123; ll ret = 1; while(b)&#123; if(b &amp; 1) ret = Mod(ret * a,mod); a = Mod(a * a,mod); b &gt;&gt;= 1; &#125; return Mod(ret,mod);&#125;inline ll lowb(ll x) &#123; return x &amp; (-x); &#125;inline void update(int l, int r, ll val, int n) &#123; for (ll i = l; i &lt;= n; i += lowb(i)) diff[i] += val; for (ll i = r + 1; i &lt;= n; i += lowb(i)) diff[i] -= val;&#125;inline ll query(int l, int r, ll p) &#123; ll ret = 0; for (ll i = l; i &gt; 0; i -= lowb(i)) ret += diff[i]; if (l == r || p == 1) return Mod(ret, p); return my_pow(Mod(ret,p), query(l + 1, r, phi[p]), p);&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; init(); while (~scanf("%d%d",&amp;n,&amp;m)) &#123; ll foo; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld",&amp;foo); update(i, i, foo, n); &#125; ll l, r, w, p, op; for (int i = 0; i &lt; m; i++) &#123; scanf("%lld",&amp;op); if (op == 1) &#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;w); update(l, r, w, n); &#125; else &#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;p); printf("%lld\n",query(l,r,p) % p); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉降幂</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数]]></title>
    <url>%2F2018%2F07%2F15%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义$\phi(n)$: 小于n的正整数中与n互质的个数$(\phi(1) = 1)$ 欧拉函数是积性函数 通式：$\phi(n) = x \prod^{n}_{i=1}(1 - \frac{1}{p_i})$ $p_i$为n的质因子 对于$n = p^k$，p为质数。 $\phi(n) = p^k - p^{k-1} = p^{k-1} (p - 1)$ 因为欧拉函数是积性函数 对于$n = p_1^{k_1}p_2^{k_2}$, $\phi(n) = p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)$ 性质 若n为质数,则$\phi(n) = n-1$ 一个数的质因子之和为$\frac{\phi(n) \times n}{2}$ 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 求单个Eular函数map&lt;ll, ll&gt; Eular; //记忆化ll eular(ll n) &#123; ll &amp;ret = Eular[n]; if (ret) return ret; ret = n; for (ll i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; ret -= ret / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ret -= ret / n; return ret;&#125;// 线性筛 (同时得到欧拉函数和素数表)const int maxn = 1e7 + 5;bool vis[maxn];int prime[maxn], phi[maxn];void init() &#123; clr(vis, 0); phi[1] = 1; int tot = 0; for (int i = 2; i &lt; maxn; i++) &#123; if (!vis[i]) &#123; prime[tot++] = i; phi[i] = i - 1; &#125; for (int k = 0; k &lt; tot &amp;&amp; 1LL * i * prime[k] &lt; maxn; k++) &#123; vis[i * prime[k]] = 1; if (i % prime[k] == 0) &#123; phi[i * prime[k]] = phi[i] * prime[k]; break; &#125; phi[i * prime[k]] = phi[i] * (prime[k] - 1); &#125; &#125;&#125;// 打表 (太慢了不要用)const maxn = 1e6 + 5;void getEular() &#123; clr(eular, 0); eular[1] = 1; for (ll i = 2; i &lt; maxn; i++) &#123; if (!eular[i]) for (ll k = i; k &lt; maxn; k += i) &#123; if (!eular[k]) eular[k] = k; eular[k] = eular[k] / i * (i - 1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>欧拉函数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划的优化方法]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单调队列优化对于状态是一维,转移也是一维的dp, 可以用单调队列进行优化. $dp[i] = min( A(i) + B(k) ) , k \in [l,i-1]$ 那么可以用一个单调队列来维护$B(k)$, 这样可以把复杂度降到O(n) 斜率优化问题： 设 $f(i) = max{s[i] \times x[k] + y[k]}, k \in [1,i-1]$, 现在要求出所有$f(i), i \in [1,n]$ 考虑两个决策 $j$ 和 $k$ （$j &lt; k$），如果 $k$ 比 $j$ 优，则 $$s[i] \times x[j] + y[j] \leq s[i] \times x[k] + y[k]$$ 化简得: $$\frac{y_j - y_k}{x_k - x_j} \leq s_i$$ 这里假设 $x_k &gt; x_j$ （不然需要变号） 不等式左边可以理解为一个斜率，我们把它设为$slope(j,k)$ 可以发现，如果 $slope(q[r-1],q[r]) \geq slope(q[r],i)$，那么当前者成立时，后者必定成立。 即 $q[r]$ 决策优于 $q[r-1]$ 决策时， $i$ 必然优于 $q[r]$，所以 $q[r]$ 就没有存在的必要了。因此我们可以用一个斜率单调递增的队列来维护所有决策点。 每次决策的时候，只要在队列中找到满足下面条件的元素进行转移即可： $$\begin{cases} slope(q[p-1],q[p]) \leq s[i]\\ slope(q[p],q[p+1]) &gt; s[i] \end{cases}$$ 因为队列是按斜率单调递增的，因此我们可以去二分这个决策点。 1234567891011121314151617int l = 1, r = 1;q[l] = 0; // 0 这个决策点要赋初值for (int i = 1; i &lt;= n; i++) &#123; int p, L = l, R = r; while (L &lt;= R) &#123; int mid = L + R &gt;&gt; 1; if (slope(q[mid - 1], q[mid]) &lt;= s[i]) &#123; p = mid; L = mid + 1; &#125; else R = mid - 1; &#125; // q[p] 为决策点 while (l &lt; r &amp;&amp; slope(q[r - 1], q[r]) &gt;= slope(q[r], i)) r--; q[r] = i;&#125;// slope的比较一般写成交叉相乘的形式 特别的对于 $s[i]$ 是单调不降的情况： 因为当 $slope(q[l], q[l+1]) \leq s[i]$ 时，必然有 $slope(q[l], q[l+1]) &lt; s[i+1]$。因此 $q[l+1]$ 这个决策将会永远优于 $q[l]$ 这个决策。因此 $q[l]$ 就没有存在的必要了。 因此我们可以将转移的复杂度从上面的 $O(\log(n))$ 优化为均摊 $O(1)$。 每次决策的时候，如果对于队头元素有 $slope(q[l], q[l+1]) \leq s[i]$，这说明 $q[l+1]$ 比 $q[l]$ 优，我们就可以把 $q[l]$ 移出队列。（如果 $s[i]$ 不是单调的，就不可以移出队列！） 每次向队列加入新的元素时，如果有 $slope(q[r-1],q[r]) \geq slope(q[r], i)$，那么说明若 $q[r]$ 比 $q[r-1]$ 优，那么 $i$ 一定比 $q[r]$ 优，所以去 $q[r]$ 就没有存在的必要，因此可以把 $q[r]$ 移除队列。 123456789int l = 1, r = 1;q[l] = 0; // 0 这个决策点要赋初值for (int i = 1; i &lt;= n; i++) &#123; while (l &lt; r &amp;&amp; slope(q[l], q[l + 1]) &lt;= s[i]) l++; // q[l] 为决策点 while (l &lt; r &amp;&amp; slope(q[r - 1], q[r]) &gt;= slope(q[r], i)) r--; q[r] = i;&#125;// slope的比较一般写成交叉相乘的形式]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NCPC2017-A-Airport Coffee 单调队列优化dp]]></title>
    <url>%2F2018%2F07%2F15%2FNCPC2017-A-Airport-Coffee-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[题意一个人要走一段长度为l的路,中间有n个咖啡店,给你每个咖啡店的位置. 不喝咖啡时速度为a,喝咖啡时速度为b. 买咖啡不需要时间,买了咖啡之后走t秒后就开始喝咖啡了,每杯咖啡会喝r秒. 最多可以同时拥有一杯咖啡. 问在最短时间内走完这条路需要经过哪些咖啡店? 分析设$dp[i]$为到第i个的咖啡店并买咖啡的最短时间 $$dp[i] = min { dp[k] + cost(i,k) }, k \in [0,i-1]$$ $cost(i,k)$ 有三种情况 $$\begin{cases} (\frac{-pos[k]}{a} + dp[k])+ \frac{pos[i]}{a} \quad {a[i] - a[k] &lt; a \times t }\\ (\frac{b\times t - a\times t - pos[k]}{b} + dp[k]) + \frac{pos[i]}{b} \quad {a\times t \leq a[i] - a[k] \leq a\times t + b\times r}\\ (\frac{a\times r - b\times r - pos[k]}{a} + dp[k]) + \frac{pos[i]}{a} \quad {a\times t + b\times r &lt; a[i] - a[k]} \end{cases} $$ $$\begin{cases} x_1 = x_{1,0} + \frac{a_2}{(a_1,a_2)}\times t\\ {x_2 = x_{2,0} - \frac{a_1}{(a_1,a_2)}\times t} \end{cases}$$ 发现只要维护三个单调队列即可, 但是实际上只需要维护中间那个. 对于第一种情况,他在上一个店里买了咖啡,到当前店的时候还没开始喝,那么他必然在当前店不会再买咖啡 对于第三种情况,因为咖啡作用完之后还需要再走一段距离,所以这段距离应该越近越好 还是写三个单调队列比较稳一点. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;typedef pair&lt;double, double&gt; pdd;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e5 + 5;double a[maxn], dp[maxn];int last[maxn];int n;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); double l, A, B, t, r; while (cin &gt;&gt; l &gt;&gt; A &gt;&gt; B &gt;&gt; t &gt;&gt; r) &#123; cin &gt;&gt; n; a[0] = dp[0] = 0; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; a[++n] = l; deque&lt;pair&lt;int, double&gt; &gt; dq; // (pos, val) double d = A * t + B * r; for (int i = 1, k = 1; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + (a[i] - a[i - 1]) / A; last[i] = i - 1; while (a[i] - a[k] &gt; d) &#123; double foo = (A * r - B * r - a[k] + a[i]) / A + dp[k]; if (foo &lt; dp[i]) &#123; dp[i] = foo; last[i] = k; &#125; k++; &#125; while (dq.size() &amp;&amp; a[i] - a[dq.front().first] &gt; d) dq.pop_front(); if (dq.size()) &#123; pair&lt;int,double&gt; u = dq.front(); if (u.second + a[i] / B &lt; dp[i]) &#123; dp[i] = u.second + a[i] / B; last[i] = u.first; &#125; &#125; double bar = dp[i] + (t * B - t * A - a[i]) / B; while (dq.size() &amp;&amp; dq.back().second &gt; bar) dq.pop_back(); dq.push_back(mp(i, bar)); &#125; vector&lt;int&gt; ans; for (int i = last[n]; i &gt; 0; i = last[i]) &#123; ans.pb(i - 1); &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for (int i = ans.size() - 1; i &gt;= 0; i--) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>优化方法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf981e Addition on Segments]]></title>
    <url>%2F2018%2F07%2F15%2Fcf981e-Addition-on-Segments%2F</url>
    <content type="text"><![CDATA[题意给你一个长度为n的全为0的序列,接下来有m个区间加的操作,你可以从这m个操作中任取一些操作实施,然后会得到一个区间最大值. 问区间最大值在1到n的可能的情况有多少个? $1 \leq n ,q \leq 10^4 $ 分析我们可以枚举位置i的值是最大值, 这样对于不包括i的操作就可以舍去. 然后看i有多少种取值是在1到n之间的. 对于区间加的操作我们可以用线段树的lazy来维护, 这样我们在查询i的值时那些不包括i的操作就会被舍去. 然后就是对每个点的lazy进行01背包,即每个区间操作取或不取. (每个节点的lazy不只是一个值,因为可能有多个区间覆盖一个点的情况) 因为最大值的区间在1到n,所以我们可用bitset进行优化,最后复杂度为$O(n^2logn / 64)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4 + 5;vector&lt;int&gt; lazy[maxn &lt;&lt; 2];bitset&lt;maxn&gt; dp[100], ans;void update(int l, int r, int rt, int L, int R, int x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; lazy[rt].pb(x); return; &#125; int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, lson, L, R, x); if (m &lt; R) update(m + 1, r, rson, L, R, x);&#125;void query(int l, int r, int rt, int k) &#123; dp[k] = dp[k - 1]; for (auto &amp;v : lazy[rt]) dp[k] |= dp[k] &lt;&lt; v; if (l == r) &#123; ans |= dp[k]; return; &#125; int m = l + r &gt;&gt; 1; query(l, m, lson, k + 1); query(m + 1, r, rson, k + 1);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); bitset&lt;maxn&gt; bt, foo; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; for (int i = 0; i &lt; 2 * n + 5; i++) &#123; lazy[i].clear(); &#125; int l, r, x; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; update(1, n, 1, l, r, x); &#125; dp[0].set(0); ans.reset(); query(1, n, 1, 1); int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt += ans[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if (ans[i] == 1) cout &lt;&lt; i &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛22-C 简单瞎搞题]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B22-C-%E7%AE%80%E5%8D%95%E7%9E%8E%E6%90%9E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意一共有n个数，第i个数是$x_i$,$x_i$可以取$[l_i , r_i]$中任意的一个值。 设$S = \sum x_i^2$, 求S种类数 $1 \leq n, l_i, r_i \leq 100$ 分析计算可知S最大为1e6, 所以我们可以用1e6个二进制位来记录每个数是否出现过. 然后暴力所有的区间. 复杂度(1e10 / w) …. 代码123456789101112131415161718192021222324252627282930313233343536373839//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6+5;bitset&lt;maxn&gt; b[2];int main()&#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; b[0].set(0); for(int i=1;i&lt;=n;i++)&#123; int l,r; cin &gt;&gt; l &gt;&gt; r; b[i &amp; 1].reset(); for(int k=l;k&lt;=r;k++)&#123; b[i &amp; 1] |= b[i &amp; 1 ^ 1] &lt;&lt; (k*k); &#125; &#125; cout &lt;&lt; b[n&amp;1].count() &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bitset]]></title>
    <url>%2F2018%2F07%2F14%2FBitset%2F</url>
    <content type="text"><![CDATA[12bitset&lt;N&gt; bt;//复杂度据说是 N / w(计算机字长) 主要用来优化类01背包问题 成员函数]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>Bitset</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调队列]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[求滑动窗口最大值 双端队列模拟即可 12345678deque&lt;pii&gt; dq; // (pos, val)for(int i=1;i&lt;=n;i++)&#123; while(dq.size() &amp;&amp; 队首过期) dq.pop_front(); while(dq.size() &amp;&amp; 加入当前元素后队列不单调) dq.pop_back(); dq.push_back(当前元素) 队首进行决策&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2018.7 大鱼吃小鱼]]></title>
    <url>%2F2018%2F07%2F12%2FEOJ-Monthly-2018-7-%E5%A4%A7%E9%B1%BC%E5%90%83%E5%B0%8F%E9%B1%BC%2F</url>
    <content type="text"><![CDATA[题意有n条鱼 任意时刻只能吃大小小于等于自己的鱼。 任何时刻都要保证鱼的大小是正整数。 当吃了第 i 条鱼之后自己的大小 x 会变为 $x+a_i$。 初始鱼的大小至少需要多大才能吃完这 n 条鱼? 吃的顺序可以任意。 分析二分最后答案,然后先吃掉所有$a_i &gt;= 0$的鱼 对于$a_i&lt;0$的鱼, 有两种方法: 考虑吃掉i之前,$x\geq w_i$,吃掉i之后,$x \geq w_i + a_i$, 要使体型尽可能的大,所以按$a+w$排序即可. 先把所有鱼都吃掉,然后看如果$x \geq w_i + a_i$, 那么就减去$a_i$,也是按$a+w$排序即可.代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const ll INF = 1e18;const int NINF = 0xc0c0c0c0;struct P &#123; ll w, a;&#125;;vector&lt;P&gt; foo, bar;const int maxn = 1e6 + 5;bool vis[maxn];bool ok(ll x) &#123; for (auto &amp;v : foo) if (x &gt;= v.w) x += v.a; else return false; for (auto &amp;v : bar) &#123; if (x &gt;= v.w) x -= v.a; else return false; &#125; if (x &lt;= 0) return false; return true;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; int u, v; foo.clear(); bar.clear(); temp.clear(); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; if (v &gt;= 0) &#123; foo.push_back(&#123;u, v&#125;); &#125; else &#123; bar.push_back(&#123;u, -v&#125;); // temp.push_back(&#123;u, -v&#125;); &#125; &#125; for (int i = 0; i &lt; bar.size(); i++) bar[i].id = i; // for (int i = 0; i &lt; temp.size(); i++) temp[i].id = i; sort(foo.begin(), foo.end(), cmp1); sort(bar.begin(), bar.end(), cmp2); // sort(temp.begin(), temp.end(), cmp3); ll l = 1, r = 1e18; ll ans; while (l &lt;= r) &#123; ll mid = l + r &gt;&gt; 1; if (ok(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOJ Monthly 2018.7 对称与科学美 异或和为0的区间数量]]></title>
    <url>%2F2018%2F07%2F12%2FEOJ-Monthly-2018-7-%E5%AF%B9%E7%A7%B0%E4%B8%8E%E7%A7%91%E5%AD%A6%E7%BE%8E-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题意给一个数列，问有多少连续子数列，符合对称与科学美，也就是每个数字的出现次数均为偶数。 题目 分析满足题意的区间，其异或和为0，反之不一定成立。 所以我们可以对每个相同的数字重新随机一个新的数字，然后再计算答案 多次随机，在所有答案中取最小的即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 4e5;map&lt;ll, ll&gt; cnt;ll back[maxn], a[maxn];vector&lt;ll&gt; G[maxn];int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; srand(time(0)); while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; ll ans = 1e18; for (int i = 1; i &lt;= 10; i++) &#123; ll t = rand(); for (int k = 1; k &lt;= n; k++) a[k] *= t; cnt.clear(); ll x = 0; ll foo = 0; for (int k = 1; k &lt;= n; k++) &#123; x ^= a[k]; foo += cnt[x] + (x == 0); cnt[x]++; &#125; ans = min(ans, foo); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三分查找]]></title>
    <url>%2F2018%2F07%2F12%2F%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[求单峰区间的极值 整数三分1234567891011121314151617// 求极大值 [l,r]int find(int l, int r) &#123; int m1, m2, val = 0, ret; while (r - l &gt;= 3) &#123; m1 = l + (r - l) / 3; m2 = r - (r - l) / 3; if (work(m1) &gt; work(m2)) r = m2; else l = m1; &#125; for (int i = l; i &lt;= r; i++) &#123; int res = work(i); if (val &lt; res) val = res, ret = i; &#125; return ret;&#125; 浮点三分12345678910111213// 求极小值double find(double l, double r) &#123; double m1, m2; while (r - l &gt;= eps) &#123; m1 = l + (r - l) / 3; m2 = r - (r - l) / 3; if (work(m1) &gt; work(m2)) l = m1; else r = m2; &#125; return (m1 + m2) / 2;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
      <tags>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[染色]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题意给定一棵有n个节点的无根树和m个操作，操作有2类： 1、将节点a到节点b路径上所有点都染成颜色c； 2、询问节点a到节点b路径上的颜色段数量（连续相同颜色被认为是同一段）， 如“112221”由3段组成：“11”、“222”和“1”。 请你写一个程序依次完成这m个操作。 分析轻重链剖分后线段树区间合并 注意 线段树查询的时候，递归查询左右两个子段时，如果交界处颜色相等，答案要减一 在树链上查询的时候，如果链首的父亲和链首颜色相同，答案要减一 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];struct Node &#123; int l, r, cnt;&#125;;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; Node seg[maxn &lt;&lt; 2]; int lazy[maxn &lt;&lt; 2]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; void pushup(int rt) &#123; seg[rt].cnt = seg[lson].cnt + seg[rson].cnt; seg[rt].l = seg[lson].l; seg[rt].r = seg[rson].r; if (seg[lson].r == seg[rson].l) seg[rt].cnt--; &#125; void build(int l, int r, int rt) &#123; lazy[rt] = -1; if (l == r) &#123; seg[rt].l = seg[rt].r = a[rk[l]]; seg[rt].cnt = 1; return; &#125; int m = l + r &gt;&gt; 1; build(l, m, lson); build(m + 1, r, rson); pushup(rt); &#125; void pushdown(int rt) &#123; if (lazy[rt] == -1) return; int c = lazy[rt]; seg[lson].l = seg[rson].l = c; seg[lson].r = seg[rson].r = c; seg[lson].cnt = seg[rson].cnt = 1; lazy[lson] = lazy[rson] = c; lazy[rt] = -1; &#125; void update(int l, int r, int L, int R, int rt, int c) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; seg[rt].l = seg[rt].r = c; seg[rt].cnt = 1; lazy[rt] = c; return; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, L, R, lson, c); if (R &gt; m) update(m + 1, r, L, R, rson, c); pushup(rt); &#125; void update_path(int u, int v, int c) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, n, id[top[u]], id[u], 1, c); u = par[top[u]]; &#125; // if (u == v) return; if (dep[u] &gt; dep[v]) swap(u, v); update(1, n, id[u], id[v], 1, c); &#125; int query_c(int l, int r, int x, int rt) &#123; if (l == r) return seg[rt].l; pushdown(rt); int m = l + r &gt;&gt; 1; if (x &lt;= m) return query_c(l, m, x, lson); if (x &gt; m) return query_c(m + 1, r, x, rson); &#125; int query(int l, int r, int L, int R, int rt) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].cnt; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; int ret = 0; if (R &lt;= m) &#123; ret += query(l, m, L, R, lson); &#125; else if (L &gt; m) &#123; ret += query(m + 1, r, L, R, rson); &#125; else &#123; ret += query(m + 1, r, L, R, rson) + query(l, m, L, R, lson); if(seg[lson].r == seg[rson].l) ret--; &#125; // if (L &lt;= m) ret += query(l, m, L, R, lson); // if (R &gt; m) ret += query(m + 1, r, L, R, rson); return ret; &#125; int query_path(int u, int v) &#123; int ret = 0; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret += query(1, n, id[top[u]], id[u], 1); int fac = query_c(1, n, id[par[top[u]]], 1); int c = query_c(1, n, id[top[u]], 1); if (fac == c) ret--; u = par[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v); ret += query(1, n, id[u], id[v], 1); return ret; &#125;&#125;;HLD hld;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int u, v, c; hld.init(n); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; u &gt;&gt; v; hld.addedge(u, v); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); hld.build(1, n, 1); string op; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == "C") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; hld.update_path(u, v, c); &#125; else &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; hld.query_path(u, v) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tree POJ - 3237 边权模板题]]></title>
    <url>%2F2018%2F07%2F10%2FTree-POJ-3237-%E8%BE%B9%E6%9D%83%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意三种操作： 改变某条边的权值 将a到b点链上的所有边的权值都取反 查询a到b点链上的所有边的权值最大值 分析将边权下放到点权，注意查询和修改的时候不能动最后的LCA（因为它的权值是属于它与它父亲的边 轻重链剖分后线段树维护即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];struct Node &#123; int Min, Max;&#125;;struct Edge &#123; int u, v, w;&#125;;vector&lt;Edge&gt; edges;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; Node seg[maxn &lt;&lt; 2]; int lazy[maxn &lt;&lt; 2]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; int pushup(int rt) &#123; seg[rt].Min = min(seg[lson].Min, seg[rson].Min); seg[rt].Max = max(seg[lson].Max, seg[rson].Max); &#125; void build(int l, int r, int rt) &#123; lazy[rt] = 0; if (l == r) &#123; seg[rt].Min = seg[rt].Max = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(l, m, lson); build(m + 1, r, rson); pushup(rt); &#125; void pushdown(int rt) &#123; if (!lazy[rt]) return; swap(seg[lson].Max, seg[lson].Min); seg[lson].Max *= -1; seg[lson].Min *= -1; swap(seg[rson].Max, seg[rson].Min); seg[rson].Max *= -1; seg[rson].Min *= -1; lazy[lson] ^= 1; lazy[rson] ^= 1; lazy[rt] = 0; &#125; void update(int l, int r, int L, int R, int rt, int op, int val) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; if (!op) &#123; seg[rt].Max = seg[rt].Min = val; &#125; else &#123; swap(seg[rt].Max, seg[rt].Min); seg[rt].Max *= -1; seg[rt].Min *= -1; lazy[rt] ^= 1; &#125; return; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; if (L &lt;= m) update(l, m, L, R, lson, op, val); if (R &gt; m) update(m + 1, r, L, R, rson, op, val); pushup(rt); &#125; void update_path(int u, int v, int op) &#123; if (!op) &#123; update(1, n, id[u], id[u], 1, op, v); return; &#125; if (dep[u] &gt; dep[v]) swap(u, v); while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(1, n, id[top[u]], id[u], 1, op, -1); u = par[top[u]]; &#125; if(u == v) return; if (dep[u] &gt; dep[v]) swap(u, v); update(1, n, id[u] + 1, id[v], 1, op, -1); &#125; int query(int l, int r, int L, int R, int rt) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) &#123; return seg[rt].Max; &#125; pushdown(rt); int m = l + r &gt;&gt; 1; int ret = NINF; if (L &lt;= m) ret = max(ret,query(l, m, L, R, lson)); if (R &gt; m) ret = max(ret,query(m + 1, r, L, R, rson)); return ret; &#125; int query_path(int u, int v) &#123; int ret = NINF; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); ret = max(ret, query(1, n, id[top[u]], id[u], 1)); u = par[top[u]]; &#125; if(u == v) return ret; if (dep[u] &gt; dep[v]) swap(u, v); ret = max(ret, query(1, n, id[u] + 1, id[v], 1)); return ret; &#125;&#125;;HLD hld;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n, u, v, w; cin &gt;&gt; n; hld.init(n); edges.clear(); for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.addedge(u, v); edges.push_back(&#123;u, v, w&#125;); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); for (int i = 0; i &lt; edges.size(); i++) &#123; int &amp;u = edges[i].u; int &amp;v = edges[i].v; w = edges[i].w; if (hld.dep[u] &gt; hld.dep[v]) swap(u, v); a[hld.id[v]] = w; &#125; hld.build(1, n, 1); string op; while (cin &gt;&gt; op) &#123; if (op == "DONE") break; if (op == "QUERY") &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; hld.query_path(u, v) &lt;&lt; endl; &#125; else if (op == "CHANGE") &#123; cin &gt;&gt; u &gt;&gt; w; hld.update_path(edges[u - 1].v, w, 0); &#125; else &#123; cin &gt;&gt; u &gt;&gt; v; hld.update_path(u, v, 1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Aragorn's Story HDU-3966 点权模板题]]></title>
    <url>%2F2018%2F07%2F10%2FAragorn-s-Story-HDU-3966-%E7%82%B9%E6%9D%83%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意三种操作： c1 到 c2 链上都增加k c1 到 c2 链上都减少k 查询c1 到c2 链上的和 分析轻重链剖分后用树状数组维护即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4+5;int a[maxn];struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn], rk[maxn]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); clr(diff, 0); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u); &#125; void dfs(int u, int fa, int d) &#123; dep[u] = d; par[u] = fa; sz[u] = 1; for (auto &amp;v : G[u]) &#123; if (v == fa) continue; dfs(v, u, d + 1); sz[u] += sz[v]; if (son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u, int t) &#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if (son[u] == -1) return; link(son[u], t); for (auto &amp;v : G[u]) &#123; if (v != son[u] &amp;&amp; v != par[u]) link(v, v); &#125; &#125; void update_path(int u, int v, int val) &#123; while (top[u] != top[v]) &#123; if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(id[top[u]], id[u], val); u = par[top[u]]; &#125; if (dep[u] &gt; dep[v]) swap(u, v); update(id[u], id[v], val); &#125; int diff[maxn]; int lowb(int x) &#123; return x &amp; (-x); &#125; int query(int x) &#123; int ret = 0; for (int i = x; i &gt; 0; i -= lowb(i)) &#123; ret += diff[i]; continue; &#125; return ret; &#125; void update(int l, int r, int val) &#123; for (int i = l; i &lt;= n; i += lowb(i)) diff[i] += val; for (int i = r + 1; i &lt;= n; i += lowb(i)) diff[i] -= val; &#125;&#125;;HLD hld;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m, q; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123; hld.init(n + 5); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int u, v, w; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; hld.addedge(u, v); &#125; hld.dfs(1, 1, 1); hld.link(1, 1); for (int i = 1; i &lt;= n; i++) hld.update(hld.id[i], hld.id[i], a[i]); string op; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; op; if (op == "I") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.update_path(u, v, w); &#125; else if (op == "D") &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; hld.update_path(u, v, -w); &#125; else &#123; cin &gt;&gt; u; cout &lt;&lt; hld.query(hld.id[u]) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树链剖分</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HLD]]></title>
    <url>%2F2018%2F07%2F03%2FHLD%2F</url>
    <content type="text"><![CDATA[感谢 大神博客 HLDHLD: Heavy-Light Decomposition 轻重链剖分 将一棵树转化为若干链拼接而成的区间.然后在这个区间上就可以使用一些数据结构来操作. 复杂度: 因为是轻重链剖分,所以跳跃的复杂度不会超过$log(n)$次 其实树链剖分并不是一个复杂的算法或者数据结构，只是能把一棵树拆成链来处理而已，换一种说法，树链剖分只是 xxx 数据结构/算法在树上的推广，或者说，树链剖分只是把树 hash 到了几段连续的区间上。 因为这东西本身没有功能，具体功能都是靠具体数据结构实现的，所以复杂度就是$O(logn * ??)$。如果套上了线段树，就是$O(log^2 n)$. 如果套上了树套树，那就是$O(log^3 n)$.如果你用树链剖分和树套树写区间第 k 大，那就是$O(log^4 n)$. ——出自大神博客 讲解重儿子：父亲节点的所有儿子中子树结点数目最多的结点； 轻儿子：父亲节点中除了重儿子以外的儿子； 重边：父亲结点和重儿子连成的边； 轻边：父亲节点和轻儿子连成的边； 重链：由多条重边连接而成的路径； 轻链：由多条轻边连接而成的路径； $par[u]$ 保存结点 u 的父亲节点 $dep[u]$ 保存结点 u 的深度值 $sz[u]$ 保存以 u 为根的子树节点个数 $son[u]$ 保存重儿子 $rk[u]$ 保存当前 dfs 标号在树中所对应的节点 $top[u]$ 保存当前节点所在链的顶端节点。如果该点不在重链上则 top[u]=u $id[u]$ 保存树中每个节点剖分以后的新编号（DFS 的执行顺序） 算法过程 dfs 去找出所有重儿子 link 去连接重链，保证重链的 dfs 序是连续的（因为重链是要维护的信息） update_path(u,v) 如果 top[u] == top[v]，说明 u 和 v 在同一条重链上，直接按 dfs 序用数据结构去更新即可（update(id[u],id[v])）。如果 top[u] != top[v]，我们需要深度大的点往上跳（update(id[top[u]],id[u])）。 查询同理 注意 数据结构维护的是树链剖分后的序列（id 序列） 当题目中给的是边权时，要将边权下放变成点权（下放给深度大的点） 查询的时候要注意最后公共的 lca 是不算进去的，因为的权值是它与它父亲的边权。 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int maxn = 1000000;struct HLD &#123; int n, dfn; int sz[maxn], top[maxn], son[maxn], dep[maxn], par[maxn], id[maxn],rk[maxn]; vector&lt;int&gt; G[maxn]; void init(int n) &#123; this-&gt;n = n; clr(son, -1); dfn = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); &#125; void addedge(int u,int v)&#123; G[u].pb(v); G[v].pb(u); &#125; void build() &#123; dfs(1, 1, 1); link(1, 1); &#125; void dfs(int u,int fa,int d)&#123; dep[u] = d; par[u] = fa; sz[u] = 1; for(auto &amp;v:G[u])&#123; if(v == fa) continue; dfs(v,u,d+1); sz[u] += sz[v]; if(son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125; &#125; void link(int u,int t)&#123; top[u] = t; id[u] = ++dfn; rk[dfn] = u; if(son[u] == -1) return ; link(son[u],t); // 保证重链的dfs序是连续的 for(auto &amp;v:G[u])&#123; if(v != son[u] &amp;&amp; v != par[u]) link(v,v); &#125; &#125; void update(int u,int v,int w) &#123;&#125; // 数据结构 int query(int u,int v) &#123;&#125; // 数据结构 void update_path(int u,int v,int w)&#123; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); update(id[top[u]],id[u],w); u = par[top[u]]; &#125; // if(u == v) return; // 边权 if(dep[u] &gt; dep[v]) swap(u,v); update(id[u],id[v],w); // 点权 // update(id[u] + 1,id[v],w); // 边权 &#125; int query_path(int u,int v)&#123; int ret = 0; while(top[u] != top[v])&#123; if(dep[top[u]] &lt; dep[top[v]]) swap(u,v); ret += query(id[top[u]],id[u]); u = par[top[u]]; &#125; // if(u == v) return ret; // 边权 if(dep[u] &gt; dep[v]) swap(u,v); ret += query(id[u],id[v]); // 点权 // ret += query(id[u] + 1,id[v]); // 边权 return ret; &#125;&#125; hld;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ]]></title>
    <url>%2F2018%2F07%2F03%2FRMQ%2F</url>
    <content type="text"><![CDATA[RMQRMQ: Range Minimum Query 范围最小值 一维 RMQ$dp[i][k]$: 表示从 i 位置开始，长度为$2^k$的一段元素中的最小值。 $dp[i][k] = min(dp[i][k-1], dp[i + (1 &lt;&lt; (k-1))][k-1])$ 查询区间$[l,r]$的时候要先找到第一个 k,使得$2^{k+1} &gt; r - l + 1$ 那么答案就是$min(dp[l][k],dp[r - (1 &lt;&lt; k) + 1][k])$ 时间复杂度为： 预处理 nlogn, 查询 logn 模板1234567891011121314151617// nlog(n) 预处理， log(n) 查询// 起始下标为1const int maxn = 100;int dp[maxn][maxn];int a[maxn];void rmq_init(int n) &#123; for (int i = 1; i &lt;= n; i++) dp[i][0] = a[i]; for (int k = 1; (1 &lt;&lt; k) &lt;= n; k++) &#123; for (int i = 1; i + (1 &lt;&lt; k) &lt; n; i++) &#123; dp[i][k] = min(dp[i][k - 1], dp[i + (1 &lt;&lt; (k - 1))][k - 1]); &#125; &#125;&#125;int rmq(int l, int r) &#123; int k = 31 - __builtin_clz(r - l + 1); // 前导零的个数 return min(d[l][k], d[r - (1 &lt;&lt; k) + 1][k]);&#125; 二维 RMQ$dp[r][c][i][k]$: 表示$(r,c)$为左上角,$(r + 2^{i} - 1, c + 2^{k} - 1)$为右下角的矩阵中的最小值 1234567891011121314151617181920212223242526272829303132333435363738// 预处理 n*m*log(n)*log(m)， 查询 log(nm)// 起始下标为1const int maxn = 100;int dp[maxn][maxn][maxn][maxn];int a[maxn][maxn];void rmq_init(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int k = 1; k &lt;= m; k++) &#123; dp[i][k][0][0] = a[i][k]; &#125; &#125; for (int i = 0; (1 &lt;&lt; i) &lt;= n; i++) &#123; for (int k = 0; (1 &lt;&lt; k) &lt;= m; k++) &#123; if (!i &amp;&amp; !k) continue; for (int r = 1; r + (1 &lt;&lt; i) - 1 &lt;= n; r++) &#123; for (int c = 1; c + (1 &lt;&lt; k) - 1 &lt;= m; c++) &#123; if (!k) dp[r][c][i][k] = min(dp[r][c][i - 1][k], dp[r + (1 &lt;&lt; (i - 1))][c][i - 1][k]); else dp[r][c][i][k] = min(dp[r][c][i][k - 1], dp[r][c + (1 &lt;&lt; (k - 1))][i][k - 1]); &#125; &#125; &#125; &#125;&#125;int rmq(int x1, int y1,int x2,int y2) &#123; int kx = 31 - __builtin_clz(x2 - x1 + 1); int ky = 31 - __builtin_clz(y2 - y1 + 1); int m1 = dp[x1][y1][kx][ky]; int m2 = dp[x2 - (1 &lt;&lt; kx) + 1][y1][kx][ky]; int m3 = dp[x1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; int m4 = dp[x2 - (1 &lt;&lt; kx) + 1][y2 - (1 &lt;&lt; ky) + 1][kx][ky]; return min(&#123;m1,m2,m3,m4&#125;);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cf602d Lipshitz Sequence]]></title>
    <url>%2F2018%2F06%2F29%2Fcf602d-Lipshitz-Sequence%2F</url>
    <content type="text"><![CDATA[来源: cf 602d 分析相邻两个元素的L(h)是最大的。 单调栈预处理每个区间所覆盖的区间即可。 注意要[l,r) 左开右闭，否则会重复计算元素 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int a[maxn];int L[maxn], R[maxn];void init(int n) &#123; stack&lt;pii&gt; st; for (int i = 1; i &lt; n; i++) &#123; while (st.size() &amp;&amp; (abs(a[i] - a[i - 1])) &gt;= st.top().second) st.pop(); if (st.empty()) L[i] = 0; else L[i] = st.top().first; st.push(mp(i, abs(a[i] - a[i - 1]))); &#125; while (!st.empty()) st.pop(); for (int i = n - 1; i &gt; 0; i--) &#123; while (st.size() &amp;&amp; (abs(a[i] - a[i - 1])) &gt; st.top().second) st.pop(); if (st.empty()) R[i] = n - 1; else R[i] = st.top().first - 1; st.push(mp(i, abs(a[i] - a[i - 1]))); &#125;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, q; while (cin &gt;&gt; n &gt;&gt; q) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; init(n); int l, r; ll ans; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; l &gt;&gt; r; ans = 0; for (int k = l; k &lt; r; k++) &#123; int ri = min(R[k], r-1); int li = max(L[k], l-1); ans += 1LL * (ri - k + 1) * (k - li) * abs(a[k] - a[k - 1]); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>单调栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu4348 To the moon 主席树区间修改区间查询]]></title>
    <url>%2F2018%2F06%2F28%2Fhdu4348-To-the-moon-%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题意要支持区间修改，区间查询，版本回退 分析因为要维护多个版本，这正是主席树做的事情。 难点在区间修改怎么做 普通的线段树做区间修改都会设置lazy标志，然后在更新和查询的时候会下放。 在主席树中同样也要设置lazy标志，但是不会下放。 因为主席树是动态开点的，下放的时候子节点都还没被被创建… 那么如果lazy标志不下放，在查询的时候就要把祖先们的lazy标志都加上。 特别要注意的是pushup的时候也要带上自身的lazy， 因为sum[i] 记录的是整个区间更新之后的值。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define my_unique(a) a.resize(distance(a.begin(), unique(a.begin(), a.end())))#define my_sort_unique(c) (sort(c.begin(), c.end())), my_unique(c)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int root[maxn], a[maxn];int lch[maxn &lt;&lt; 5], rch[maxn &lt;&lt; 5];ll sum[maxn &lt;&lt; 5], lazy[maxn &lt;&lt; 5];int idx;inline void pushup(int rt, int len) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]] + 1LL * len * lazy[rt]; // !&#125;void build(int &amp;k, int l, int r) &#123; k = ++idx; lazy[k] = 0; if (l == r) &#123; sum[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k, r - l + 1);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old]; lazy[k] = lazy[old];&#125;void update(int old, int &amp;k, int l, int r, int L, int R, int x) &#123; k = ++idx; newnode(old, k); if (L &lt;= l &amp;&amp; R &gt;= r) &#123; sum[k] += x * (r - l + 1); lazy[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (m &gt;= L) update(lch[old], lch[k], l, m, L, R, x); if (m &lt; R) update(rch[old], rch[k], m + 1, r, L, R, x); pushup(k, r - l + 1);&#125;ll query(int k, int l, int r, int L, int R, ll x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k] + 1LL * (r - l + 1) * x; // ! int m = l + r &gt;&gt; 1; x += lazy[k]; // ! ll ret = 0; if (m &gt;= L) ret += query(lch[k], l, m, L, R, x); if (m &lt; R) ret += query(rch[k], m + 1, r, L, R, x); return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n, m; int kase = 0; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (kase) cout &lt;&lt; '\n'; kase++; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; idx = 0; build(root[0], 1, n); char op; int l, r, t; ll x; int dfn = 0; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == 'Q') &#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(root[dfn], 1, n, l, r, 0) &lt;&lt; endl; &#125; else if (op == 'C') &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; update(root[dfn], root[dfn + 1], 1, n, l, r, x); dfn++; &#125; else if (op == 'H') &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; t; cout &lt;&lt; query(root[t], 1, n, l, r, 0) &lt;&lt; endl; &#125; else &#123; cin &gt;&gt; dfn; idx = root[dfn + 1] - root[0]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kth number]]></title>
    <url>%2F2018%2F06%2F28%2FKth-number%2F</url>
    <content type="text"><![CDATA[题意求区间第k大 （不带修改 分析一般的权值线段树只能够求全局第k大 （还不如直接排序 怎么求区间第k大呢？ 还是权值线段树的思想 初始版本全是0， 第一个版本加入$a_1$,第二个版本加入$a_2$… 那么我要求$[a_i,a_k]$区间的第k大的话，我只需要在查询的时候用第k个版本减去第(i-1)个版本即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int root[maxn];int lch[maxn &lt;&lt; 5], rch[maxn &lt;&lt; 5], sum[maxn &lt;&lt; 5];int idx;vector&lt;int&gt; a, b;inline int getid(int x) &#123; return lower_bound(b.begin(), b.end(), x) - b.begin() + 1;&#125;// /*// inline void pushup(int rt) &#123; sum[rt] += sum[lson] + sum[rson]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++idx; sum[k] = 0; if (l == r) return; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); // pushup(k);&#125;// */void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++idx; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old] + x; if (l == r) return; int m = l + r &gt;&gt; 1; if (p &lt;= m) update(lch[old], lch[k], l, m, p, x); else update(rch[old], rch[k], m + 1, r, p, x);&#125;int query(int l, int r, int L, int R, int k) &#123; if (l == r) return l; int m = l + r &gt;&gt; 1; int cnt = sum[lch[R]] - sum[lch[L]]; if (k &lt;= cnt) return query(l, m, lch[L], lch[R], k); else return query(m+1,r,rch[L],rch[R],k - cnt);&#125;int main() &#123; // /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("2.out","w",stdout); #endif // */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; a.resize(n + 5); b.resize(n + 5); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; b.resize(distance(b.begin(), unique(b.begin(), b.end()))); sort(b.begin(), b.end()); idx = 0; build(root[0], 1, b.size()); for (int i = 1; i &lt;= n; i++) &#123; update(root[i - 1], root[i], 1, b.size(), getid(a[i-1]), 1); &#125; int l, r, k; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; cout &lt;&lt; b[query(1, b.size(),root[l-1], root[r], k)-1] &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>主席树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[主席树]]></title>
    <url>%2F2018%2F06%2F27%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[主席树也称可持久化线段树，即支持版本回退。 对于单点更新的线段树，每次更新操作实际上只会更新一条链，即 logn 个点。 如果将一次更新看做一个新的版本，那么每一个版本只会增加 logn 个节点。 这样我们就不需要每次重新建一棵线段树，直接利用那些没有更改的点就好。 因此，我们只需要记录每个版本的根节点即可完成历史查询的操作。 当然，这里的版本回退可以有多种理解。 它实际上是一种限制条件。 像普通线段树求带修改的区间和，那么想知道第几次修改后的某一区间和，就需要可持久化线段树了。 像普通权值线段树求只能求全局第 k 大，想求区间第 k 大的话就需要可持久化线段树来解决”区间”这个限制了。 再说一下关于空间的问题 因为每次更新都会增加 logn 个节点，所以开多大空间就要看有多少个版本了。假设版本数为 Q, 那 maxn + Q * logQ 应该够了 再说一下关于区间更新的问题 区间更新中，lazy 标记是不会下放的。 （留给读者自行思考 sum[k] 维护的是其所覆盖区间的和（加上 lazy 之后的 但因为查询是自顶向下的，所以 query 的时候要记得加上每一层的懒惰标记。 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495const int maxn = 100;const int N = maxn + Qlog(n);int root[maxn]; // 记录每个版本的根节点int sum[N], lch[N], rch[N];int dfn = 0; // 记得清空// 单点修改，区间查询inline void pushup(int rt) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]]; &#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; if (l == r) &#123; sum[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old];&#125;void update(int old, int &amp;k, int l, int r, int p, int x) &#123; k = ++dfn; newnode(old, k); if (l == r) &#123; sum[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (p &lt;= m) update(lch[old], lch[k], l, m, p, x); if (p &gt; m) update(rch[old], rch[k], m + 1, r, p, x); pushup(k);&#125;int query(int k1, int k2, int l, int r, int L, int R) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k2] - sum[k1]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R); if(m &lt; R) ret += query(rch[k],m+1,r,L,R); return ret;&#125;// 区间更新 区间查询int lazy[N];inline void pushup(int rt, int len) &#123; sum[rt] = sum[lch[rt]] + sum[rch[rt]] + len * lazy[sum];&#125;void build(int &amp;k, int l, int r) &#123; k = ++dfn; lazy[k] = 0; if (l == r) &#123; cin &gt;&gt; sum[k]; return; &#125; int m = l + r &gt;&gt; 1; build(lch[k], l, m); build(rch[k], m + 1, r); pushup(k, r - l + 1);&#125;inline void newnode(int old, int k) &#123; lch[k] = lch[old]; rch[k] = rch[old]; sum[k] = sum[old]; lazy[k] = lazy[old];&#125;void update(int old, int &amp;k, int l, int r, int L, int R, int x) &#123; k = ++dfn; newnode(old, k); if (L &lt;= l &amp;&amp; R &gt;= r) &#123; sum[k] += x * (r - l + 1); lazy[k] += x; return; &#125; int m = l + r &gt;&gt; 1; if (m &gt;= L) update(lch[old], lch[k], l, m, L, R, x); if (m &lt; R) update(rch[old], rch[k], m + 1, r, L, R, x); pushup(k, r - l + 1);&#125;int query(int k, int l, int r, int L, int R, int x) &#123; if (L &lt;= l &amp;&amp; R &gt;= r) return sum[k] + x * (r - l + 1); x += lazy[k]; int m = l + r &gt;&gt; 1; int ret = 0; if(m &gt;= L) ret += query(lch[k],l,m,L,R,x); if(m &lt; R) ret += query(rch[k],m+1,r,L,R,x); return ret;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求逆序对]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题意求区间逆序对 分析权值树状数组 + 离散化 倒着插，每次查询比当前数字小的数的数量的即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e3 + 6;vector&lt;int&gt; a, b;int BIT[maxn];inline int getid(int x) &#123; return lower_bound(b.begin(), b.end(), x) - b.begin() + 1;&#125;inline int lowb(int x) &#123; return x &amp; (-x); &#125;void add(int x) &#123; while (x &lt; b.size()) &#123; BIT[x]++; x += lowb(x); &#125;&#125;int sum(int x) &#123; int ret = 0; while (x &gt; 0) &#123; ret += BIT[x]; x -= lowb(x); &#125; return ret;&#125;int main() &#123;// /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif // */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; a.resize(n + 5); b.resize(n + 5); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i]; &#125; b.resize(distance(b.begin(), unique(b.begin(), b.end()))); sort(b.begin(), b.end()); int ans = 0; clr(BIT, 0); for (int i = n - 1; i &gt;= 0; i--) &#123; ans += sum(getid(a[i]) - 1); add(getid(a[i])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SG函数]]></title>
    <url>%2F2018%2F06%2F23%2FSG%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是 SG 函数我们考虑 Nim 游戏，其实是有若干个子游戏组合而成的（每一堆石子看做一个子游戏 然后得到了结论：将每一堆石子的数量异或起来，若为零，则先手必败。 再考虑一般情况，某些博弈游戏也可以分解为若干个子游戏，那么 Nim 游戏的结论是否具有一般性呢？ 那么每个子游戏的”石子数”就是该子游戏 SG 函数的值。 将每个子游戏的 SG 函数的值异或起来，如果为 0，则先手必败。 SG 函数定义SG(x) = mex{SG(y) | y 是 x 的后继} 其中 mex 表示第一个集合中没有的自然数 联系 Nim 博弈 SG(x) = mex{x-1, x-2 … 0} = x 就是该堆的石子数 一般 SG(0) = 0 即为必败状态， SG(x) != 0, 即为必胜状态 模板1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 100;int f[N];int SG[maxn]; //int S[maxn]; // x 的后继状态void getSG(int n) &#123; SG[0] = 0; // clr(SG,0); for (int i = 1; i &lt; maxn; i++) &#123; clr(S, 0); for (int k = 0; f[k] &lt;= i &amp;&amp; k &lt; n; k++) S[SG[i - f[k]]] = 1; for (int k = 0;; k++) &#123; if (!S[k]) &#123; SG[i] = k; break; &#125; &#125; &#125;&#125;// 单点SG查询void init()&#123; clr(SG,-1);&#125;int getSG(int n, int foo) &#123; if (SG[foo] != -1) return SG[foo]; // int S[N] = &#123;0&#125;; set&lt;int&gt; S; for (int k = 0; f[k] &lt;= foo &amp;&amp; k &lt; n; k++) &#123; int bar = getSG(n, foo - f[k]); S.insert(bar); // S[bar] = 1; &#125; for (int k = 0;; k++) &#123; if (S.find(k) == S.end()) &#123; return SG[foo] = k; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三大博弈游戏]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%B8%89%E5%A4%A7%E5%8D%9A%E5%BC%88%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[参考：ACM BOOK 巴什博弈问题只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。 分析 如果 n=m+1 ，那么由于一次最多只能取 m 个，所以，无论先手拿走多少个，后手都能够一次拿走剩余的物品，后者取胜。 如果 n=(m+1)∗r+s ，(r为任意自然数， s≤m ),先手要拿走s个物品，如果后手拿走 k(k≤m) 个，那么先手再拿走 m+1−k 个，结果剩下 (m+1)∗(r−1) 个，以后保持这样的取法，那么先取者肯定获胜。我们得到如下结论:要保持给对手留下 (m+1) 的倍数，就能最后获胜。 拓展如果我们规定最后取光者输，那么又会如何呢？ (n−1) % (m+1)==0 则后手胜利 先手会重新决定策略，所以不是简单的相反的。 例如 n=15，m=3 后手 先手 剩余 0 2 13 1 3 9 2 2 5 3 1 1 1 0 0 先手胜利 输的人最后必定只抓走一个，如果&gt;1个，则必定会留一个给对手 威佐夫博弈问题有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 分析我们用$(a_k,b_k)$,$(a_k≤b_k,k=0,1,2,…,n)$表示两堆物品的数量并称其为局势，如果甲面对 （0，0） ，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是： （0，0） 、 （1，2） 、 （3，5） 、 （4，7） 、 （6，10） 、 （8，13） 、 （9，15） 、 （11，18） 、 （12，20） 。 可以看出： $a_0=b_0=0$ , $a_k$ 是未在前面出现过的最小自然数,而$b_k=a_k+k$ 。 满足$a_k=k\times (1+\sqrt 5)/2,b_k=a_k+k$后手必胜，否则先手必胜。 Nim博弈问题有若干堆石子，每堆石子的数量都是有限的，合法的移动是“选择一堆石子并拿走若干颗（不能不拿）”，如果轮到某个人时所有的石子堆都已经被拿空了，则判负（因为他此刻没有任何合法的移动）。 分析假设n堆石子，每堆石子的数量为$a_i$ 若$a_1\bigoplus a_2…\bigoplus a_n = 0$ 则先手必败 证明： 若$a_1\bigoplus a_2…\bigoplus a_n \neq 0$ 那么一定可以通过从其中一堆拿一定数量的石子使得$a_1\bigoplus a_2…\bigoplus a_n = 0$ 若$a_1\bigoplus a_2…\bigoplus a_n = 0$,则不管怎么拿，拿完之后$a_1\bigoplus a_2…\bigoplus a_n \neq 0$ 若想不明白可以考虑 数字的每一位]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>博弈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu3938 Portal]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu3938-Portal%2F</url>
    <content type="text"><![CDATA[来源：题目 题意给你一张无向图，求有多少条路径使得路径上的花费小于L，这里路径上的花费是这样规定的，a、b两点之间的多条路径中的最长的边最小值 分析将所有边按权值排序，从权值最小的边开始取。 如果两点不在同一个集合，则合并（相当于使两个集合的点都可以互达） 答案加 sum[u] * sum[v] 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4 + 5;int par[maxn];struct Edge &#123; int u, v, w; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;struct Query &#123; int l, id, ans; bool operator&lt;(const Query &amp;A) const &#123; return id &lt; A.id; &#125;&#125;;Query q[maxn];vector&lt;Edge&gt; edges;int sum[maxn];bool cmpl(const Query A, const Query B) &#123; return A.l &lt; B.l; &#125;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n, m, Q; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q) &#123; int u, v, w, L; edges.clear(); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.push_back(Edge&#123;u, v, w&#125;); &#125; for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; q[i].l; q[i].id = i; q[i].ans = 0; &#125; for (int i = 1; i &lt;= n; i++) par[i] = i, sum[i] = 1; sort(edges.begin(), edges.end()); sort(q, q + Q, cmpl); int foo = 0; for (int i = 0; i &lt; Q; i++) &#123; while (foo &lt; m &amp;&amp; edges[foo].w &lt;= q[i].l) &#123; int u = find(edges[foo].u); int v = find(edges[foo].v); if (u != v) &#123; par[u] = v; q[i].ans += sum[u] * sum[v]; sum[v] += sum[u]; &#125; ++foo; &#125; if (i) q[i].ans += q[i - 1].ans; &#125; sort(q, q + Q); for (int i = 0; i &lt; Q; i++) cout &lt;&lt; q[i].ans &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu3234 Exclusive-OR]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu3234-Exclusive-OR%2F</url>
    <content type="text"><![CDATA[分析带权并查集 添加一个n点，使其值为0，这样任何值异或它都是本身。 然后注意查询的时候，先除去根节点是n的。 然后对于有相同根节点的节点，如果它的数量是奇数那么一定无法确定，偶数则可以确定。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e4 + 5;int par[maxn], val[maxn];int a[30];bool flag;int n;inline int find(int x) &#123; if (x == par[x]) return x; int fa = par[x]; par[x] = find(par[x]); val[x] ^= val[fa]; return par[x];&#125;inline void merge(int u, int v, int x, int i) &#123; int fu = find(u); int fv = find(v); if (fu == fv) &#123; if ((val[u] ^ val[v]) != x) &#123; // cout &lt;&lt; val[u] &lt;&lt; ' ' &lt;&lt; val[v] &lt;&lt; ' ' &lt;&lt; (val[u] ^ val[v]) &lt;&lt; endl; // cout &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl; flag = true; cout &lt;&lt; "The first " &lt;&lt; i &lt;&lt; " facts are conflicting." &lt;&lt; endl; &#125; &#125; else &#123; if (fu == n) swap(fu, fv); val[fu] = val[u] ^ val[v] ^ x; par[fu] = fv; &#125;&#125;void query(int m) &#123; vector&lt;int&gt; fas; vector&lt;int&gt; sons[30]; int ret = 0; for (int i = 0; i &lt; m; i++) &#123; int fa = find(a[i]); if (fa == n) ret ^= val[a[i]]; else &#123; int k = 0; for (k = 0; k &lt; fas.size(); k++) &#123; if (fas[k] == fa) &#123; break; &#125; &#125; if (k == fas.size()) fas.pb(fa); sons[k].pb(a[i]); &#125; &#125; for (int i = 0; i &lt; fas.size(); i++) &#123; if (sons[i].size() &amp; 1) &#123; cout &lt;&lt; "I don't know." &lt;&lt; endl; return; &#125; for (int k = 0; k &lt; sons[i].size(); k++) &#123; ret ^= val[sons[i][k]]; &#125; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int kase = 1; int Q; while (cin &gt;&gt; n &gt;&gt; Q) &#123; flag = false; if (!n &amp;&amp; !Q) break; cout &lt;&lt; "Case " &lt;&lt; kase++ &lt;&lt; ":" &lt;&lt; endl; for (int i = 0; i &lt;= n; i++) par[i] = i, val[i] = 0; int idx = 0; string line; char op; for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; line; if (line == "I") &#123; idx++; int k = 0; while (cin &gt;&gt; a[k++]) &#123; if (cin.get() == '\n') &#123; break; &#125; &#125; if(flag) continue; if (k == 2) merge(a[0], n, a[1], idx); else merge(a[0], a[1], a[2], idx); &#125; else&#123; int k ; cin &gt;&gt; k; for(int i=0;i&lt;k;i++) cin &gt;&gt; a[i]; if(flag) continue; query(k); &#125; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zoj3261 Connections in Galaxy War 删边]]></title>
    <url>%2F2018%2F06%2F23%2Fzoj3261-Connections-in-Galaxy-War-%E5%88%A0%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[删边模板题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// ybmj// #include &lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 5e4 + 5;struct P &#123; string op; int u, v;&#125;;P ops[maxn];int par[maxn], w[maxn];pii a[maxn];set&lt;pii&gt; del;inline int find(int x) &#123; return x == par[x] ? x : par[x] = find(par[x]); &#125;inline void merge(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return; if (w[u] &gt; w[v]) par[v] = u; else if (w[u] == w[v]) &#123; if (u &gt; v) par[u] = v; else par[v] = u; &#125; else par[u] = v;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, m, Q; int kase = 0; while (cin &gt;&gt; n) &#123; if(kase) cout &lt;&lt; '\n'; kase++; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i]; par[i] = i; &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a[i].first &gt;&gt; a[i].second; if(a[i].first &gt; a[i].second) swap(a[i].first,a[i].second); &#125; cin &gt;&gt; Q; del.clear(); for (int i = 0; i &lt; Q; i++) &#123; cin &gt;&gt; ops[i].op; if (ops[i].op == "destroy") &#123; cin &gt;&gt; ops[i].u &gt;&gt; ops[i].v; if(ops[i].u &gt; ops[i].v) swap(ops[i].u, ops[i].v); del.insert(mp(ops[i].u, ops[i].v)); &#125; else cin &gt;&gt; ops[i].u; &#125; for (int i = 0; i &lt; m; i++) &#123; if (del.find(a[i]) != del.end()) continue; // cout &lt;&lt; a[i].first &lt;&lt; ' ' &lt;&lt; a[i].second &lt;&lt; endl; merge(a[i].first, a[i].second); &#125; vector&lt;int&gt; ans; int u, v; for (int i = Q - 1; i &gt;= 0; i--) &#123; if (ops[i].op == "query") &#123; u = ops[i].u; int fa = find(u); if (w[fa] &gt; w[u]) ans.pb(fa); else ans.pb(-1); &#125; else &#123; u = ops[i].u; v = ops[i].v; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; merge(u, v); &#125; &#125; for(int i=ans.size()-1;i&gt;=0;i--)&#123; cout &lt;&lt; ans[i] &lt;&lt; '\n'; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hdu2473 Junk-Mail Filter 删点]]></title>
    <url>%2F2018%2F06%2F23%2Fhdu2473-Junk-Mail-Filter-%E5%88%A0%E7%82%B9%2F</url>
    <content type="text"><![CDATA[来源：题目 删点模板题 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 1e9 + 7;const int maxn = 2e6 + 5;int par[maxn];bool vis[maxn];int idx;inline int find(int u)&#123; return u == par[u] ? u : par[u] = find(par[u]);&#125;void merge(int u, int v) &#123; u = find(u); v = find(v); if (u != v) &#123; par[u] = v; &#125;&#125;void del(int u) &#123; par[u] = idx++; &#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n, m; int kase = 1; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for(int i=0;i&lt;n;i++) par[i] = i+n; for(int i=n;i&lt;n+m+n+5;i++) par[i] = i; idx = 2*n; char op; int u, v; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; op; if (op == 'M') &#123; cin &gt;&gt; u &gt;&gt; v; merge(u, v); &#125; else &#123; cin &gt;&gt; u; del(u); &#125; &#125; clr(vis,0); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; int x = find(i); if(!vis[x])&#123; vis[x] = true; ++ans; &#125; &#125; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[带权并查集带权指 子节点与父节点之间存在限制条件， 如子节点在父节点左边的x米处 接下来面临的两个难点： 路径压缩时权值的变化 两棵树合并时权值的变化 1234567int find(int x)&#123; if(x == par[x]) return x; int fa = par[x]; par[x] = find(par[x]); val[x] += val[fa]; return par[x];&#125; 删点因为并查集是一个树形结构，所以你很难在很低的时间复杂度内，删除一个点，并且维护原来的关系不变。 这里我们对每个节点初始的时候连到一个相应的虚父节点，比如1节点就连到1+n节点。 这样每次合并都用其父节点进行合并。 删除某个节点的时候直接将该节点指向一个新节点即可。 12345678910111213int tot;void init(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; par[i] = i + n; par[i + n] = i + n; &#125; tot = 2 * n;&#125;void remove(int x) &#123; par[x] = ++tot; par[tot] = tot;&#125; 删边将所有操作离线。 我们先把最后的状态建出来，然后逆着查询，这样原来的删边操作就变成了加边操作。]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>并查集</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SPFA]]></title>
    <url>%2F2018%2F06%2F22%2FSPFA%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243vector&lt;pii&gt; G[maxn];bool inq[maxn];int cnt[maxn]; // 记录入队次数int d[maxn];inline void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;inline void addedge(int u,int v,int w)&#123; G[u].pb(mp(v,w)); // G[v].pb(mp(u,w));&#125;bool spfa(int s,int n)&#123; for(int i=0;i&lt;=n;i++) &#123; d[i] = INF; inq[i] = 0; cnt[i] = 0; &#125; d[s] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = true; cnt[s]++; while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = false; for(auto V : G[u])&#123; int v = V.first; int w = V.second; if(d[v] &gt; d[u] + w)&#123; // 求最长路的话改成 &lt; d[v] = d[u] + w; if(!inq[v])&#123; inq[v] = true; cnt[v]++; q.push(v); if(cnt[v] &gt;= n) return false; &#125; &#125; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝壳找房函数最值]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题意来源：计算之道2018复赛g 贝壳找房的攻城狮最近在研究一次函数 $f(x) = ax + b$。 现在有$n$个一次函数，$f_i(x) = a_ix+b_i$ 容易发现，一次函数嵌套一次函数，还是一次函数。 $\displaystyle f_{i}(f_{j}(x)) = a_{i} ( a_{j}x + b_{j}) + b_{i}$ 给定$x$，并且对于所有的$f_i(x)$ 可以任意改变顺序嵌套函数，求 $f(f(f(…f(x))…)$ 的最大值。 分析考虑两个函数的互相嵌套$ax + b$ 和 $cx+d$ $acx + ad + b$ 和 $acx + cb + d$ 所以只要按$ad + b$和$cb + d$排序即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4+5;struct P&#123; int u,v; bool operator&lt;(const P &amp;A) const&#123; int a = u * A.v + v; int b = A.u * v + A.v; return a &lt; b; &#125;&#125;;P a[maxn];int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,x; cin &gt;&gt; n &gt;&gt; x; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i].u; &#125; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i].v; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++)&#123; x = x * a[i].u + a[i].v; x %= 10; &#125; cout &lt;&lt; x &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贝壳找房魔法师顾问]]></title>
    <url>%2F2018%2F06%2F17%2F%E8%B4%9D%E5%A3%B3%E6%89%BE%E6%88%BF%E9%AD%94%E6%B3%95%E5%B8%88%E9%A1%BE%E9%97%AE%2F</url>
    <content type="text"><![CDATA[题意来源:计算之道2018复赛d 贝壳找房在遥远的传奇境外，找到了一个强大的魔法师顾问。他有 22 串数量相同的法力水晶，每个法力水晶可能有不同的颜色。为了方便起见，可以将每串法力水晶视为一个长度不大于$10^5$ ，字符集不大于 $10^5$ 的字符串。现在魔法师想要通过一系列魔法使得这两个字符串相同。每种魔法形如 $(u,\ v),\ u,\ v \le 10^5$ ，可以将一个字符$u$改成一个字符 $v$，并且可以使用无限次。出于种种原因，魔法师会强行指定这两个串能否进行修改。 若失败输出 -1，否则输出最少使用的魔法的种类数。 输入格式一个正整数$n(n \le 10^5)$ 表示每个字符串的长度。 接下来两行每行首先输入一个单词（”Variable”或”Constant”），”Variable”表示这个字符串能进行修改，”Constant”表示这个字符串不能进行修改，然后n个正整数表示一个字符集不大于$10^5$ 的字符串。 分析对于CC：直接比较即可。 对于VV：问题可以转化为给一张无向图，最少用几条边可以保持原图的联通性（可以新建） 每一个连通分量里面选n-1条边即可。 对于CV(VC)：问题转化为给一张有向图，最少用几条边可以保持原图的连通性（可以新建） 对于每一个联通分量，如果里面不含强连通分量，则选n-1条边即可 如果里面含有强连通分量，则最少需要n条边 可以使这张图变为强连通。 对每个联通分量用拓扑排序判环。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e6 + 5;string a[2][maxn];string b[2] = &#123;"Constant", "Variable"&#125;;map&lt;string, int&gt; maps;int par[maxn];vector&lt;int&gt; G[maxn], GG[maxn];bool vis[maxn];int in[maxn];inline int find(int x) &#123; return par[x] &lt; 0 ? x : par[x] = find(par[x]); &#125;void dfs(int id, int u) &#123; GG[id].pb(u); vis[u] = true; for (auto &amp;v : G[u]) &#123; if (!vis[v]) &#123; dfs(id, v); &#125; &#125;&#125;int topo(int id) &#123; queue&lt;int&gt; q; int cnt = 0; for (auto &amp;v : GG[id]) &#123; if (!in[v]) &#123; q.push(v); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); cnt++; for (auto &amp;v : G[u]) &#123; if (in[v] &gt; 0) &#123; in[v]--; if (!in[v]) q.push(v); &#125; &#125; &#125; if (cnt == GG[id].size()) return GG[id].size() - 1; else return GG[id].size();&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; string s[2]; for (int i = 0; i &lt; 2; i++) &#123; cin &gt;&gt; s[i]; for (int k = 0; k &lt; n; k++) cin &gt;&gt; a[i][k]; &#125; bool flag = true; if (s[0] == b[0] &amp;&amp; s[1] == b[0]) &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] != a[1][i]) &#123; flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; else if (s[0] == b[1] &amp;&amp; s[1] == b[1]) &#123; for (int i = 0; i &lt; maxn; i++) par[i] = -1; maps.clear(); int idx = 1; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] == a[1][i]) continue; int u = maps[a[0][i]] == 0 ? maps[a[0][i]] = idx++ : maps[a[0][i]]; int v = maps[a[1][i]] == 0 ? maps[a[1][i]] = idx++ : maps[a[1][i]]; u = find(u); v = find(v); if (u != v) &#123; par[v] += par[u]; par[u] = v; &#125; &#125; ll ans = 0; for (int i = 1; i &lt; idx; i++) &#123; if (par[i] &lt; -1) &#123; ans += -par[i] - 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt; maxn; i++) par[i] = -1; for (int i = 0; i &lt; maxn; i++) G[i].clear(), GG[i].clear(); clr(in, 0); clr(vis, 0); maps.clear(); int idx = 1; for (int i = 0; i &lt; n; i++) &#123; if (a[0][i] == a[1][i]) continue; int u = maps[a[0][i]] == 0 ? maps[a[0][i]] = idx++ : maps[a[0][i]]; int v = maps[a[1][i]] == 0 ? maps[a[1][i]] = idx++ : maps[a[1][i]]; G[u].pb(v); in[v]++; u = find(u); v = find(v); if(u != v) par[v] = u; &#125; int id = 0; map&lt;int,int&gt; rt; for(int i=1;i&lt;idx;i++)&#123; if(par[i] &lt; 0)&#123; rt[i] = id++; &#125; &#125; ll ans = 0; for (int i = 1; i &lt; idx; i++) &#123; int u = find(i); GG[rt[u]].pb(i); &#125; for (int i = 0; i &lt; id; i++) &#123; ans += topo(i); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kuro and GCD and XOR ans SUM]]></title>
    <url>%2F2018%2F05%2F18%2FKuro-and-GCD-and-XOR-ans-SUM%2F</url>
    <content type="text"><![CDATA[题意来源:cf979D q次询问，每次询问有两种操作： 向数组中插入一个u $(1 \leq u \leq 10^5)$ 给定x,k,s, 要从数组中找一个数v，使得其满足：$k \mid GCD(x, v)$, $x + v \leq s$, $x \oplus v$ $1 \leq x, k, s \leq 10^{5}$ 分析01字典树 + 暴力 首先考虑$x \oplus v$: 即在一个数组中找到一个数与给定的数的异或值最大， 这个经典的问题可以用01字典树解决。 再考虑$k \mid GCD(x, v)$: 可以推出 $k \mid x , k \mid v$, 我们可以对1~1e5中每个数建一棵字典树，然后将所有能被k整除的数插入到k的字典树中。 然后我们只要在这棵树上找与x异或最大的数即可。 最后考虑$x + v \leq s$: 对于字典树的每个节点，去维护一个最小的v值，如果要查询的x + val[root] &gt; s 肯定是不行的 字典树的内存设置： 一共要插1e5个数,他们总共的因子个数不超过$nlog(n)$,每个数的二进制长度为20,所以maxnode = 1e5 log(1e5) * 20 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;const int maxnode = 2e7 + 5;const int types = 2;bool vis[maxn];struct Trie &#123; int root[maxn]; int ch[maxnode][types]; int val[maxnode]; int sz; void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; root[i] = i; val[i] = INF; clr(ch[i], 0); &#125; sz = maxn; &#125; void insert(int x, int key) &#123; int u = root[x]; val[u] = min(val[u], key); for (int i = 18; i &gt;= 0; i--) &#123; int v = (key &gt;&gt; i) &amp; 1; if (ch[u][v] == 0) &#123; clr(ch[sz], 0); val[sz] = INF; ch[u][v] = sz++; &#125; u = ch[u][v]; val[u] = min(val[u], key); &#125; // assert(sz &lt; maxnode); &#125; int query(int x, int key, int s) &#123; int u = root[x]; if (val[u] &gt; s) return -1; int ret = 0; for (int i = 18; i &gt;= 0; i--) &#123; int v = (key &gt;&gt; i) &amp; 1; if (ch[u][v ^ 1] != 0 &amp;&amp; val[ch[u][v ^ 1]] &lt;= s) &#123; ret += ((v ^ 1) &lt;&lt; i); u = ch[u][v ^ 1]; &#125; else &#123; ret += (v &lt;&lt; i); u = ch[u][v]; &#125; &#125; return ret; &#125;&#125;;Trie trie;vector&lt;int&gt; f[maxn];void init() &#123; for (int i = 0; i &lt; maxn; i++) f[i].clear(); for(int i=1;i&lt;maxn;i++)&#123; for(int k = i;k &lt; maxn;k+=i)&#123; f[k].pb(i); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; trie.init(); clr(vis, 0); init(); for (int i = 0; i &lt; n; i++) &#123; int op; cin &gt;&gt; op; if (op == 1) &#123; int u; cin &gt;&gt; u; if (vis[u]) continue; vis[u] = true; for (auto i : f[u]) &#123; trie.insert(i, u); &#125; &#125; else &#123; int x, k, s; cin &gt;&gt; x &gt;&gt; k &gt;&gt; s; if (x % k != 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; continue; &#125; cout &lt;&lt; trie.query(k, x, s - x) &lt;&lt; endl; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[（ 蓝书上的图比较形象！ lowbit(x) 可以理解为 BIT[x]所管辖范围的长度 一般就用来做带修改的前缀和。 像什么区间最值是无法做的。 1234567891011121314151617181920212223242526// 数组下标必须从1开始// 单点更新区间查询int BIT[maxn];inline int lowb(int x) &#123; return x &amp; (-x); &#125;inline int query(int l,int r)&#123; int ret = 0; for(int i=l-1;i&gt;0;i-=lowb(i)) ret -= BIT[i]; for(int i=r;i&gt;0;i-=lowb(i)) ret += BIT[i]; return ret;&#125;inline void update(int x,int y,int n)&#123; for(int i=x;i&lt;=n;i+=lowb(i)) BIT[i] += y;&#125;//区间更新单点查询int diff[maxn];inline int lowb(int x) &#123;return x &amp;(-x);&#125;inline int query(int x)&#123; int ret = 0; for(int i=x;i&gt;0;i-=lowb(i)) ret += diff[i]; return ret;&#125;inline void update(int l,int r,int val,int n)&#123; for(int i=l;i&lt;=n;i+=lowb(i)) diff[i] += val; for(int i=r+1;i&lt;=n;i+=lowb(i)) diff[i] -= val;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化]]></title>
    <url>%2F2018%2F05%2F09%2F%E7%A6%BB%E6%95%A3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1234567891011// c++11vector&lt;int&gt; a,b;for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i]; b[i] = a[i];&#125;b.resize(distance(b.begin(),unique(b.begin(),b.end())));inline int getid(int x)&#123; return lower_bound(b.begin(),b.end(),x) - b.begin() + 1;&#125; 12345678for(int i=0;i&lt;n;i++)&#123; A[i] = B[i];&#125;sort(B,B+n);int size = unique(B,B+n) - B;for(int i=0;i&lt;n;++)&#123; A[i] = lower_bound(B,B+size,A[i]) - B + 1;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Perfect Groups]]></title>
    <url>%2F2018%2F05%2F09%2FPerfect-Groups%2F</url>
    <content type="text"><![CDATA[题意来源:cd980D 给定一个长度为n的数组，对于它的每个子段，最少需要分几组，使得每组中的元素，两两乘积都为完全平方数？ $1 \leq n \leq 5000$ 分析首先我们考虑如何判断两个数的乘积是否为完全平方数？ 很显然$O(\sqrt n)$是不行滴。 我们对每个数进行质因数分解，将其所有的平方因子全部去掉，这样只需要判断两数是否相等即可判断其乘积是否为完全平方数。 然后对于区间[i,k]中所有相等的数字可以分到一组，那么区间[i,k]的答案就是不同的数字的数量 暴力枚举所有子段即可。 需要注意的是0可以代替任何数。 而且若一个子段里全是0，那么其值应为1。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4; int a[maxn],b[maxn],lastpos[maxn],cnt[maxn];map&lt;int,int&gt; last;inline void work(int idx)&#123; int x = a[idx]; int flag = x &gt; 0 ? 1 : -1; x *= flag; for(int i=2;i&lt;=sqrt(x);i++)&#123; while(x &amp;&amp; x % (i*i) == 0) x /= i*i; &#125; a[idx] = x * flag;&#125;int init(int n)&#123; last.clear(); for(int i=1;i&lt;=n;i++)&#123; work(i); &#125; for(int i=1;i&lt;=n;i++)&#123; b[i] = a[i]; &#125; sort(b+1,b+1+n); int sz = unique(b+1,b+1+n) - b - 1; bool flag = false; int ret = -1; for(int i=1;i&lt;=n;i++)&#123; if(a[i] == 0) flag = true; a[i] = lower_bound(b+1,b+1+sz,a[i]) - b ; if(flag &amp;&amp; ret == -1) ret = a[i]; lastpos[i] = last[a[i]]; last[a[i]] = i; &#125; return ret;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; a[i]; &#125; int zero = init(n); clr(cnt,0); for(int i=1;i&lt;=n;i++)&#123; int val = 0; for(int k=i;k&lt;=n;k++)&#123; if(lastpos[k] &lt; i &amp;&amp; a[k] != zero)&#123; val = val + 1; &#125; cnt[val]++; &#125; &#125; cnt[1] += cnt[0]; for(int i=1;i&lt;=n;i++) cout &lt;&lt; cnt[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cards Game]]></title>
    <url>%2F2018%2F05%2F09%2FCards-Game%2F</url>
    <content type="text"><![CDATA[题意有n堆牌，每一堆牌有m张，alice只可以每一堆牌的最上面的一张，bob只可以取每一堆牌最下面的一张，每张牌都有一个权值。 两人都采取最优策略，问最后alice和bob各取了多少? $1≤n,m≤100$ 分析这有个性质，对于偶数张的牌堆，alice和bob一定是各取一半，对于奇数张的牌堆，最中间那张从大到小排序后alice和bob按顺序拿 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 105;int a[maxn];vector&lt;int&gt; mid;int main()&#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while(cin &gt;&gt; n)&#123; mid.clear(); int alice = 0, bob = 0; for(int i=0;i&lt;n;i++)&#123; int m; cin &gt;&gt; m; for(int k=0;k&lt;m;k++)&#123; cin &gt;&gt; a[k]; if(k&lt;m/2)alice += a[k]; else bob += a[k]; &#125; if(m &amp; 1)&#123; bob -= a[m/2]; mid.pb(a[m/2]); &#125; &#125; sort(mid.begin(),mid.end(),greater&lt;int&gt;()); for(int i=0;i&lt;mid.size();i++)&#123; if(i &amp; 1) bob += mid[i]; else alice += mid[i]; &#125; cout &lt;&lt; alice &lt;&lt; ' ' &lt;&lt; bob &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beautiful Land]]></title>
    <url>%2F2018%2F05%2F09%2FBeautiful-Land%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛F 超大容量01背包 分析dp[i][k] 表示前i个物品组成价值为k的最小容量 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e4+5;int c[105],v[105];int dp[105][maxn]; // dp[i][k] 前i个物品组成价值为k的最小容量 int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while(T--)&#123; int n,C; cin &gt;&gt; n &gt;&gt; C; int sum = 0; for(int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; c[i] &gt;&gt; v[i]; sum += v[i]; &#125; clr(dp[0],0x3f); dp[0][0] = 0; for(int i=1;i&lt;=n;i++)&#123; for(int k=0;k&lt;=sum;k++)&#123; if(k &gt;= v[i])&#123; dp[i][k] = min(dp[i-1][k-v[i]] + c[i],dp[i-1][k]); &#125; else dp[i][k] = dp[i-1][k]; &#125; &#125; int ans = 0; for(int i=0;i&lt;=sum;i++)&#123; if(dp[n][i] &lt;= C)&#123; ans = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[A Simple Problem]]></title>
    <url>%2F2018%2F05%2F09%2FA-Simple-Problem%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛E 给你两个数组，问你从第一个数组中存在多少个子段与第二个数组同构？ 同构的意思是两个数组的结构相同： aabb 和 ccdd同构$1 \leq n \leq 2 \times 10^5$ $1 \leq m \leq 10^5$ 分析KMP 根据这个同构的特点，我们只需要记录上一个和当前数字相同的距离即可。如果没有则记为-1. 如：121 2 0 2 0 1 -&gt; -1 -1 -1 2 2 51 2 1 2 -&gt; -1 -1 2 2 然后跑kmp 注意这里的kmp要魔改一下下 如果距离大于m的要当做-1看待 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll, ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5 + 5;int s[maxn], p[maxn];int last[15];struct MP&#123; int back[maxn]; void getfail(int m)&#123; int i,k; k = back[0] = -1; i = 0; while(i &lt; m)&#123; while(k != -1 &amp;&amp; ((p[i] &gt; k) ? (p[k] != -1) : (p[i] != p[k]))) k = back[k]; back[++i] = ++k; &#125; &#125; int match(int n,int m)&#123; int i = 0,k = 0; int ret = 0; getfail(m); while(i &lt; n)&#123; while(k != -1 &amp;&amp; ((s[i] &gt; k) ? (p[k] != -1) : (s[i] != p[k]))) k = back[k]; ++i;++k; if(k &gt;= m)&#123; ret++; k = back[k]; &#125; &#125; return ret; &#125;&#125;;MP kmp;void init(int n, int m) &#123; clr(last, -1); for (int i = 0; i &lt; n; i++) &#123; int temp = s[i]; if (last[s[i]] == -1) s[i] = -1; else s[i] = i - last[s[i]]; last[temp] = i; &#125; clr(last, -1); for (int i = 0; i &lt; m; i++) &#123; int temp = p[i]; if (last[p[i]] == -1) p[i] = -1; else p[i] = i - last[p[i]] ; last[temp] = i; &#125;&#125;void debug(int n, int m) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 0; i &lt; m; i++) cout &lt;&lt; p[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;int main() &#123; /*j#ifndef freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif*/ std::ios::sync_with_stdio(false); int n, k; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; s[i]; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i]; init(n, m); // debug(n, m); int ans = kmp.match(n, m); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trees on Sale]]></title>
    <url>%2F2018%2F05%2F08%2FTrees-on-Sale%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛B 给定N，K $(1 \leq N \leq 10^5, 1 \leq K \leq 10^{12})$ 我是一个花店老板，我每次营业之前都会将花打包起来，每一束最少有一枝花。 已知每日都会有N个人来买花，每个人最多一次买K枝花，问我最少需要包几束花。 可以将若干束花合成一束，但不能把一束拆开。 分析假如N个人都买一枝花，那么我们需要N束只含一枝花的。 假如N个人都买两枝花，那么我们可以利用之前的N束花， 所以我们只需要 N - N/2 假如N个人都买三枝花，那么我们可以利用之前的N + N2 束花， 所以我们只需要N - (N + N 2) / 3 但是这样下去是O(K)的，不行。 我们可以发现这么一个通式： 第i枝花需要: max(0, N - (preSum) / i) 所以我们可以通过 preSum / i + 1,来跳到下一个需要计算的。 代码123456789101112131415161718192021222324252627282930313233343536//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0; int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); ll n,k; while(cin &gt;&gt; n &gt;&gt; k)&#123; ll sum = 0; ll ans = 0; ll i = 1; while(i &lt;= k)&#123; ll cnt = n - sum / i; sum += cnt * i; ans += cnt; i = sum / n + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beauty of Trees]]></title>
    <url>%2F2018%2F05%2F08%2FBeauty-of-Trees%2F</url>
    <content type="text"><![CDATA[题意来源:第十四届华中科技大学程序设计竞赛决赛A 给你m个询问，每次询问包括一个区间，以及这个区间的异或和。 现在问你哪几个询问是错的。 $1≤M≤10^5$ $10^5≤l_i ≤r_i≤10^5$ 分析逻辑判断 带权并查集 对于每个l,r ： 若l和r不在一个集合中，则合并两个集合。 若l和r在同一个集合中，则先将l和r进行路径压缩，然后进行权值验证。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e5+5;int par[maxn],val[maxn]; int find(int x)&#123; if(par[x] == x) return x; int rt = find(par[x]); // ! val[x] = val[x] ^ val[par[x]]; return par[x] = rt;&#125;void merge(int l,int r,int w)&#123; int pl = find(l); int pr = find(r); if(pl != pr)&#123; val[pr] = val[l] ^ w ^ val[r]; // ! par[pr] = pl; &#125;&#125;bool same(int l,int r)&#123; return find(l) == find(r);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int n,m; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i=0;i&lt;=n;i++) par[i] = i; clr(val,0); bool flag = true; for(int i=0;i&lt;m;i++)&#123; int l,r,w; cin &gt;&gt; l &gt;&gt; r &gt;&gt; w; l--; if(!same(l,r)) merge(l,r,w); else if((val[r] ^ val[l]) != w)&#123; flag = false; cout &lt;&lt; i + 1 &lt;&lt; endl; &#125; &#125; if(flag) cout &lt;&lt; -1 &lt;&lt; endl; &#125; &#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经纬度]]></title>
    <url>%2F2018%2F05%2F05%2F%E7%BB%8F%E7%BA%AC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题意来源:牛客练习赛17D 给定地球的两个经纬度坐标，问这两个点的球面距离和直线距离的差。假设地球为球体，半径为6371009米。 分析球面上任意两点间弧长公式： 设所求点A ，纬度β1 ，经度α1 ；点B ，纬度β2 ，经度α2。则距离S=R·arc cos[cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2]，其中R为球体半径。 直线距离可以用 $S = R\times \theta$ $L = 2 \times R \times sin(\theta/2)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const double pi = acos(-1); int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; double R = 6371009; while(T--)&#123; double lat1,lng1,lat2,lng2; cin &gt;&gt; lat1 &gt;&gt; lng1 &gt;&gt; lat2 &gt;&gt; lng2; lat1 = lat1 / 180 * pi; lng1 = lng1 / 180 * pi; lat2 = lat2 / 180 * pi; lng2 = lng2 / 180 * pi; double lh = R * acos(cos(lat1)*cos(lat2)*cos(lng2-lng1) + sin(lat1)*sin(lat2)); // cout &lt;&lt; lh &lt;&lt; endl; double theta = lh / R; theta /= 2; // cout &lt;&lt; theta &lt;&lt; endl; double l = R * sin(theta) * 2; cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; lh - l &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[好位置]]></title>
    <url>%2F2018%2F05%2F05%2F%E5%A5%BD%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[题意来源:牛客练习赛17B 给出两个串s和x 定义s中的某一位i为好的位置，当且仅当存在s的子序列 满足y=x且存在j使得i=kj成立。 问s中是否所有的位置都是好的位置。 输入描述: 一行两个字符串s，x,这两个串均由小写字母构成。 1 &lt;= |s|, |x| &lt;= 200000 输出描述: Yes表示是。 No表示不是。 分析dp[i] 表示以s[i]结尾的最长匹配长度。 然后可以发现这个dp数组满足一个性质,所有的上升子序列长度都为x.size() 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 2e5+5;int dp[maxn];int last[200]; int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); string s,x; while(cin &gt;&gt; s &gt;&gt; x)&#123; int now = 0; dp[0] = 0; clr(last,-1); bool flag= true; for(int i=1;i&lt;=s.size();i++)&#123; if(now &lt; x.size() &amp;&amp; s[i - 1] == x[now])&#123; now ++ ; dp[i] = dp[i-1] + 1; last[s[i-1] - 'a'] = dp[i]; &#125; else&#123; dp[i] = last[s[i-1] - 'a']; if(dp[i] == -1)&#123; flag = false; break; &#125; &#125; &#125; if(!flag)&#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; int val = 0; for(int i=1;i&lt;=s.size();i++)&#123; if(dp[i] &lt; val) val = dp[i]; else if(dp[i] == val + 1) val++; &#125; if(val == x.size()) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[算法导论 学习博客 求最大值$$\begin{cases} B - A \leq c \\ C - A \leq b \\ C - B \leq a \\ \end{cases}$$ 这样求A到C的最大值就是 求min{a+c, b}, 即建图跑最短路。 求最小值$$\begin{cases} B - A \geq c \\ C - A \geq b \\ C - B \geq a \\ \end{cases}$$ 这样求A到C的最小值就是 求max{a+c,b}, 即建图跑最长路。 不等式的标准化如果题目中既有小于等于的关系也有大于等于的关系怎么办? 根据题目来，如果要求最大值，就要将所有的大于等于号改为小于等于号，求最小值同理 解的存在性无解： 出现了负环无穷多解： 图不连通]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2018%2F05%2F03%2FLIS%2F</url>
    <content type="text"><![CDATA[题意来源:zoj4028 构造一个长度为n的序列，满足以下条件： f[i] 表示以第i个元素结尾的最长上升子序列的长度。 l[i],r[i] 表示第i个元素的范围。 $1 \le n \le 10^5$ 分析差分约束 设d[i]表示第i个位置的元素。 $l[i] \leq d[i] \leq r[i] = l[i] \leq d[i] - d[0] \leq r[i]$ -&gt; $d[0] - d[i] \leq -l[i]$ -&gt; $d[i] - d[0] \leq r[i]$ 添加附加源 d[0] = 0 对于i &lt; k,如果 $f[k] == f[i]$, 则有 $d[k] - d[i] \leq 0$ 对于i &lt; k,如果 $f[k] = f[i] + 1$, 则有$d[k] - d[i] \geq 1$ -&gt; $d[i] - d[k] \leq -1$ 然后跑最短路即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)typedef long long ll;typedef pair&lt;int, int&gt; pii;typedef pair&lt;ll,ll&gt; pll;const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;const int maxn = 1e5 + 5;int f[maxn], l[maxn], r[maxn], loc[maxn];vector&lt;pii&gt; G[maxn];bool vis[maxn];int inq[maxn]; // 记录入队次数ll d[maxn];inline void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;inline void addedge(int u,int v,int w)&#123; G[u].pb(mp(v,w)); // G[v].pb(mp(u,w));&#125;bool spfa(int s,int n)&#123; for(int i=0;i&lt;=n;i++) &#123; d[i] = INF; inq[i] = 0; vis[i] = 0; &#125; d[s] = 0; queue&lt;int&gt; q; q.push(s); vis[s] = true; inq[s]++; while(!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for(auto &amp;V : G[u])&#123; int v = V.first; ll w = V.second; if(d[v] &gt; d[u] + w)&#123; d[v] = d[u] + w; if(!vis[v])&#123; vis[v] = true; inq[v]++; q.push(v); if(inq[v] &gt;= n) return false; &#125; &#125; &#125; &#125; return true;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; clr(loc, -1); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; f[i]; &#125; init(n); for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; l[i] &gt;&gt; r[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; addedge(0, i, r[i]); addedge(i, 0, -l[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (loc[f[i] - 1] != -1) &#123; int u = loc[f[i] - 1]; addedge(i, u, -1); &#125; if (loc[f[i]] != -1) &#123; int u = loc[f[i]]; addedge(u, i, 0); &#125; loc[f[i]] = i; &#125; spfa(0,n); for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) cout &lt;&lt; d[i]; else cout &lt;&lt; ' ' &lt;&lt; d[i]; &#125; cout &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Resource Distribution]]></title>
    <url>%2F2018%2F05%2F02%2FResource-Distribution%2F</url>
    <content type="text"><![CDATA[题意来源:cd967d 给n个服务器，每个服务器都有一个负载。 现在要组建两个大型服务器S1和S2，要求S1能负载x1，S2能负载x2. 每个大型服务器的负载都会平均分配到每个小服务器上。 每个服务器最多服务一个大型服务器。 问是否有满足条件的分配方案 $2 \leq n \leq 300\,000, 1 \leq x_1, x_2 \leq 10^9$ 分析有一个显而易见的性质：能选大的一定不选小的。 所以在数组排好序后，最后的结果一定是一段包含右端点的连续区间，现在问题就是S1和S2的次序问题，都枚举一下，有一个解就是yes。 一开始想着二分k，但是后来发现这个不满足单调的性质。赛后看了别人代码才明白。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pii pair&lt;int, int&gt;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 3e5 + 5;pii c[maxn];int x[2];vector&lt;int&gt; ans[2];bool work(int i1,int i2,int n)&#123; int s = -1; for(int i=0;i&lt;n;i++)&#123; if(c[i].first * (i + 1) &gt;= x[i1])&#123; s = i; break; &#125; &#125; if(s == -1) return false; for(int i=s+1;i&lt;n;i++)&#123; if(c[i].first * (i - s) &gt;= x[i2])&#123; for(int k=0;k&lt;=s;k++) ans[i1].pb(c[k].second); for(int k=s+1;k&lt;=i;k++) ans[i2].pb(c[k].second); return true; &#125; &#125; return false;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n &gt;&gt; x[0] &gt;&gt; x[1]) &#123; for(int i=0;i&lt;2;i++) ans[i].clear(); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c[i].first; c[i].second = i + 1; &#125; sort(c, c + n, greater&lt;pii&gt;()); if (work(0, 1, n) || work(1, 0, n)) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; cout &lt;&lt; ans[0].size() &lt;&lt; ' ' &lt;&lt; ans[1].size() &lt;&lt; endl; for (int i = 0; i &lt; 2; i++) &#123; for (auto I : ans[i]) cout &lt;&lt; I &lt;&lt; ' '; cout &lt;&lt; endl; &#125; &#125; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sequence Swapping]]></title>
    <url>%2F2018%2F05%2F02%2FSequence-Swapping%2F</url>
    <content type="text"><![CDATA[题意来源:15届浙江省赛D 给你一个由左右括号组成的字符串，每个位置的括号都对应一个权值。 现在可以做一个操作： 交换相邻位置的括号，若第k个括号是’(‘,并且第k+1个括号是’)’,则获得对应权值相乘的分数。 该操作可做无限次，问得到的最大权值是多少？ 字符串长度 $\leq 10^3$ $-10^3 \le$ 权值 $\le 10^3$ 分析首先需要注意到的是权值有正有负，这样就很难贪心了。 我们可以这么考虑，对于第i个左括号，如果它向右交换k个右括号,那么第i-1个左括号就可往右多交换k个。 根据这个思想就可以想到是个记忆化搜索的过程 $dp[i][k]:$ 表示第i个左括号向右至多交换k个右括号所得到的最大价值。 所以这里有一堆预处理等着你 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//ybmj#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)#define pb(x) push_back(x)#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pii pair&lt;int,int&gt; typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1e3+5;int num[maxn];char ch[maxn];ll dp[maxn][maxn];int pre[maxn][maxn]; // pre[i][k]: 第i个左括号向右交换k个右括号得到的价值int x[maxn]; //x[i] 表示i位置开始的后缀和（右括号的数量vector&lt;pair&lt;int,int&gt; &gt;le; // le[i]: 第i个左括号的位置和他右边右括号的数量vector&lt;pair&lt;int,int&gt; &gt; ri[maxn]; //ri[i]第i个左括号右边 每个右括号的位置和权值ll dfs(int pos,int cnt)&#123; // pos : i, cnt : k if(dp[pos][cnt] != -1) return dp[pos][cnt]; ll ret = 0; int k; if(cnt == 0)&#123; //不能交换和不交换有点区别 if(pos == 0) return 0; k = x[le[pos].first]; ret = dfs(pos-1,ri[pos-1].size() - k); if(ret&lt;0)ret = 0; dp[pos][cnt] = ret; return ret; &#125; for(int i=0;i&lt;=cnt;i++)&#123; if(i == cnt) &#123; k = x[ri[pos][cnt-1].first + 1]; &#125; else &#123; k = x[ri[pos][i].first]; &#125; if(pos == 0)&#123; ret = max(ret,1LL * pre[pos][i] * num[le[pos].first]); &#125; else ret = max(ret,dfs(pos - 1,ri[pos-1].size() - k) + 1LL*pre[pos][i] * num[le[pos].first]); &#125; if(ret &lt; 0) ret = 0; dp[pos][cnt] = ret; return ret;&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); int T; scanf("%d",&amp;T); while(T--)&#123; int n; scanf("%d",&amp;n); scanf("%s",ch); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; x[n] = 0; for(int i=n-1;i&gt;=0;i--)&#123; x[i] = x[i+1] + (ch[i] == ')'); &#125; le.clear(); for(int i=0;i&lt;n;i++)&#123; if(ch[i] == '(')&#123; int cnt = 0; for(int k=i+1;k&lt;n;k++)&#123; if(ch[k] == ')') cnt++; &#125; le.pb(mp(i,cnt)); int pos = le.size() - 1; ri[pos].clear(); for(int k=i+1;k&lt;n;k++)&#123; if(ch[k] == ')')&#123; ri[pos].pb(mp(k,num[k])); &#125; &#125; pre[pos][0] = 0; for(int k=1;k&lt;=ri[pos].size();k++)&#123; pre[pos][k] = pre[pos][k-1] + ri[pos][k-1].second; &#125; &#125; &#125; for(int i=0;i&lt;le.size();i++)&#123; for(int k=0;k&lt;=ri[i].size();k++)&#123; dp[i][k] = -1; &#125; &#125; ll ans; if(le.size() == 0) ans = 0; else ans = dfs(le.size()-1,ri[le.size()-1].size()); printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求值]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/E 来源：牛客网 题目描述 给定n个数字$a_1, a_2, …, a_n$。 定义$f(l, r) = a_l | a_{l+1}| … | a_r$。 现在枚举(1 &lt;= l &lt;= r &lt;= n)，问不同的f值一共有多少个。 输入描述: 第一行一个整数n表示数组大小 (1 &lt;= n &lt;= 100,000)； 第二行n个整数满足0 &lt;= $a_i$ &lt;= 1000,000。 输出描述: 输出一个整数表示不同的f值一共有多少个。 示例1 输入1231 2 0 输出14 示例2输入12101 2 3 4 5 6 1 2 9 10 输出111 分析数组内子串或和不同的数量 $dp[i][k]$ 表示第i位开始，第k数位为1的数字，第一次出现的位置 枚举左端点，对于每个数位，找离左端点最近的开始求或。 vis记录当前值是否出现过 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2000000;int num[100005];bool vis[maxn];int pos[100005][20];int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(vis,0,sizeof(vis)); memset(pos,-1,sizeof(pos)); for(int i=0;i&lt;n;i++) &#123; cin &gt;&gt; num[i]; int x = num[i]; int cnt = 0; while(x)&#123; int temp = x % 2; if(temp) pos[i][cnt] = i; cnt++; x &gt;&gt;= 1; &#125; &#125; for(int i=n-1;i&gt;=0;i--)&#123; for(int k=0;k&lt;20;k++)&#123; if(pos[i][k] != -1) continue; pos[i][k] = pos[i+1][k]; &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int now = num[i]; vector&lt;int&gt; v; for(int k=0;k&lt;20;k++)&#123; if(pos[i][k] != -1) v.push_back(pos[i][k]); &#125; sort(v.begin(),v.end()); if(!vis[now])&#123; vis[now] = 1; ans++; &#125; for(int k=0;k&lt;v.size();k++)&#123; now |= num[v[k]]; if(!vis[now])&#123; vis[now] = 1; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[任意点]]></title>
    <url>%2F2018%2F04%2F27%2F%E4%BB%BB%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/C 来源：牛客网 题目描述 平面上有若干个点，从每个点出发，你可以往东南西北任意方向走，直到碰到另一个点，然后才可以改变方向。 请问至少需要加多少个点，使得点对之间互相可以到达。输入描述: 第一行一个整数n表示点数（ 1 &lt;= n &lt;= 100)。 第二行n行，每行两个整数xi, yi表示坐标（ 1 &lt;= xi, yi &lt;= 1000)。 y轴正方向为北，x轴正方形为东。 输出描述: 输出一个整数表示最少需要加的点的数目。 示例1 输入12322 11 2 输出11 示例2 输入12322 14 1 输出10 分析将那些可以互相到达的点用并查集维护。 最后查看有几个不联通的 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn= 105;int x[maxn],y[maxn];int par[maxn];int find(int i)&#123; return i == par[i] ? i : par[i] = find(par[i]);&#125;void merge(int i,int k)&#123; i = find(i); k = find(k); par[i] = k;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; for(int i=0;i&lt;n;i++) par[i] = i; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int k=i + 1;k&lt;n;k++)&#123; if(x[i] == x[k] || y[i] == y[k])&#123; merge(i,k); &#125; &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; if(find(i) == i) ans++; &#125; cout &lt;&lt; ans - 1&lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漂亮的树]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%BC%82%E4%BA%AE%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题意链接：https://www.nowcoder.com/acm/contest/84/B来源：牛客网 题目描述 街上有n棵树，标号为1…n，第i棵树的高度为$a_i$。 定义这n棵树是漂亮的，当且仅当 对于所有的i，$a_i=a_n-i+1$； 对于1 &lt;= i &lt; n / 2 (不是整除)，$a_i + 1= a_i + 1$； 比如说 “2 3 4 5 5 4 3 2”和“1 2 3 2 1”是漂亮的而“1 3 3 1”和“1 2 3 1”不是 现在请问最少修改几棵树的高度（可以变大也可以变小），使得这些树是漂亮的。 输入描述: 第一行一个整数n表示树的数量（ 1 &lt;= n &lt;= 100,000)。 第二行n个整数表示树的高度（ 1 &lt;= ai &lt;= 100,000)。 输出描述: 输出一个整数表示最少修改树的高度的数目。 示例1 输入1232 2 2 输出11 示例2 输入1241 2 2 1 输出10 分析因为序列里只要一个数字确定，其他数字自然而然就确定了。 所以我们可以记录每位的偏移量，即第i位的偏移量就是num[i] - i.（前n/2个数） 然后我们可以枚举偏移量计算就可以啦。 注意偏移量可能为负数！ 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;typedef long long ll;const int maxn = 2e5+5;int num[maxn];int dp[2][maxn];int main()&#123; int n; while(cin &gt;&gt; n)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) cin &gt;&gt; num[i]; for(int i=0;i&lt;n/2;i++)&#123; dp[0][num[i] - i + 100001] ++; dp[1][num[n-i-1]-i + 100001]++; &#125; if(n &amp; 1) dp[0][num[n/2] - n/2 + 100001]++; int ans = INF; for(int i=0;i&lt;maxn;i++)&#123; int temp = n - dp[0][i] - dp[1][i]; ans = min(ans,temp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数根]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%95%B0%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[数根数根(又称数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根。 数根是将一正整数的各个位数相加(即横向相加)，若加完后的值大于等于10的话，则继续将各位数进行横向相加直到其值小于十为止，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。 [1] 推论设x在模k意义下的数根为d(x) 则 d(x) = x % (k-1)]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>数论</category>
        <category>树根</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vscode配置-cpp]]></title>
    <url>%2F2018%2F04%2F27%2Fvscode%2F</url>
    <content type="text"><![CDATA[My snippet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: // "Print to console": &#123; // "prefix": "log", // "body": [ // "console.log('$1');", // "$2" // ], // "description": "Log output to console" // &#125; "print to console":&#123; "prefix": "inc", "body": [ "//ybmj", "#include&lt;bits/stdc++.h&gt;", "using namespace std;", "#define lson (rt &lt;&lt; 1)", "#define rson (rt &lt;&lt; 1 | 1)", "#define lson_len (len - (len &gt;&gt; 1))", "#define rson_len (len &gt;&gt; 1)", "#define pb(x) push_back(x)", "#define clr(a, x) memset(a, x, sizeof(a))", "#define mp(x, y) make_pair(x, y)", "typedef long long ll;", "typedef pair&lt;int,int&gt; pii;", "typedef pair&lt;ll,ll&gt; pll;", "const int INF = 0x3f3f3f3f;", "const int NINF = 0xc0c0c0c0;", "", "int main()&#123;", "\t/*", "\t#ifndef ONLINE_JUDGE", "\tfreopen(\"1.in\",\"r\",stdin);", "\tfreopen(\"1.out\",\"w\",stdout);", "\t#endif", "\t*/", "\tstd::ios::sync_with_stdio(false);", "", "&#125;" ] &#125;&#125; launch.json12345678910111213141516171819202122232425262728&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", "type": "cppdbg", "request": "launch", "program": "$&#123;workspaceFolder&#125;/a.out", "args": [], "stopAtEntry": false, "cwd": "$&#123;fileDirname&#125;", "environment": [], "externalConsole": true, "MIMode": "gdb", "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "build" &#125; ]&#125; tasks.json1234567891011121314151617181920212223242526272829303132333435&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "command": "g++", "args": [ // Ask msbuild to generate full paths for file names. "-g", "-std=c++11", "$&#123;file&#125;" ], "group": &#123; "kind": "build", "isDefault": true &#125;, // Use the standard MS compiler pattern to detect errors, warnings and infos "problemMatcher": &#123; "owner": "cpp", "fileLocation":"absolute", "pattern":&#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125;, &#125; &#125; ]&#125; 字体Windows : 字体： Source Code Pro 渲染器： MacType]]></content>
      <categories>
        <category>工作环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈密顿图]]></title>
    <url>%2F2018%2F04%2F24%2F%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[哈密顿图哈密顿通路: 设G=&lt;V,E&gt;为一图(无向的或有向的),G中经过每个顶点一次且仅一次的通路 哈密顿回路: G中经过每个顶点一次且仅一次的回路 哈密顿图: 若G中存在哈密顿回路,则称G为哈密顿图 充分条件定理一设G是$n(n \geq 3)$阶无向简单图,若对于G中每一对不相邻的顶点u,v,均有$$d(u) + d(v) \geq n-1$$ 则G中存在哈密顿通路,又若$$d(u) + d(v) \geq n$$ 则G中存在哈密顿回路,即G为哈密顿图. 其中$d(v_i) = d^+(v_i) + d^-(v_i)$ 推论: 设G是$n(n \geq 3)$阶无向简单图,若 $\delta(G) \geq \frac{n}{2} $ 则G是哈密顿图. 定理二在$n(n\geq 2)$阶有向图D = &lt;V,E&gt;中,如果略去所有有向边的方向,所得无向图中含生成子图$K_n$,则D中存在哈密顿通路 必要条件设无向图G = &lt;V,E&gt;为哈密顿图,$V_1$是$V$的任意真子集,则$$p(G-V_1) \leq |V_1|$$ 其中,$p(G-V_1)$为从G中删除$V_1$后所得图的连通分支数. 推论: 有割点的图一定不是哈密顿图]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>哈密顿图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[插值查找]]></title>
    <url>%2F2018%2F04%2F24%2F%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[插值查找插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$$pos = low+\frac{val-num[low]}{num[high]-num[low]}(high-low) $$ 需要注意的是： $val &gt; num[low]$ $val &gt; num[high]$ 这两种情况要判一下下 时间复杂度 这个O(loglogN)的复杂度是平均期望复杂度，而不是最坏情况复杂度。 需要假设数据在某个范围内均匀分布。 代码12345678910111213141516int Search(int val) &#123; int l = 0, r = 100; int ans = -1; while (l &lt;= r) &#123; if (val &lt; num[l] || val - num[l] &gt; r - l) break; int m = l + (val - num[l]) * (r - l) / (a[r] - a[l]); if (ok(m)) &#123; ans = m; l = m + 1; &#125; else r = m - 1; &#125; if (ans == -1) cout &lt;&lt; "Find nothing" &lt;&lt; endl; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>查找算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合约数]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%90%88%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题意来源:shuoj507 给定一棵n个节点的树，并且根节点的编号为p，第i个节点有属性值$val_i$, 定义F(i): 在以i为根的子树中，属性值是$val_i$的合约数的节点个数。 y 是 x 的合约数是指 y 是合数且 y 是 x 的约数。 小埃想知道$\sum^n_{i = 1}i⋅F(i)对1000000007$取模后的结果。 1≤n≤20000, 1≤p≤n 1≤vali≤10000 ，1≤i≤n. 分析这题考察对递归性质的理解 当我走到某一结点u，我可以在O(sqrt(val[u]))的时间内找到目前所有是val[u]合约数的个数。 当我回溯到u的时候，再一次统计val[u]合约数的个数，二者相减即可得到u子树中，val[u]合约数的个数。 时间复杂度$O(n \times sqrt(val))$; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2e4 + 5;const int mod = 1e9 + 7;vector&lt;int&gt; G[maxn];int val[maxn];int num[maxn];bool vis[maxn];ll ans;void make_prime() &#123; clr(vis, 0); vis[0] = vis[1] = 1; for (ll i = 2; i &lt;= 10000; i++) &#123; if (!vis[i]) for (ll k = 2; i * k &lt;= 10000; k++) &#123; vis[i * k] = 1; &#125; &#125;&#125;void dfs(int u, int fa) &#123; ll temp = 0; for (int i = 1; i &lt; (int)sqrt(val[u]) + 1; i++) &#123; if (val[u] % i == 0) &#123; if (i != 1 &amp;&amp; vis[i]) temp += num[i]; if (i != val[u] / i &amp;&amp; (val[u] / i) != 1 &amp;&amp; vis[val[u] / i]) temp += num[val[u] / i]; &#125; &#125; for (auto v : G[u]) &#123; if (v != fa) &#123; dfs(v, u); &#125; &#125; num[val[u]]++; for (int i = 1; i &lt; (int)sqrt(val[u]) + 1; i++) &#123; if (val[u] % i == 0) &#123; if (i != 1 &amp;&amp; vis[i]) temp -= num[i]; if (i != val[u] / i &amp;&amp; (val[u] / i) != 1 &amp;&amp; vis[val[u] / i]) &#123; temp -= num[val[u] / i]; &#125; &#125; &#125; if (temp &gt; 0) assert(false); ans = (ans + (-temp) * u % mod) % mod;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); make_prime(); int T; cin &gt;&gt; T; while (T--) &#123; int n, p; cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= n; i++) G[i].clear(); clr(num, 0); for (int i = 0; i &lt; n - 1; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].pb(v); G[v].pb(u); &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; val[i]; ans = 0; dfs(p, -1); cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ultmaster 的小迷妹们]]></title>
    <url>%2F2018%2F04%2F23%2Fultmaster-%E7%9A%84%E5%B0%8F%E8%BF%B7%E5%A6%B9%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[题意来源:eoj2018.4.A 给你一个$n\times n$的正方形，和若干$x\times y$的长方形，问你是否能拼成一个更大的正方形。 $n,x,y (1≤n,x,y≤10^9)$ 分析我们可以把小正方形放到中心位置。 可以发现整个大的正方形可以分成四个对称的部分（除去中心的小正方形） 可以得到$\frac{n + k_1x}{y} = k_2$ 或者 $\frac{n + k_2y}{x} = k_1$ 即$k_2y - k_1x = n$ 或者 $k_1x - k_2y = n$ x，y要取正数解。即只要这个二元一次方程有解即可。 代码1234567891011121314151617181920212223242526272829303132333435// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int gcd(int a, int b) &#123; if (b) while ((a %= b) &amp;&amp; (b %= a)) ; return a + b;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, x, y; while (cin &gt;&gt; n &gt;&gt; x &gt;&gt; y) &#123; int a = min(x, y); int b = max(x, y); if (n % gcd(a, b) == 0) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Destruction of a Tree]]></title>
    <url>%2F2018%2F04%2F18%2FDestruction-of-a-Tree%2F</url>
    <content type="text"><![CDATA[题意来源：cf964d 一棵树，可以删去偶度点，问是否能删除掉整棵树？ 如果可以则输出删除顺序（spj） $(1 ≤ n ≤ 2·10^5)$ 分析递归 最近写不出来题目了，简单的递归瞎搞都写不来了。 对每个点，判断其度的奇偶（通过对未删除的边进行计数），若是偶数点则删除以该点为根的整棵子树。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2e5 + 5;vector&lt;int&gt; G[maxn];vector&lt;int&gt; ans;bool vis[maxn];void addedge(int u, int v) &#123; G[u].pb(v); G[v].pb(u);&#125;void remove(int u, int fa) &#123; if (vis[u]) return; vis[u] = true; ans.pb(u); for (auto v : G[u]) &#123; if (v == fa) continue; remove(v, u); &#125;&#125;void dfs(int u, int fa) &#123; int deg = fa == -1 ? 0 : 1; for (auto v : G[u]) &#123; if (v == fa) continue; dfs(v, u); if (!vis[v]) deg ^= 1; &#125; if (!deg) remove(u, fa);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); clr(vis, 0); ans.clear(); for (int i = 1; i &lt;= n; i++) &#123; int v; cin &gt;&gt; v; if (v != 0) addedge(i, v); &#125; dfs(1, -1); if (ans.size() != n) cout &lt;&lt; "NO" &lt;&lt; endl; else &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; endl; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alternating Sum]]></title>
    <url>%2F2018%2F04%2F18%2FAlternating-Sum%2F</url>
    <content type="text"><![CDATA[题意来源：cf 964C You are given two integers a and b. Moreover, you are given a sequence $s_0,s_1,…,s_n.$ All values in s are integers 1 or −1. It’s known that sequence is k-periodic and k divides n+1.In other words, for each k≤i≤n it’s satisfied that $s_i=s_i−k.$ Find out the non-negative remainder of division of $\sum^n_{i = 0}s_ia^{n-1}b^i$ by $10^9+9$ Note that the modulo is unusual! $(1 \leq n \leq 10^{9}, 1 \leq a, b \leq 10^{9}, 1 \leq k \leq 10^{5})$ 分析等比数列求和 每个位置的元素，经过一个周期就会变成原来的$a^{-k}b^k$倍，所以可以用等比数列求和。 没有看到题目中说$(n+1) \% k == 0$，所以我的做法是对任何n都适用的。 需要注意的是如何需要判断公比为1的特殊情况（当时直接认为a等于b时才会出现公比为1的情况，事实上因为它不断地在模，所以即使不相等，模完之后也可能相等） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9 + 9;ll n, a, b, k;ll my_pow(ll a, ll b) &#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ret;&#125;ll work(int i) &#123; ll m = (n - i) / k + 1; // ll m = (n + 1) / k; ll ret = 0; ll temp = my_pow(b, k) * my_pow(my_pow(a, k), mod - 2) % mod; if (temp == 1) return m * my_pow(a, n - i) % mod * my_pow(b, i) % mod; // wa temp = (1 - temp + mod) % mod; ret = (ret + my_pow(a, n - i) * my_pow(b, i) % mod) % mod; ll idx = n - i - m * k; if (idx &gt;= 0) ret = (ret - my_pow(b, m * k + i) * my_pow(a, idx) % mod + mod) % mod; else ret = (ret - my_pow(b, m * k + i) * my_pow(my_pow(a, -idx), mod - 2) % mod + mod) % mod; ret = ret * my_pow(temp, mod - 2) % mod; return ret;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k) &#123; string line; cin &gt;&gt; line; ll ans = 0; for (int i = 0; i &lt; line.size() &amp;&amp; i &lt;= n; i++) &#123; if (line[i] == '+') &#123; ans = (ans + work(i)) % mod; &#125; else &#123; ans = (ans - work(i) + mod) % mod; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[序列变换]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BA%8F%E5%88%97%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj508 描述 给定两个长度为n的序列，$a_i,b_i(1≤i≤n)$, 通过3种魔法使得序列a变换为序列b，也就是$a_i=b_i(1≤i≤n)$. 魔法1： 交换$a_i$和$a_j$，i≠j 首先通过若干次的魔法1将序列a变换成序列c 魔法2： 对1个数乘2或者加1 魔法3： 对1个数除以2或者减1，如果是奇数，则不能除以2 若$c_i&gt;b_i$, 则只能对$c_i$实施魔法3，若$c_i&lt;b_i$, 则只能对$c_i$实施魔法2. 例如$c_i=6, b_i=4$, 则可以通过对ci实施2次减1操作(魔法3)将$c_i$变为$b_i$, 但不可以对$c_i$除以2再加1将$c_i$变为$b_i$，因为$c_i&gt;b_i$, 所以不能对$c_i$实施加1操作(魔法2). 小埃想通过最少的操作次数使得序列a变成序列b， 操作次数是指使用的魔法次数。 输入 输入测试组数T，每组数据，第一行输入n，1≤n≤9,紧接着输入两行，每行n个整数，前一行为$a_1,a_2,…,a_n$,后一行为$b_1,b_2,…,b_n$.其中$1≤a_i,b_i≤10^8,1≤i≤n.$ 输出 每组数据输出一个整数，表示最少的操作次数 分析由于n只有9，因为9! = 3e5, 所以这是个可以暴力的数据（枚举所有全排列） 对于魔法一： 将序列a1通过交换变成序列a2，最小花费的步数？ 第一个要注意的是如何进行全排列，如果直接对a中元素全排列，这样在求魔法一时非常困难，因为没有办法快速找到当前元素本来的位置。 所以我们通过对下标进行全排列。 idx[i]： 表示重新排列后在i位置上的元素，其在a数组中的下标。 这样对于第i位元素，我就知道它原来的位置是idx[i]。 从i开始搜，如果idx[i]未访问过，就继续搜下去。 这样最后就得到一个环，假设里面有n个元素，这样说明他的交换次数是n-1。 这个做法对于数列元素都不相同的题目可以做。 如果数列元素有重复，那么这么做出来的结果不一定对。 这道题可以是以为它有一个全排列。 魔法二三： 预处理a中每一个数变成b中每一个数所需要的次数。 这里有一个小技巧，因为将一个大数变成一个小数是可以贪心的！ 但是将一个小数变成一个大数是不能贪心的！ 但是！ 大数变小数 和 小数变大数是对称的！！ 做完了 难点在于： 对下标进行全排列 计算通过交换元素使得两数组相同的最小步数 大数变小数的过程与小数变大数的过程是对称的 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 10;int maps[maxn][maxn];int a[maxn], b[maxn], idx[maxn];bool vis[maxn];int n;int dfs(int pos) &#123; vis[pos] = true; // if(a[idx[pos]] == b[pos]) return 0; if (!vis[idx[pos]]) &#123; return dfs(idx[pos]) + 1; &#125; else return 0;&#125;int work() &#123; int ret = 0; clr(vis, 0); for (int i = 0; i &lt; n; i++) if (!vis[i]) ret += dfs(i); for (int i = 0; i &lt; n; i++) &#123; ret += maps[idx[i]][i]; &#125; return ret;&#125;int cal(int x, int y) &#123; if (x == y) return 0; if (x &lt; y) swap(x, y); int ret = 0; while (x &gt; y) &#123; while ((x &amp; 1) == 0 &amp;&amp; (x &gt;&gt; 1) &gt;= y) &#123; x &gt;&gt;= 1; ret++; &#125; if (x &gt; y &amp;&amp; (x &gt;&gt; 1) &lt; y) &#123; ret += x - y; break; &#125; if (x &gt; y) &#123; x--; ret++; &#125; &#125; return ret;&#125;int main() &#123; /*#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif*/ std::ios::sync_with_stdio(false); int T; scanf("%d", &amp;T); // cin &gt;&gt; T; while (T--) &#123; scanf("%d", &amp;n); // cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", a + i); // cin &gt;&gt; a[i]; idx[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", b + i); // cin &gt;&gt; b[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; n; k++) &#123; maps[i][k] = cal(a[i], b[k]); &#125; &#125; int ans = INF; do &#123; ans = min(ans, work()); &#125; while (next_permutation(idx, idx + n)); printf("%d\n", ans); // cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1+2=3?]]></title>
    <url>%2F2018%2F04%2F16%2F1-2-3%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj511 x⊕2x=3x 求满足上述条件的第N个数字。（保证最后结果在longlong范围内） $N≤10^{12}$ 分析数位dp + 二分二分最后答案，然后数位dp去找小于等于二分答案的满足要求的数的数量。 数位dp + 模拟满足上述条件的数字，其二进制表示下，一定是没有“11”出现的。 所以我们可以小小的数位dp一下。 $dp[i][k]$ 表示数位长度为i的，最高位（第i位）为k的，满足条件的数的数量。 接下来就是超级无敌爆炸讨厌的模拟过程。 先找最高位的1在哪里，这里需要预处理前缀和. 然后从最高位的1后面开始枚举，如果前一位为1，那么当前位必为0，直接转移就可以。如果前一位为0，那么当前位可以为0，也可以为1。 所以先看看当前位为0的话总共会有多少种情况，如果大于等于n，则当前位为0，否则当前位为1，并且要减去这个情况的数量。然后继续找下一位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[65][2]; // dp[i][k] i长度的数字，最高位为k，一共有多少中满足条件情况。int num[100];ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return !lead; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 1; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (i &amp;&amp; sta) continue; ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, i); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;ll solve(ll n) &#123; int pos = 0; while (n) &#123; num[pos++] = n % 2; n &gt;&gt;= 1; &#125; return dfs(pos - 1, true, true, 0);&#125;void work(ll n) &#123; ll l = 1, r = 1e18; ll ans; while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (solve(mid) &gt;= n) &#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); clr(dp, -1); int T; cin &gt;&gt; T; while (T--) &#123; ll n; cin &gt;&gt; n; work(n); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// ybmj// I hate this problem!!!#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[65][2]; // dp[i][k] i长度的数字，最高位为k，一共有多少中满足条件情况。ll pre[65]; // pre[i] dp的前缀和，长度最多为i的数字，一共有多少种满足条件的情况ll P[65]; // 预处理2的幂次ll dfs(int pos, bool lead, int sta) &#123; if (pos == -1) return !lead; if (!lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; ll ans = 0; if (lead &amp;&amp; sta == 0) ans += dfs(pos - 1, true, 0); else if (sta == 0 &amp;&amp; pos != 0) &#123; ans += dfs(pos - 1, false, 0); ans += dfs(pos - 1, false, 1); &#125; else if (sta == 1) ans += dfs(pos - 1, false, 0); if (!lead) dp[pos][sta] = ans; return ans;&#125;void work(ll n) &#123; int pos = -1; vector&lt;ll&gt; ans; for (int i = 61; i &gt;= 0; i--) &#123; if (n &gt; pre[i]) &#123; pos = i; n -= pre[i]; ans.pb(1); break; &#125; &#125; for (int i = pos; i &gt;= 0; i--) &#123; if (ans[ans.size() - 1] == 1) &#123; ans.pb(0); &#125; else &#123; if (n &lt;= dp[i][0]) &#123; ans.pb(0); &#125; else &#123; n -= dp[i][0]; ans.pb(1); &#125; &#125; &#125; ll ret = 0; for (int i = ans.size() - 1; i &gt;= 0; i--) &#123; ret += ans[i] * P[ans.size() - 1 - i]; &#125; cout &lt;&lt; ret &lt;&lt; endl;&#125;void init() &#123; clr(dp, -1); dp[0][0] = 1; dfs(63, true, 1); pre[0] = dp[0][1]; for (int i = 1; i &lt; 62; i++) &#123; pre[i] = pre[i - 1] + dp[i][1]; &#125; P[0] = 1; for (int i = 1; i &lt; 63; i++) &#123; P[i] = P[i - 1] * 2LL; &#125;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); init(); int T; cin &gt;&gt; T; while (T--) &#123; ll n; cin &gt;&gt; n; if (n == 1) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; work(n); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[K序列]]></title>
    <url>%2F2018%2F04%2F16%2FK%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题意来源：shuoj517 给一个数组a，长度为n，若某个子序列中的和为K的倍数，那么这个序列被称为“K 序列”。现在要你对数组a 求出最长的子序列的长度，满足这个序列是K 序列。 $1≤n≤10^5,1≤a[i]≤10^9, 1≤nK^2≤10^7$ 分析小数据的话用二维dp $dp[i][k]$ 表示前i个元素，和的余数为k，的最长子序列的长度 转移方程：$dp[i][(k + a[i])\% K] = max(dp[i-1][(k+a[i])\%K],dp[i-1][k]+1)$ 但是由于题目数据很大，所以我们需要滚动第一维，所以递推方程变为： $dp[i \&amp; 1][(k + a[i]) \% K]= max(dp[(i \&amp; 1) \bigoplus 1][(k + a[i]) \% K],dp[(i \&amp; 1) \bigoplus 1][k] + 1)$ 一开始想到了二维dp，但是因为对滚动反应不够，所以就放弃了那个想法。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 1e5 + 5;int a[maxn];int dp[2][maxn];int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int n, K; while (cin &gt;&gt; n &gt;&gt; K) &#123; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; a[i] %= K; &#125; clr(dp, 0xc0); dp[0][0] = 0; // dp[i][k] 前i个，余数为k，的最长子序列长度 for (int i = 1; i &lt;= n; i++) &#123; for (int k = 0; k &lt; K; k++) &#123; dp[i &amp; 1][(k + a[i]) % K] = max(dp[(i &amp; 1) ^ 1][(k + a[i]) % K], dp[(i &amp; 1) ^ 1][k] + 1); // dp[i][(k + a[i]) % K] = // max(dp[i - 1][(k + a[i]) % K], dp[i - 1][k] + 1); &#125; &#125; /* for (int i = 1; i &lt;= n; i++) &#123; for (int k = 0; k &lt; K; k++) &#123; cout &lt;&lt; dp[i][k] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; */ cout &lt;&lt; dp[n &amp; 1][0] &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Guard Duty (medium)]]></title>
    <url>%2F2018%2F04%2F16%2FGuard-Duty-medium%2F</url>
    <content type="text"><![CDATA[题意来源：cd 958 e2 从一个数组中选Ｋ个不相邻的数，使得和最小。 K, N (2 ≤ 2K ≤ N ≤ 500000, K ≤ 5000) 分析对于小数据，我们可以用ｄｐ做。 $dp[i][k][vis]$ 表示从前ｉ个里面选ｋ个，ｖｉｓ表示第ｉ位有没有选。 转移方程: $$dp[i][k][0] = min(dp[i-1][k][0],dp[i-1][k][1])$$ $$dp[i][k][1] = min(dp[i-1][k-1][0],dp[i-1][k-1][1]) + cost[i]$$ 对于原题中的数据就不能这么做啦。 最朴素的想法是每次取最小的元素，但是这么贪心明显是错误的，因为最小的元素不一定在最终的答案里。 为什么最小的元素不一定在最终的答案里呢？ a[] = {4 ,1, 5, 100}; 我们会先取1，然后再取100,。 但是4 + 5 &lt; 1 + 100 所以我们在贪心的时候，每取一个数，则要把他相应的“补救措施”也放进这个贪心的过程中。 所谓的补救措施就是：不取当前元素，而取其相邻的两个元素。 这里有个性质： 如果4 或 5其中一个在最后的答案里，那么这个答案一定不是最优的，因为我可以将其替换成1，而不影响其它元素的选取。 为什么是两个？ 看上面的例子，当我们取第二个元素时，我们取到了100。 但如果考虑其”补救措施“，那么我们取到的就应该是 4 + 5 - 1. 这里因为有元素的删除，我们采用静态双向链表实现。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x7fffffff;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 5e5 + 5;ll a[maxn], d[maxn], pre[maxn], nxt[maxn];bool vis[maxn];int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int k, n; while (cin &gt;&gt; k &gt;&gt; n) &#123; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt; &gt;, greater&lt;pair&lt;ll, int&gt; &gt; &gt; pq; for (int i = 1; i &lt; n; i++) &#123; d[i] = a[i] - a[i - 1]; pre[i] = i - 1; nxt[i] = i + 1; vis[i] = 0; pq.push(mp(d[i], i)); &#125; d[0] = d[n] = INF; ll ans = 0; for (int i = 0; i &lt; k; i++) &#123; while (true) &#123; if (pq.empty()) break; int i = pq.top().second; pq.pop(); if (vis[i]) continue; ans += d[i]; d[i] = -d[i]; vis[pre[i]] = true; d[i] += d[pre[i]]; pre[i] = pre[pre[i]]; nxt[pre[i]] = i; vis[nxt[i]] = true; d[i] += d[nxt[i]]; nxt[i] = nxt[nxt[i]]; pre[nxt[i]] = i; pq.push(mp(d[i], i)); break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>杂题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优先队列比较器]]></title>
    <url>%2F2018%2F04%2F15%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1234567struct cmp &#123; bool operator () (int i, int j) &#123; return a[i] &gt; a[j]; &#125;&#125;;priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;]]></content>
      <categories>
        <category>ACM</category>
        <category>比较器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Trie]]></title>
    <url>%2F2018%2F04%2F13%2FTrie%2F</url>
    <content type="text"><![CDATA[介绍功能：主要用于保存字符集合。 优点：可以在$O(len)$ ($len$为要查询单词长度) 时间内查询某个单词是否存在。 缺点：需要大量的储存空间。典型的用空间换时间。 思想：前缀树，顾名思义，通过记录每个单词的前缀来保存单词。 每个值为1的节点，代表这个单词存在。 上图的单词为： al,le,lk,f,fx. 数组开多大合适？ 如果有100个单词，每个单词长度不超过500，且全是小写字母。 那么我们假设每个单词单独是一条链，一共有100条链，每条链长度为500，所以$maxnode = 100\times500$ $types = 26$ 因为有26个字母。 代码：123456789101112131415161718192021222324252627282930//数组版struct Trie &#123; int ch[maxnode][types]; int val[maxnode]; int sz; void init() &#123; memset(ch[0], 0, sizeof(ch[0])); sz = 1; &#125; inline int idx(char x) &#123; return x - 'a'; &#125; void insert(string line, int key) &#123; int u = 0; for (int i = 0; i &lt; line.size(); i++) &#123; int v = idx(line[i]); if (ch[u][v] == 0) &#123; memset(ch[sz], 0, sizeof(ch[sz])); val[sz] = 0; ch[u][v] = sz++; &#125; u = ch[u][v]; &#125; val[u] = key; &#125; void find();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738//左儿子，右兄弟版。 减少储存空间。struct Trie &#123; int head[maxnode]; // the i'th son. int next[maxnode]; // the i'th brother. char ch[maxnode]; int tot[maxnode]; int sz; void init() &#123; ans = 0; tot[0] = head[0] = next[0] = 0; sz = 1; &#125; void insert(string line) &#123; int u = 0, v; tot[0]++; for (int i = 0; i &lt; line.size(); i++) &#123; bool found = false; for (v = head[u]; v != 0; v = next[v]) &#123; if (ch[v] == line[i]) &#123; found = true; break; &#125; &#125; if (!found) &#123; v = sz++; tot[v] = head[v] = 0; ch[v] = line[i]; next[v] = head[u]; head[u] = v; &#125; u = v; tot[u]++; &#125; &#125;&#125;; 题目Remember the Word UVA - 1401 Trie + dp题意给出一个由n个不同单词组成的字典和一个长字符串。把这个字符串分解成若干个单词的连接（单词可以重复使用），有多少种方法？比如：有4个单词a,b,cd,ab,则abcd有两种分解方法: a+b+cd 和 ab+cd. 所有单词总共长度不超过300000。长字符串个数不超过4000. 每个长字符串不超过100。 全是小写字母。 分析对于每个长字符串line,123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990转移方程则为$$dp[i] =\sum(dp[i + prefix(i...L)])$$其中prefix(i..L) 表示从i到末尾这个字符串的每个前缀。若该前缀在字典树中存在则加上相应的dp的值。比如： abcdef设i为3，则prefix(3..5) 是 def,de,d ，为def的前缀。### 代码```cpp// ybmj#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int mod = 20071027;const int maxn = 300005;const int sigma_size = 26;const int maxnode = 4005 * 100; //words number * words lengthint dp[maxn];struct Trie&#123; int ch[maxnode][sigma_size]; int val[maxnode]; int sz; void init()&#123; memset(ch[0],0,sizeof(ch[0])); sz = 1; &#125; int idx(char c)&#123; return c - &apos;a&apos;; &#125; void insert(string line,int v)&#123; int u = 0; for(int i=0;i&lt;line.size();i++)&#123; int now = idx(line[i]); if(!ch[u][now])&#123; memset(ch[sz],0,sizeof(ch[sz])); val[sz] = 0; ch[u][now] = sz++; &#125; u = ch[u][now]; &#125; val[u] = v; &#125; int query(const string &amp;line)&#123; memset(dp,0,sizeof(dp)); dp[line.size()] = 1; for(int i=line.size()-1;i &gt;= 0;i --)&#123; int now = 0; for(int k=0;k+i &lt; line.size();k++)&#123; int temp = idx(line[i+k]); if(!ch[now][temp]) break; now = ch[now][temp]; if(val[now])&#123; dp[i] = (dp[i] + dp[i+k+1]) % mod; &#125; &#125; &#125; return dp[0]; &#125;&#125;;Trie trie;int main()&#123; /* #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif */ std::ios::sync_with_stdio(false); string line; int kase = 1; while(cin &gt;&gt; line)&#123; int n; trie.init(); cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; string temp; cin &gt;&gt; temp; trie.insert(temp,1); &#125; int ans = trie.query(line); cout &lt;&lt; &quot;Case &quot; &lt;&lt; kase++ &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl; &#125;&#125; “strcmp()” Anyone? UVA - 11732 左兄弟右儿子版题意strcmp比较两个字符串的次数,比如比较than 和 that,需要比较7次才能判断是否相等，比较there 和 the 也需要比较7次（因为结尾有’\0’）。 给定n个字符串，问需要比较总的次数是多少？ 最多4000个字符串，每个串不超过1000个字符。 分析将所有字符串都插入字典树中，对于每个插入的节点，其权值加一。 其余看代码吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 4005;const int maxnode = maxn * 1000;struct Trie &#123; int head[maxnode]; // the i'th son. int next[maxnode]; // the i'th brother. char ch[maxnode]; ll tot[maxnode]; int sz; ll ans; void init() &#123; ans = 0; tot[0] = head[0] = next[0] = 0; sz = 1; &#125; void insert(string line) &#123; int u = 0, v; tot[0]++; for (int i = 0; i &lt; line.size(); i++) &#123; bool found = false; for (v = head[u]; v != 0; v = next[v]) &#123; if (ch[v] == line[i]) &#123; found = true; break; &#125; &#125; if (!found) &#123; v = sz++; tot[v] = head[v] = 0; ch[v] = line[i]; next[v] = head[u]; head[u] = v; &#125; u = v; tot[u]++; &#125; &#125; void debug() &#123; for (int i = 0; i &lt; 7; i++) cout &lt;&lt; tot[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; void query(int u, int depth) &#123; if (head[u] == 0) &#123; ans += tot[u] * (tot[u] - 1) * depth; &#125; else &#123; int sum = 0; for (int v = head[u]; v != 0; v = next[v]) &#123; sum += tot[v] * (tot[u] - tot[v]); &#125; ans += sum / 2 * (2 * depth + 1); for (int v = head[u]; v != 0; v = next[v]) &#123; query(v, depth + 1); &#125; &#125; &#125;&#125;;Trie trie;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; int kase = 1; while (cin &gt;&gt; n) &#123; if (n == 0) break; trie.init(); for (int i = 0; i &lt; n; i++) &#123; string line; cin &gt;&gt; line; line.push_back('!'); //代替'\0' trie.insert(line); &#125; // trie.debug(); trie.query(0, 0); cout &lt;&lt; "Case " &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; trie.ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
        <category>Trie</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2018%2F04%2F13%2FKMP%2F</url>
    <content type="text"><![CDATA[思想 如图，进行第一次匹配的时候，在红色地方失配，接下来第二次直接从位置二开始匹配，这就是kmp算法的精髓。 去寻找最长的公共前后缀，一旦失配，直接“后缀变前缀”，从上图来说ababe,最长公共前后缀就是ab,（不考虑e，因为假设在e处失配）。 这个back数组的含义就是：在第i位失配之后，[0, back[i]-1] 已经是成功的匹配了。 只要继续匹配第i位和back[i]即可。 模板1234567891011121314151617181920212223242526272829/*在0处失配，就表示模式串该向右移动了，标志为-1.*/struct KMP&#123; int back[maxn]; void getfail(string line)&#123; int i,k; k = back[0] = -1; i = 0; while(i &lt; line.size())&#123; while(k != -1 &amp;&amp; line[i] != line[k]) k = back[k]; back[++i] = ++k; &#125; &#125; int match(string T,string P)&#123; int i = 0,k = 0; int ret = 0; getfail(P); while(i &lt; T.size())&#123; while(k != -1 &amp;&amp; T[i] != P[k]) k = back[k]; ++i;++k; if(k &gt;= P.size())&#123; ret++; k = back[k]; &#125; &#125; return ret; &#125;&#125;; 题目Period UVA - 1371 back数组的应用题意给定一个长度为$n(2\leq n \leq 10^6)$的字符串S，求它每个前缀的最短循环节，换句话说，对于每个$i(2\leq i\leq n)$,求个一个最大的整数$K(K \geq 1)$（如果K存在），使得S的前i个字符组成的前缀是某个字符串重复K次得到的。输出所有存在K的i和对应的K。 比如对于字符串aabaabaabaab,只有当i = 2,6,9,12时K存在,且分别为2，2，3，4. 分析回想一下mp中getfail函数的含义。求第i个字符前的最长公共前后缀。 a b c a b c a b c a b c a b c a b c 如图，back[8] = 5,说明最后一位前面最长公共前后缀的长度为5，算上最后一位，那么最长公共前后缀的长度就为6. 试想，最长的前后缀有六位相同，也就是说中间有重叠的三个。 如图， 1 = a, 2 = b, 3 = c. 2 = a , 3 = b. 所以1 = 2 = 3 = a = b = c. a b c e e a b c a b c e e a b c 如图， 1 = a, 2 = b, 3 = c. 3 = a. 所以没有循环节。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ybmj#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;const int maxn = 1000000 + 5;struct MP &#123; int back[maxn]; void getFail(string P) &#123; back[0] = back[1] = 0; for (int i = 1; i &lt; P.size(); i++) &#123; int k = back[i]; while (k &amp;&amp; P[i] != P[k]) k = back[k]; back[i + 1] = P[i] == P[k] ? k + 1 : 0; &#125; // for (int i = 0; i &lt; P.size(); i++) &#123; // cout &lt;&lt; P[i] &lt;&lt; ' ' &lt;&lt; back[i] &lt;&lt; endl; // &#125; &#125;&#125;;MP mp;int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; int kase = 1; while (cin &gt;&gt; n) &#123; if (n == 0) break; string line; cin &gt;&gt; line; // cout &lt;&lt; line &lt;&lt; endl; mp.getFail(line); cout &lt;&lt; "Test case #" &lt;&lt; kase++ &lt;&lt; '\n'; for (int i = 2; i &lt;= line.size(); i++) &#123; if (mp.back[i] &gt; 0 &amp;&amp; i % (i - mp.back[i]) == 0) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; i / (i - mp.back[i]) &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125;&#125; Obsessive String CodeForces - 494B mp + dp题意给定一个字符串T，让你选两个集合$A(a_i)，B(b_i)$，对于其中的$s_{a_i} ··· s_{b_i}$,含有指定字符串P。问总共有多少种不同的集合？ 结果模1e9+7. $(1 \leq T,P \leq 10^5)$ 分析我们只要保证所选的$s_{a_i} ··· s_{b_i}$中至少包含一个P串即可。 考虑dp。 dp[i] 表示以第i个字符结尾的前i个字符的选择方式。 关键是如何转移？ 假设P串的长度为m。 当T[i-m+1 … i] 与P串不同时,dp[i] = dp[i-1]. 否则，我们可以将 T[k…i] (k &lt; i-m+1) 作为集合中的一个确定的元素$(a_z = k,b_x = i)$，然后我们可以从T[1…k]中选择子串放到这个集合中，这样的选择一共有$\sum_{x=1}^{i-m} (sum[x]+1)$.多加1是因为，这个子串我可以什么都不选。 sum[i] 表示第i个字符前一共有多少种选择方式。 那么如何判断T[i-m+1 .. i] 与P串是否相同呢？ 当然是用mp算法，若相同，则将flag[i]记为1，否则为0. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;iomanip&gt;using namespace std;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9+7;const int maxn = 100005;bool flag[maxn];int dp[maxn],sum[maxn],tot[maxn];struct MP&#123; int back[maxn]; void getfail(string P)&#123; back[0] = back[1] = 0; for(int i=1;i&lt;P.size();i++)&#123; int k = back[i]; while(k &amp;&amp; P[i] != P[k]) k = back[k]; back[i+1] = P[i] == P[k] ? k+1 : 0; &#125; &#125; void match(string T,string P)&#123; getfail(P); int k = 0; for(int i=0;i&lt;T.size();i++)&#123; while(k &amp;&amp; T[i] != P[k]) k = back[k]; if(T[i] == P[k]) k++; if(k == P.size())&#123; flag[i] = 1; k = back[k]; &#125; &#125; &#125;&#125;;MP mp;int main()&#123; #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif std::ios::sync_with_stdio(false); string T,P; while(cin &gt;&gt; T &gt;&gt; P)&#123; memset(flag,0,sizeof(flag)); mp.match(T,P); dp[0] = 0; sum[0] = 0; tot[0] = 0; for(int i=1;i&lt;=T.size();i++)&#123; if(flag[i-1])&#123; dp[i] = (tot[i-P.size()] +i-P.size()+1) % mod; sum[i] = (sum[i-1] + dp[i]) % mod; tot[i] = (tot[i-1] + sum[i]) % mod; &#125; else&#123; dp[i] = dp[i-1]; sum[i] = (sum[i-1] + dp[i]) % mod; tot[i] = (tot[i-1] + sum[i]) % mod; &#125; &#125; cout &lt;&lt; sum[T.size()] &lt;&lt; '\n'; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉路]]></title>
    <url>%2F2018%2F04%2F12%2F%E6%AC%A7%E6%8B%89%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[莫名其妙之前总结的不见了，只好ｃｏｐｙ一下蔡大佬的嘻嘻 基本概念欧拉图: 能够没有重复地一次遍历所有边的图。（必须是连通图） 欧拉路: 上述遍历的路径就是欧拉路。 欧拉回路: 若欧拉路是闭合的（一个圈，从起点开始遍历最终又回到起点），则为欧拉回路。 无向图G有欧拉路径的充要条件 G是连通图 G中奇顶点（连接边的数量为奇数）的数量等于0或2. 无向图G有欧拉回路的充要条件 G是连通图 G中每个顶点都是偶顶点 有向图G有欧拉路径的充要条件 G是连通图 u的出度比入度大1，v的出度比入度小1，其他所有点出度和入度相同。（u为起点，v为终点） 有向图G有欧拉回路的充要条件 G是连通图 G中每个顶点的出度等于入度 模板123456789101112131415int G[maxn][maxn];int deg[maxn][maxn];vector&lt;int&gt; Ans;void init() &#123; clr(G, 0), clr(deg, 0); &#125;void addedge(int u, int v) &#123; deg[u]++, deg[v]++, G[u][v]++, G[v][u]++; &#125;void Fleury(int s)&#123; for (int i = 0; i &lt; n; i++) if (G[s][i]) &#123; G[s][i]--, G[i][s]--; Fleury(i); &#125; Ans.pb(s);&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>欧拉路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[吉哥系列故事――恨7不成妻]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%95%E2%80%95%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 4507 如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 整数中某一位是7； 整数的每一位加起来的和是7的整数倍； 这个整数是7的整数倍； 吉哥想知道在一定区间内和7无关的数字的平方和。 分析我们分析一个整数平方和的拆分$A^2 = (a + b + c + d) ^ 2 = a^2 + 2 \times a \times (b + c + d) + (b + c + d)^2$ 发现是可以递归计算的。 式子中需要用到数的和（sum） 而计算数的和需要用到数的个数 所以我们要维护三个值： cnt 满足条件数的个数 sum 满足条件数的和 squ 满足条件数的平方和 squ的计算方法上面已经给出来了，那么sum怎么计算呢？ 假设枚举到第i位，那么这一位的贡献就是 val pow(10,i) cnt val是当前数位的值，cnt是枚举到第i+1位时满足条件数的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int mod = 1e9 + 7;int num[20];ll Pow[20];struct P &#123; ll cnt, squ, sum; P() &#123; cnt = -1; squ = sum = 0; &#125; P(int c, int s1, int s2) : cnt(c), sum(s1), squ(s2) &#123;&#125;&#125;;P dp[20][20][20];P dfs(int pos, bool limit, int sum, int mul) &#123; if (pos == -1) &#123; P ret(0, 0, 0); if (sum &amp;&amp; mul) ret.cnt = 1; return ret; &#125; if (!limit &amp;&amp; dp[pos][sum][mul].cnt != -1) return dp[pos][sum][mul]; int up = limit ? num[pos] : 9; P ans(0, 0, 0); for (int i = 0; i &lt;= up; i++) &#123; if (i == 7) continue; P temp = dfs(pos - 1, limit &amp;&amp; i == up, (sum + i) % 7, (mul * 10 + i) % 7); ll A = i * Pow[pos] % mod; ans.cnt += temp.cnt % mod; ans.cnt %= mod; ans.sum += (A * temp.cnt % mod + temp.sum) % mod; ans.sum %= mod; ans.squ += ((A * A % mod * temp.cnt % mod + 2 * A % mod * temp.sum) % mod + temp.squ) % mod; ans.squ %= mod; &#125; if (!limit) dp[pos][sum][mul] = ans; return ans;&#125;P solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 0, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; Pow[0] = 1; for (int i = 1; i &lt; 20; i++) &#123; Pow[i] = Pow[i - 1] * 10 % mod; &#125; while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; P R = solve(r); P L = solve(l - 1); cout &lt;&lt; (R.squ - L.squ + mod) % mod &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XHXJ's-LIS]]></title>
    <url>%2F2018%2F04%2F12%2FXHXJ-s-LIS%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 4352 一个整数，他的数位的最长上升子序列的长度为k，则成是合格的。 问区间内合格的整数的数量 分析因为数位的取值一共只有十个（0~9）， 所以我们可以用十个二进制来保存状态。 0表示出现过，1表示未出现过 最后check的时候检查状态中1的数量是否为k即可。 $dp[i][sta][k]$ i 表示枚举第i位，sta表示当前状态，k表示最长上升子序列的长度。 这里需要注意的是更新状态的方法。 做法与nlog(n)求最长上升子序列的思想相同。 假设要更新第pos位，那么就找原状态中第一个大于等于pos位置，然后将其置为0！ 然后把pos位设为1. 如果想不通就好好想想是怎么处理最长上升子序列的吧。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[20][1024][20];int num[20];int w[20];int K;int getnew(int sta, int val) &#123; for (int i = val; i &lt; 10; i++) &#123; if (sta &amp; (1 &lt;&lt; i)) return (sta ^ (1 &lt;&lt; i)) | (1 &lt;&lt; val); // !求最长上升子序列！ &#125; // sta ^= 1 &lt;&lt; (val); sta |= 1 &lt;&lt; (val); return sta;&#125;int getnum(int sta) &#123; int ret = 0; while (sta) &#123; if (sta &amp; 1) ret++; sta &gt;&gt;= 1; &#125; return ret;&#125;ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return getnum(sta) == K; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta][K] != -1) return dp[pos][sta][K]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, sta); else ans += dfs(pos - 1, limit &amp;&amp; i == up, lead &amp;&amp; i == 0, getnew(sta, i)); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta][K] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, true, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T, kase = 1; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; ll l, r; cin &gt;&gt; l &gt;&gt; r &gt;&gt; K; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Round-Number]]></title>
    <url>%2F2018%2F04%2F12%2FRound-Number%2F</url>
    <content type="text"><![CDATA[题意来源： POJ - 3252 一个数其二进制表示形式，若0的数量大于等于1的数量，则称该数合格。 问区间内合格的整数的数量 分析$dp[i][sta]$ i表示枚举到当前位，sta表示到当前位一共有多少个0 因为sta可能会小于零，所以我们先给sta加一个值（offset），最后判断的时候再减去这个offset即可。 这里注意前导零的影响，因为前面的零是不算0的。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ybmj// #include &lt;bits/stdc++.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[35];int dp[35][100];int dfs(int pos, int sta, bool limit, bool lead) &#123; if (pos == -1) return sta &gt;= 35; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 1; int ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, sta, limit &amp;&amp; i == num[pos], true); else ans += dfs(pos - 1, sta + (i == 0 ? 1 : -1), limit &amp;&amp; i == num[pos], false); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;int solve(int val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 2; val /= 2; &#125; return dfs(pos - 1, 35, true, true);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int l, r; clr(dp, -1); while (cin &gt;&gt; l &gt;&gt; r) &#123; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[F(x)]]></title>
    <url>%2F2018%2F04%2F12%2FF-x%2F</url>
    <content type="text"><![CDATA[题意来源： HDU - 4734 For a decimal number x with n digits $(A_n A_{n-1} … A_2 A_1)$, we define its weight as $F(x) = A_n \times 2^{n-1} + A_n-1 \times 2^{n-2} + … + A_1 \times 1$. Now you are given two numbers A and B, please calculate how many numbers are there between 0 and B, inclusive, whose weight is no more than F(A). 分析$dp[i][sta]$ 表示枚举到第i位，还有sta可用。 为什么不用sta表示前i位的和呢？ 以为A每次都是不一样的，所以每次都要清空dp数组，会超时的！ 注意 很重要的技巧！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 4700;ll W[] = &#123;1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024&#125;;ll dp[12][maxn];int num[20];ll dfs(int pos, bool limit, int sta) &#123; if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; // 表示枚举到pos位，还有sta可用 int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (sta - i * W[pos] &gt;= 0) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], sta - i * W[pos]); &#125; else break; &#125; if (!limit) dp[pos][sta] = ans; return ans;&#125;ll solve(ll l, ll r) &#123; int pos = 0; int val = 0; while (l) &#123; val += (l % 10) * W[pos++]; l /= 10; &#125; pos = 0; while (r) &#123; num[pos++] = r % 10; r /= 10; &#125; return dfs(pos - 1, true, val);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T, kase = 1; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; "Case #" &lt;&lt; kase++ &lt;&lt; ": "; cout &lt;&lt; solve(l, r) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不要62]]></title>
    <url>%2F2018%2F04%2F12%2F%E4%B8%8D%E8%A6%8162%2F</url>
    <content type="text"><![CDATA[题意来源：HDU - 2089 区间内不包含“62”或者“4”的整数的个数 分析数位dp的经典入门题，推荐一篇博文 里面讲的很清楚，就不再赘述了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;ll dp[20][2];int num[20];ll dfs(int pos, bool limit, bool sta) &#123; // sta 表示前一位是否为6 if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (i == 4) continue; if (i == 2 &amp;&amp; sta == true) continue; if (i == 6) ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], true); else ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], false); &#125; if (!limit) dp[pos][sta] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, false);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); ll l, r; clr(dp, -1); while (cin &gt;&gt; l &gt;&gt; r) &#123; if (l == 0 &amp;&amp; r == 0) break; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Beautiful-numbers]]></title>
    <url>%2F2018%2F04%2F12%2FBeautiful-numbers%2F</url>
    <content type="text"><![CDATA[题意来源：CodeForces - 55D 每个整数可以被他每个非零的数位整除。 问区间内符合上述条件的整数的个数。 分析被每个非零数位整除，即可以被所有非零数位的最小公倍数整除。 所以我们可以枚举这个最小公倍数，1~9的最小公倍数为2520. 所以我们可以得到 $dp[i][k][sta]$ i表示枚举到当前位，k表示所有数位的最小公倍数，sta表示当前整数模k的结果。 最后如果sta为0，则return 1 但是！ 爆内存了！ 考虑我们要枚举的是最小公倍数，但之前上我们做的是枚举1 到 2520，然而实际上真正的最小公倍数实际上不过只有40多个。（如果2520能被k整除，那么k一定是一个由若干数位组成的最小公倍数） 所以我们用一个map映射一下，就可以减少内存的消耗啦！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 2600;ll dp[20][50][maxn];int num[20];map&lt;int, int&gt; maps;ll gcd(ll a, ll b) &#123; if (b) while ((a %= b) &amp;&amp; (b %= a)) ; return a + b;&#125;ll lcm(ll a, ll b) &#123; if (a == 0 || b == 0) return a + b; return a * b / gcd(a, b);&#125;ll dfs(int pos, bool limit, int sta, int val) &#123; if (pos == -1) &#123; if (val % sta == 0) &#123; return 1; &#125; else return 0; &#125; if (!limit &amp;&amp; dp[pos][maps[sta]][val] != -1) return dp[pos][maps[sta]][val]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == num[pos], lcm(sta, i), (val * 10 + i) % 2520); &#125; if (!limit) dp[pos][maps[sta]][val] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 1, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int cnt = 0; for (int i = 1; i &lt;= 2520; i++) &#123; if (2520 % i == 0) &#123; maps[i] = cnt++; &#125; &#125; int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Balanced-Number-spoj]]></title>
    <url>%2F2018%2F04%2F12%2FBalanced-Number-spoj%2F</url>
    <content type="text"><![CDATA[题意来源：Cuban Olympiad in Informatics 2012 - Day 2 Problem A 数位的值为偶数，则要出现奇数次。 数位的值为奇数，则要出现偶数次。 计算区间内符合条件的整数的数量。 分析首先因为数位的值一共只有10个(0 ~ 9),所以我们可以用二进制来保存每个值出现的次数是奇是偶（0 表示出现偶数次，1 表示出现奇数次） 但有个问题是，如果某个值在整数中没有出现过，那么它并不能直接判定为0. 也就是说我们需要一个vis，来表示某个值（0 ～ 9）是否在当前整数中出现过。 我的解决办法是再用十位二进制数来记录，如果值出现过，则相应的二进制为1. 在check的时候，先检查当前数位是否出现过，再检查出现次数的奇偶性。 $dp[i][sta]$ i表示枚举到当前位，sta表示当前状态。（高十位表示vis，低十位表现出现次数的奇偶性） 注意 这种用二进制保存状态的方法非常常见！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;typedef unsigned long long ull;const int maxn = 1e6 + 5e4;int num[25];ll dp[25][maxn];bool check(int sta) &#123; for (int i = 10; i &lt; 20; i++) &#123; if ((sta &gt;&gt; i) &amp; 1) &#123; if ((i &amp; 1) == ((sta &gt;&gt; (i - 10)) &amp; 1)) return false; &#125; &#125; return true;&#125;int getsta(int sta, int val) &#123; sta |= (1 &lt;&lt; (val + 10)); sta ^= (1 &lt;&lt; val); return sta;&#125;ll dfs(int pos, bool limit, bool lead, int sta) &#123; if (pos == -1) return check(sta); if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][sta] != -1) return dp[pos][sta]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (lead &amp;&amp; i == 0) ans += dfs(pos - 1, limit &amp;&amp; i == up, true, sta); else ans += dfs(pos - 1, limit &amp;&amp; i == up, false, getsta(sta, i)); &#125; if (!limit &amp;&amp; !lead) dp[pos][sta] = ans; return ans;&#125;ll solve(ll val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, true, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ull l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; solve(r) - solve(l - 1) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Balanced-Number]]></title>
    <url>%2F2018%2F04%2F12%2FBalanced-Number%2F</url>
    <content type="text"><![CDATA[题意来源： HDU3709 一个数被称作平衡数当且仅当其存在一个对称轴，使得对称轴两边可以平衡。 定义重量为数位的值乘数位到对称轴的距离。 比如4139 可以把3当做对称轴，4 2 + 1 1 == 9 * 1 问区间内有多少个平衡数 分析枚举对称轴和对称轴左边的值 $dp[i][k][sta]$ i表示枚举到第i位，k表示对称轴的位置，sta表示枚举到当前位的值。 最后sta为0时表示当前整数符合条件，return 1. 这里如果sta变成负数，就不需要继续dfs下去了。 还要注意的是左边界为0，所以需要做一下特殊情况的判断。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[20];ll dp[20][20][2000];ll dfs(int pos, bool limit, int mid, int w) &#123; if (pos == -1) return w == 0; if (!limit &amp;&amp; dp[pos][mid][w] != -1) return dp[pos][mid][w]; int up = limit ? num[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (pos &gt; mid) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w + i * (pos - mid)); &#125; else if (pos &lt; mid) &#123; ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w - i * (mid - pos)); &#125; else ans += dfs(pos - 1, limit &amp;&amp; i == up, mid, w); &#125; if (!limit) dp[pos][mid][w] = ans; return ans;&#125;ll solve(ll val) &#123; if (val == -1) return 0; if (val == 0) return 1; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; ll ans = 0; for (int i = 0; i &lt; pos; i++) &#123; ans += dfs(pos - 1, true, i, 0); &#125; return ans;&#125;int countnum(ll val) &#123; int cnt = 0; if (val &lt; 10) &#123; cnt = 1; &#125; else &#123; while (val) &#123; cnt++; val /= 10; &#125; &#125; return cnt;&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); */ std::ios::sync_with_stdio(false); int T; cin &gt;&gt; T; clr(dp, -1); while (T--) &#123; ll l, r; cin &gt;&gt; l &gt;&gt; r; ll ans = solve(r) - solve(l - 1); int cntr = countnum(r); int cntl = countnum(l - 1); cout &lt;&lt; ans - (cntr - cntl) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B-number]]></title>
    <url>%2F2018%2F04%2F12%2FB-number%2F</url>
    <content type="text"><![CDATA[题意来源： HDU3652 区间内有多少个可以包含“13”，并且可以被13整除的数字。 分析$dp[i][k][sta]$ i表示枚举到第i位，k表示前i位组成的整数模13的结果，sta表示前一位是否为1，以及之前是否出现过13. 这里再解释一下k 假设整数A = （a + b + c + d) 那么A%13 == 0 等价于 (a + b + c + d) % 13 等价于a % 13 + b % 13 + c % 13 + d % 13 所以最后判断k是否为0，即可知道当前整数是否能被13整除。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;int num[20];int dp[20][20][3];int dfs(int pos, bool limit, int val, int sta) &#123; if (pos == -1) return sta == 2 &amp;&amp; val == 0; if (!limit &amp;&amp; dp[pos][val][sta] != -1) return dp[pos][val][sta]; int up = limit ? pos[num] : 9; int ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (sta == 2) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 2); else if (i == 1) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 1); else if (sta == 1 &amp;&amp; i == 3) ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 2); else ans += dfs(pos - 1, limit &amp;&amp; i == up, (val * 10 + i) % 13, 0); &#125; if (!limit) dp[pos][val][sta] = ans; return ans;&#125;int solve(int val) &#123; int pos = 0; while (val) &#123; num[pos++] = val % 10; val /= 10; &#125; return dfs(pos - 1, true, 0, 0);&#125;int main() &#123; /* #ifndef ONLINE_JUDGE freopen("1.in","r",stdin); freopen("1.out","w",stdout); #endif */ std::ios::sync_with_stdio(false); int val; clr(dp, -1); while (cin &gt;&gt; val) &#123; cout &lt;&lt; solve(val) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密体系]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8A%A0%E5%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[消息摘要消息摘要的作用在网络安全目标中，要求信息在生成、存储或传输过程中保证不被偶然或蓄意地删除、修改、伪造、乱序、重放、插入等破坏和丢失，因此需要一个较为安全的标准和算法，以保证数据的完整性。 常见的消息摘要算法 ： MD5 ，SHA Hash函数消息摘要算法采用单向散列（hash）函数从明文产生摘要密文。 散列函数的输出值有固定的长度，该散列值是消息M的所有位的函数并提供错误检测能力，消息中的任何一位或多位的变化都将导致该散列值的变化。从散列值不可能推导出消息M ，也很难通过伪造消息M’来生成相同的散列值。 Hash函数的值称为作为自变量的消息的“散列值”或“消息摘要”、“数字指纹” 消息M -&gt; Hash函数 -&gt; 散列值h(原像)…….(映射)…………(映像) 不同的原像映射出相同的映象称为“碰撞”或“冲突” 映象相同的两个原像互称为“等价原像” ###抗碰撞性 弱抗碰撞性(Weak collision resistance): 对于任意给定的M，找到满足 M≠N 且H(M)=H(N)的N，在计算上是不可行的； 强抗碰撞性(Strong collision resistance): 找到任何满足H(x)= H(y) 的偶对(x，y)在计算上是不可行的。 Hash函数的分类根据安全水平: 弱抗碰撞 强抗碰撞 根据是否使用密钥: 使用密钥，此时散列值称作 MAC(Message Authentication Code) 不使用密钥，此时散列值称作 MDC(Message Detection Code) ###Hash函数的应用 由Hash函数产生消息的散列值,以消息的散列值来判别消息的完整性 用加密消息的散列值来产生数字签名 用口令的散列值来安全存储口令（认证系统中的口令列表中仅存储口令的Hash函数值，以避免口令被窃取。认证时用输入口令的Hash函数值与其比较） ##消息摘要的安全隐患 无法完全阻止数据的修改。 如果在数据传递过程中，窃取者将数据窃取出来，并且修改数据，再重新生成一次摘要，将改后的数据和重新计算的摘要发送给接收者，接收者利用算法对修改过的数据进行验证时，生成的消息摘要和收到的消息摘要仍然相同，消息被判断为“没有被修改”。 所以除了需要知道消息和消息摘要之外，还需要知道发送者身份—消息验证码。 消息验证码即MAC(带密钥的哈希函数) 简单来说，发送者A和接受者B之间共同拥有一个密钥key，A将消息摘要用key加密。然后连同数据一起发给B。 B接收到之后，先用key对消息摘要解密，然后本地计算数据的消息摘要与解密得到的进行对比。 可以防止数据被修改。因为篡改者没有key。 消息验证码的局限性消息验证码可以保护信息交换双方不受第三方的攻击，但是它不能处理通信双方的相互攻击 信宿方可以伪造消息并称消息发自信源方，信源方产生一条消息，并用和信宿方共享的密钥产生认证码，并将认证码附于消息之后 信源方可以否认曾发送过某消息，因为信宿方可以伪造消息，所以无法证明信源方确实发送过该消息 在收发双方不能完全信任的情况下，引入数字签名来解决上述问题,数字签名的作用相当于手写签名 消息认证消息认证（message authentication）就是验证消息的完整性，当接收方收到发送方的报文时，接收方能够验证收到的报文是真实的和未被篡改的。它包含两层含义：一是验证信息的发送者是真正的而不是冒充的，即数据起源认证；二是验证信息在传送过程中未被篡改、重放或延迟等。 消息认证的方式 加密认证——用消息的密文本身充当认证信息 消息认证码MAC——由以消息和密钥作为输入的公开函数产生的认证信息 散列值──由以消息作为唯一输入的散列函数产生的认证信息（无需密钥） 基于消息加密的认证用对称密码体制进行加密认证过程──用同一密钥加密、解密消息 作用──认证+保密 原理──攻击者无法通过改变密文来产生所期望的明文变化 特点──接收方需要判别消息本身的逻辑性或合法性。“我请你吃饭”被乱改成“我请你謯斸” 私钥加密，公钥解密过程──发送者用自己的私钥加密明文、接收者用发送者的公钥解密密文 作用──认证及签名，但不保密 原理──因不知发送者的私钥，故其他人无法产生密文或伪造签名 若用公钥加密、私钥解密，则无法起到认证的作用。因为知道公钥的人都可以通过产生伪造的密文来篡改消息。 用私钥、公钥双重加密、解密过程──发送者先用自己的私钥加密明文，再用接收者的公钥加密一次；接收者先用自己的私钥解密密文，再用发送者的公钥解密一次 作用──认证、签名，且保密 原理──认证、签名由发送者的私钥加密实现；保密性由接收者的公钥加密保证 基于消息验证码MAC的认证产生──发送者以消息M和与接收者共享的密钥K为输入，通过某公开函数C进行加密运算得到MAC 传送并接收──M+MAC 认证──接收者以接收到的M和共享密钥K为输入，用C重新加密算得MAC’ ，若MAC’=MAC，则可确信M未被篡改 作用──认证，但不保密 基于散列值的认证 对附加了散列值的消息实施对称加密，得到并发送Ek(M+H(M)) —— 认证+保密 仅对散列值实施对称加密，得到Ek(H(M))，并与M一起发送 —— 认证+不保密 对散列值实施私钥加密，得到EKRa(H(M))并与M一起发送 —— 认证+签名，不保密 将消息与用私钥加密后的散列值一起再用共享密钥加密，最后得到Ek(M+EKRa(H(M)))并发送 —— 认证+签名+保密 将消息串接一个由通信各方共享的密值S后计算散列值，得到H(M+S)并与M一起发送 —— 认证，不保密 先将消息串接一个由通信各方共享的密值S后计算散列值，再将它与消息M一起用共享密钥加密，最后得到Ek(M+H(M+S))并发送 —— 认证+保密 数字签名在公钥体制中，用接受者的公钥加密消息得到密文，接受者用自己的私钥解密密文得到消息。加密过程任何人都能完成，解密过程只有接受者能够完成。 考虑一种相反的过程，发送者用自己的私钥“加密”消息得到“密文”，然后利用发送者的公钥“解密”密文得到消息。 很显然，加密只有发送者能够完成，而解密任何人都可以完成。 所以，任何人都可相信是特定的发送者产生了该消息，这就相当于“签名”，证明一个消息的所属。 数字签名的特点传统签名的基本特点: 与被签的文件在物理上不可分割 签名者不能否认自己的签名 签名不能被伪造 容易被验证 数字签名是传统签名的数字化: 能与所签文件“绑定” 签名者不能否认自己的签名 容易被自动验证 签名不能被伪造 数字签名必须具有下述特征 收方能够确认或证实发方的签名，但不能伪造，简记为R1-条件（unforgeable） 发方发出签名的消息给收方后，就不能再否认他所签发的消息，简记为S-条件(non-repudiation) 收方对已收到的签名消息不能否认，即有收报认证，简记作R2-条件 第三者可以确认收发双方之间的消息传送，但不能伪造这一过程，简记作T-条件 数字签名与消息认证的区别 与手书签名的区别：手书签名是模拟的，且因人而异。数字签名是0和1的数字串，因消息而异。 与消息认证的的区别：消息认证使收方能验证消息发送者及所发消息内容是否被窜改过。当收发者之间没有利害冲突时，这对于防止第三者的破坏来说是足够了。但当收者和发者之间有利害冲突时，就无法解决他们之间的纠纷，此时须借助满足前述要求的数字签名技术。 与消息加密区别：消息加密和解密可能是一次性的，它要求在解密之前是安全的；而一个签名的消息可能作为一个法律上的文件，如合同等，很可能在对消息签署多年之后才验证其签名，且可能需要多次验证此签名。因此，签名的安全性和防伪造的要求更高些，且要求证实速度比签名速度还要快，特别是联机在线实时验证。 数字签名的分类根据签名的内容分: 对整体消息的签名 对压缩消息的签名 按明、密文的对应关系划分: 确定性(Deterministic)数字签名，其明文与密文一一对应，它对一特定消息的签名不变化，如RSA、Rabin等签名； 随机化的(Randomized)或概率式数字签名 数字签名常见算法普通数字签名算法 RSA ElGamal /DSS/DSA ECDSA 盲签名算法 群签名算法 RSA 盲签名一般数字签名中，总是要先知道文件内容而后才签署，这正是通常所需要的。但有时需要某人对一个文件签名，但又不让他知道文件内容，称此为盲签名(Blind Signature) Chaum在1983年提出 适应于电子选举、数字货币协议中 群签名群体密码学由Desmedt于1987年提出，群签名是群体密码学中的课题，1991由Chaum和van Heyst提出，其特点有： 一个群体中的任意一个成员可以匿名地代表整个群体进行签名； 接收到签名的人可以用公钥验证群签名，但不可能知道由群体中哪个成员所签； 发生争议时可由群体中的成员或可信赖机构识别群签名的签名者。 数字水印数字水印（Digital Watermark）是指永久镶嵌在其它数据（主要指宿主数据）中具有可鉴别性的数字信号或数字模式。 特点 不可感知性（imperceptible）：包括视觉上的不可见性和水印算法的不可推断性。 鲁棒性（Robustness）：嵌入水印必须难以被一般算法清除。也就是说多媒体信息中的水印能够抵抗各种对数据的破坏，如A/D 、D/A转换、重量化、滤波、平滑、有失真压缩以及旋转、平移、缩放及分割等几何变换和恶意的攻击等。 可证明性：指对嵌有水印信息的图像，可以通过水印检测器证明嵌入水印的存在。 自恢复性：指含水印的图像在经受一系列攻击后（图像可能有较大的破坏），水印信息也经过了各种操作或变换。但可以通过一定的算法从剩余的图像片段中恢复出水印信息，而不需要整个原始图像的特性。 安全保密性：数字水印系统使用一个或多个密钥以确保安全，防止修改和擦除。同时若与密码学进行有机的结合，对数据可起到双重加密作用。 数字证书任何的密码体制都不是坚不可摧的，公开密钥体制也不例外。由于公开密钥体制的公钥是对所有人公开的，从而免去了密钥的传递，简化了密钥的管理。 但是这个公开性在给人们带来便利的同时，也给攻击者冒充身份篡改公钥有可乘之机。所以，密钥也需要认证，在拿到某人的公钥时，需要先辨别一下它的真伪。这时就需要一个认证机构，将身份证书作为密钥管理的载体，并配套建立各种密钥管理设施。 数字证书（Digital Certificate）又称为数字标识（Digital ID）。它提供一种在Internet上验证身份的方式，是用来标志和证明网络通信双方身份的数字信息文件。 数字安全证书是由权威公正的第三方机构即CA中心签发的。它是在证书申请被认证中心批准后，通过登记服务机构将其发放给申请者。 数字证书的内容最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。一般情况下证书中还包括密钥的有效时间，发证机关(证书授权中心)的名称，该证书的序列号等信息，证书的格式遵循ITU-T X.509国际标准。 一个标准的X.509数字安全证书包含以下一些内容： 证书的版本号。不同的版本的证书格式也不同，在读取证书时首先需要检查版本号。 证书的序列号。每个证书都有一个唯一的证书序列号。 证书所使用的签名算法标识符。签名算法标识符表明数字签名所采用的算法以及使用的参数。 证书的发行机构名称。创建并签署证书的CA的名称，命名规则一般采用X.500格式。 证书的有效期。证书的有效期由证书有效起始时间和终止时间来定义。 证书所有人的名称。命名规则一般采用X.500格式； 证书所有人的公开密钥及相关参数。相关参数包括加密算法的标识符及参数等 证书发行机构ID。这是版本2中增加的可选字段。 证书所有人ID。这是版本2中增加的可选字段。 扩展域。这是版本3中增加的字段，它是一个包含若干扩展字段的集合。 证书发行机构对证书的签名，即CA对证书内除本签名字段以外的所有字段的数字签名。 认证中心CA（Certificate Authority，认证中心）作为权威的、可信赖的、公正的第三方机构，专门负责发放并管理所有参与网上交易的实体所需的数字证书。 CA作为一个权威机构，对密钥进行有效地管理，颁发证书证明密钥的有效性，并将公开密钥同某一个实体（消费者、商户、银行）联系在一起。 CA的主要职责 颁发证书：如密钥对的生成、私钥的保护等，并保证证书持有者应有不同的密钥对。 管理证书：记录所有颁发过的证书，以及所有被吊销的证书。 用户管理：对于每一个新提交的申请，都要和列表中现存的标识名相比较，如出现重复，就给予拒绝。 吊销证书：在证书有效期内使其无效，并发表CRL（Certificate Revocation List，被吊销的证书列表） 验证申请者身份：对每一个申请者进行必要的身份认证。 保护证书服务器：证书服务器必须安全的，CA应采取相应措施保证其安全性。 保护CA私钥和用户私钥：CA签发证书所用的私钥要受到严格的保护，不能被毁坏，也不能被非法使用。同时，根据用户密钥对的产生方式，CA在某些情况下有保护用户私钥的责任。 审计和日志检查：为了安全起见，CA对一些重要的操作应记入系统日志。在CA发生事故后，要根据系统日志做善后追踪处理――审计，CA管理员要定期检查日志文件，尽早发现可能的隐患。 CA的基本组成认证中心主要有三个部分组成: 注册服务器（RS）：面向用户，包括计算机系统和功能接口； 注册中心（RA）：负责证书的审批； 认证中心（CA）：负责证书的颁发，是被信任的部门 一个完整的安全解决方案除了有认证中心外，一般还包括以下几个方面： 密码体制的选择 安全协议的选择2.1 SSL（Secure Socket Layer 安全套接字层）2.2 S-HTTP（Secure HTTP，安全的http协议）2.3 SET（Secure Electonic Transaction，安全电子交易协议） CA的三层体系结构 第一层为RCA（Root Certificate Authority，根认证中心）。它的职责是负责制定和审批CA的总政策，签发并管理第二层CA的证书，与其它根CA进行交叉认证。 第二层为BCA（Brand Certificate Authority，品牌认证中心）。它的职责是根据RCA的规定，制定具体政策、管理制度及运行规范；签发第三层证书并进行证书管理。 第三层为ECA（End user CA，终端用户CA）。它为参与电子商务的各实体颁发证书。签发的证书可分为三类：分别是支付网关（Payment Gateway）、持卡人（Cardholder）和商家（Merchant）签发的证书；签发这三种证书的CA对应的可称之为PCA、CCA和MCA。]]></content>
      <categories>
        <category>信息安全</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hash——MD5 and SHA]]></title>
    <url>%2F2018%2F04%2F08%2FHash%2F</url>
    <content type="text"><![CDATA[MD5 : Message-Digest作用通过对原文件通过运算，产生出一个固定长度（通常为128位）的散列值（Hash Value）。 哪怕原文件有一点点的改动，这个Hash Value都会产生巨大的差异。 因此可以用来验证文件的的完整性： 我将文件和这个Hash Value一起发送给另一个人，他只要检查一下文件的Hash Value和我发过去的Hash Value是否相同即可知道文件是否完整。 MD5亦有应用于部份网上赌场以保证赌博的公平性，原理是系统先在玩家下注前已生成该局的结果，将该结果的字串配合一组随机字串利用MD5 加密，将该加密字串于玩家下注前便显示给玩家，再在结果开出后将未加密的字串显示给玩家，玩家便可利用MD5工具加密验证该字串是否吻合。—— From Wikipedia 缺陷2009年，我国研究人员在$2^{20.96}$的时间复杂度下破解了MD5的碰撞抵抗。 但这里的破解也只是非特定碰撞，由于MD5算法的特性，要构造出特定内容的碰撞有很大难度。 因此仅用MD5来检测文件完整性一致性已经是不可行的了。但由于其操作简单，还有一些人在使用。 SHA 作用与MD5一样，只是生成算法不同。 相对于MD5，性能肯定没那么好，但是目前来说是很安全的！ 代码参考本人 github]]></content>
      <categories>
        <category>信息安全</category>
        <category>加密</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cf961D Pair Of Lines]]></title>
    <url>%2F2018%2F04%2F05%2Fcf961D-Pair-Of-Lines%2F</url>
    <content type="text"><![CDATA[题意题目链接给你n个点（二维），问是否能找出两条直线，使得可以覆盖所有点。 分析假设原图满足题目要求。 那么我们每次随机取两个点，将该直线上的点全部去掉， 然后判断剩下的点是否共线。 因为原图满足题目要求，所以我们可以将图中的点分为两个点集。 假设其中一个点集中点的数量为x，则另一个点集中点的数量为y = n-x 那么我们取到的两个点在一个点集中的概率就是$1 - \frac{ C_{x}^{1} \times C_{y}^{1} } { C_{n}^{2}}$ 由基本不等式可知，上述概率至少是$\frac{1}{2}$ 我们可以随机一百次，这样如果原图是满足题目要求的，那么他成功选取同一个点集中两个点的概率就是$1 - \frac{1}{2^{100}}$. 即，如果原图满足条件，则大概率可以输出yes. 注意 每次随机要更换种子！1srand(time(0)) // 利用当前系统时间作为种子 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// ybmj#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;typedef long long ll;const int maxn = 1e5 + 5;const double eps = 1e-9;pair&lt;ll, ll&gt; p[maxn];int main() &#123;#ifndef ONLINE_JUDGE freopen("1.in", "r", stdin); freopen("1.out", "w", stdout);#endif std::ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p[i].first &gt;&gt; p[i].second; &#125; if (n &lt;= 2) &#123; cout &lt;&lt; "yes" &lt;&lt; endl; return 0; &#125; srand(time(0)); //注意！ bool flag = false; for (int i = 0; i &lt; 100; i++) &#123; int p1 = rand() % n; int p2 = rand() % n; while (p1 == p2) p2 = rand() % n; ll a = p[p2].first - p[p1].first; ll b = p[p2].second - p[p1].second; ll m = p[p1].second * p[p2].first - p[p1].first * p[p2].second; vector&lt;int&gt; V; for (int i = 0; i &lt; n; i++) &#123; if (m != p[i].second * a - b * p[i].first) V.push_back(i); &#125; if (V.size() &lt;= 2) &#123; flag = true; break; &#125; p1 = V[0]; p2 = V[1]; a = p[p2].first - p[p1].first; b = p[p2].second - p[p1].second; m = p[p1].second * p[p2].first - p[p1].first * p[p2].second; flag = true; for (int i = 2; i &lt; V.size(); i++) &#123; if (m != p[V[i]].second * a - b * p[V[i]].first) &#123; flag = false; break; &#125; &#125; if (flag) break; &#125; if (flag) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数学</category>
        <category>随机概率</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Build Blog]]></title>
    <url>%2F2018%2F04%2F04%2FBuild-Blog%2F</url>
    <content type="text"><![CDATA[https://xuanwo.org/2015/03/26/hexo-intor/ https://righere.github.io/2016/10/10/install-hexo/ 利用Travis实现自动部署 ：http://www.cnblogs.com/babycool/p/7326722.html 对于购买过域名的同学，要在Source里面加一个CNAME文件，里面写上新的域名即可。]]></content>
      <categories>
        <category>关于本博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Prim]]></title>
    <url>%2F2018%2F04%2F04%2FPrim%2F</url>
    <content type="text"><![CDATA[Prim思想:Prim 和 Kruskal 实质上都是用了权值最小的边一定在生成树中这个性质。 Kruskal 对于稠密图来说性能比较差，因为要维护一个权值最小的边，所以有一个优先队列。 而 Prim 对于稠密图有比较好的性能，那么它是怎么确定权值最小的边？ Prim 与 Kruskal 不同的是，Prim 每次以一个没有访问过的点为起点，在所有连接着起点的边中找一个最小。而 Kruskal 每次找的是整张图中权值最小的边，并用并查集来维护访问过的点。 设 n 为顶点数量 所以 Prim 只要对每个顶点都做一次上述的操作即可得到最小生成树，时间复杂度为$O(n^2)$ 1234567891011121314151617181920212223242526272829// 耗费矩阵cost[][],标号从0开始,0~n-1// 返回最小生成树的权值,返回-1表示原图不连通// O(n^2)const int maxn = 100;bool vis[maxn];int lowc[maxn];int cost[maxn][maxn]; //初始化为正无穷int Prim(int n) &#123; int ans = 0; clr(vis, 0); vis[0] = 1; for (int i = 1; i &lt; n; i++) lowc[i] = cost[0][i]; for (int i = 1; i &lt; n; i++) &#123; int minc = INF; int p = -1; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; minc &gt; lowc[j]) &#123; minc = lowc[j]; p = j; &#125; if (minc == INF) return -1; vis[p] = 1; ans += minc; for (int j = 0; j &lt; n; j++) if (!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j]; &#125; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher]]></title>
    <url>%2F2018%2F03%2F09%2FManacher%2F</url>
    <content type="text"><![CDATA[Manacher本文转载自： 链接 问题定义最长回文子串问题：给定一个字符串，求它的最长回文子串长度。 如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例： 112321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词） Brute-force 解法对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为 n 的字符串，共有$n^2$个子串。这些子串的平均长度大约是$n/2$，因此这个解法的时间复杂度是$O(n^3)$。 改进的方法显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为 n 的字符串，这样的位置一共有 2n-1 个，在每个位置上平均大约要进行$n/4$次字符比较，于是此算法的时间复杂度是$O(n^2)$。 Manacher 算法对于一个比较长的字符串，$O(n^2)$的时间复杂度是难以接受的。Can we do better? 先来看看解法 2 存在的缺陷。 1.由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法 2 要对两种情况分别处理； 2.很多子串被重复多次访问，造成较差的时间效率。 缺陷 2）可以通过这个直观的小 🌰 体现： 12char: a b a b a i : 0 1 2 3 4 当 i==1，和 i ==2 时，左边的子串 aba 分别被遍历了一次。 如果我们能改善解法 2 的不足，就很有希望能提高算法的效率。Manacher 正是针对这些问题改进算法。 解决长度奇偶性带来的对称轴位置问题Manacher 算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。以插入#号为例： 12aba ———&gt; #a#b#a#abba ———&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。 解决重复访问的问题我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher 定义了一个回文半径数组 RL，用 RL[i]表示以第 i 个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义 RL[i]为第 i 个字符为对称轴的回文串的最右一个字符与字符 i 的距离。对于上面插入分隔符之后的两个串，可以得到 RL 数组： 123456789char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 上面我们还求了一下 RL[i]-1。通过观察可以发现，RL[i]-1 的值，正是在原本那个没有插入过分隔符的串中，以位置 i 为对称轴的最长回文串的长度。那么只要我们求出了 RL 数组，就能得到最长回文子串的长度。 于是问题变成了，怎样高效地求的 RL 数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量 MaxRight，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下 MaxRight 对应的回文串的对称轴所在的位置，记为 pos，它们的位置关系如下。 我们从左往右地访问字符串来求 RL，假设当前访问到的位置为 i，即要求 RL[i]，在对应上图，i 必然是在 po 右边的(obviously)。但我们更关注的是，i 是在 MaxRight 的左边还是右边。我们分情况来讨论。 1）当 i 在 MaxRight 的左边 情况 1)可以用下图来刻画： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以 i 为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到 i 关于 pos 的对称位置 j，这个 j 对应的 RL[j]我们是已经算过的。根据回文串的对称性，以 i 为对称轴的回文串和以 j 为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。 以 j 为对称轴的回文串比较短，短到像下图这样。 这时我们知道 RL[i]至少不会小于 RL[j]，并且已经知道了部分的以 i 为中心的回文串，于是可以令 RL[i]=RL[j]。但是以 i 为对称轴的回文串可能实际上更长，因此我们试着以 i 为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以 j 为对称轴的回文串很长，这么长： 这时，我们只能确定，两条蓝线之间的部分（即不超过 MaxRight 的部分）是回文的，于是从这个长度开始，尝试以 i 为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新 MaxRight 和 pos，因为有可能得到更大的 MaxRight。 具体操作如下： step 1: 令 RL[i]=min(RL[2*pos-i], MaxRight-i)step 2: 以 i 为中心扩展回文串，直到左右两边字符不同，或者到达边界。step 3: 更新 MaxRight 和 pos2）当 i 在 MaxRight 的右边 遇到这种情况，说明以 i 为对称轴的回文串还没有任何一个部分被访问过，于是只能从 i 的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新 MaxRight 和 pos。 代码1234567891011121314151617181920212223const int maxn = 1e6+5;char Ma[maxn*2]; //插入新字符后的字符串int Mp[maxn*2]; //以当前位置为对称轴的回文半径void Manacher(string &amp;s)&#123; int l = 0; Ma[l++] = '$'; //防止越界 Ma[l++] = '#'; for(int i=0;i&lt;s.size();i++)&#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; //结尾设置为空字符，防止越界 int mx = 1,id = 1; for(int i=1;i&lt;l;i++)&#123; Mp[i] = mx &gt; i ? min(Mp[2*id-i],mx-i) : 1; while(Ma[i+Mp[i]] == Ma[i-Mp[i]]) Mp[i] ++; //扩展 if(i + Mp[i] &gt; mx)&#123; mx = i + Mp[i]; id = i; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruskal]]></title>
    <url>%2F2018%2F03%2F09%2FKruskal%2F</url>
    <content type="text"><![CDATA[kruskal思想：贪心+并查集 从权值最小的边开始遍历，若当前两个点在一个连通分量里，则忽略。 否则选取这条边加入到最小生成树中，当选取 n-1 条边后停止，因为只需要 n-1 条边即可连接 n 个点。 若图不连通，则会出现问题… 可以稍微模改一下 (●’◡’●) 模板123456789101112131415161718192021222324252627282930313233const int maxn = 10;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator&lt;(const Edge &amp;A) const &#123; return w &lt; A.w; &#125;&#125;;vector&lt;Edge&gt; edges;int par[maxn];void addedge(int u, int v, int w) &#123; edges.push_back(Edge(u, v, w)); // edges.push_back(Edge(v, u, w));&#125;int find(int x) &#123; return par[x] == x ? x : find(par[x]); &#125;int kruskal(int n) &#123; int ans = 0; for (int i = 0; i &lt; n; i++) par[i] = i; sort(edges.begin(), edges.end()); //按权值排序 int cnt = 0; for (int i = 0; i &lt; edges.size(); i++) &#123; if (cnt &gt;= n - 1) break; Edge &amp;now = edges[i]; int x = find(now.u); int y = find(now.v); if (x != y) &#123; cnt++; par[x] = y; ans += now.w; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd-Warshall]]></title>
    <url>%2F2018%2F03%2F09%2FFloyd-Warshall%2F</url>
    <content type="text"><![CDATA[Floyd_Warshall思想通过不断的松弛操作求有向图或无向图上任意两点间的最短距离。 同时可以判断图中是否存在负环。（如果自身到自身的距离被更新，说明存在负环） 转移： 任意两点如i到k，其最短距离可以表示为dp[i][k]。 $$dp[i][k] = min(dp[i][k], dp[i][t] + dp[t][k])$$ 表示i到k的最短距离可以由i到t的最短距离距离加上t到k的最短距离更新 通过枚举起点，中间节点和终点，可以得到任意两点间的最短距离。 时间复杂度 ：$O(N^3)$ 传递闭包作用 : 判断任意两点间是否连通。 如果i和k之间有通路,则$dp[i][k] = 1$,否则为0. 那么递推式变为$$dp[i][k] = dp[i][k]\ ||\ (dp[i][t]\ \&amp;\&amp;\ dp[t][k])$$ 但因为复杂度较高，所以还是慎用。 模板12345678910111213141516171819202122232425const int maxn = 100;int dp[maxn][maxn];// dp初始化为正无穷void addedge(int u, int v, int w) &#123; dp[u][v] = w; // dp[v][u] = w;&#125;bool floyd_warshall(int n) &#123; for (int i = 0; i &lt; n; i++) dp[i][i] = 0; for (int t = 0; t &lt; n; t++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int k = 0; k &lt; n; k++) &#123; if (dp[i][k] &gt; dp[i][t] + dp[t][k]) &#123; dp[i][k] = dp[i][t] + dp[t][k]; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (dp[i][i] &lt; 0) &#123; return false; // exist negative circle &#125; &#125; return true;&#125; 练习题]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2018%2F03%2F09%2FDijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra思想本质上是个贪心。 从起点开始，依次把连通的路放到优先队列里（权值小的在 top),然后每次取 top，相当于连接这条边，再把与边的另一点所连接的边都放到优先队列里。（把已经连接的边看作一个整体） 注意: 图中不能存在负权边 时间复杂度 : $O(E \times logV)$ 模板1234567891011121314151617181920212223242526272829typedef pair&lt;int, int&gt; pii;const int maxn = 100;int d[maxn];vector&lt;pii&gt; G[maxn];inline void addedge(int u, int v, int w) &#123; G[u].push_back(make_pair(w, v)); // G[v].push_back(make_pair(w,u));&#125;void dijkstra(int s, int n) &#123; for (int i = 0; i &lt; n; i++) d[i] = INF; d[s] = 0; priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq; pq.push(mp(0, s)); while (!pq.empty()) &#123; pii now = pq.top(); pq.pop(); int v = now.second; if (d[v] &lt; now.first) continue; //剪枝！ 重要 for (int i = 0; i &lt; G[v].size(); i++) &#123; pii e = G[v][i]; int to = e.second; if (d[to] &gt; d[v] + e.first) &#123; d[to] = d[v] + e.first; pq.push(pii(d[to], to)); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bellman-Ford]]></title>
    <url>%2F2018%2F03%2F09%2FBellman-Ford%2F</url>
    <content type="text"><![CDATA[Bellman_Ford思想实际上就是Floyd_Warshall的单源版本 不断对边进行松弛操作，其实就是再求两点间的最小距离，因为每次更新两点之间的最小距离，可能会影响到其它两点间的最小距离。 方程表示就是$$dp[i][k] = min(dp[i][k],dp[i][t]+dp[t][k])$$ 当，$dp[i][t]$或$dp[t][k]$被更新的时候，也许$dp[i][k]$会发生改变。 所以这样一直更新下去，直到没有更新，就结束了。 因为有V个顶点，所以最多更新V-1次。 这个可以这么理解：每次对所有边松弛之后，至少有一个点会被更新。 所以V个点的图，除了起点，就剩下V-1个点了，所以最多更新V-1次。 若更新超过 V-1 次，则说明图中存在负环。 时间复杂度 : $O(E\times V)$ 模板12345678910111213141516171819202122232425262728293031struct Edge&#123; int u,v,w; Edge(int u,int v,int w):u(u),v(v),w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; edges;inline void addedge(int u,int v,int w)&#123; edges.push_back(Edge(u,v,w)); // edges.push_back(Edge(v,u,w));&#125;bool bellman_ford(int s,int n)&#123; for(int i=0;i&lt;n;i++) d[i] = INF; d[s] = 0; int cnt = 0; while(true)&#123; if(cnt &gt; n-1) return false; // exist negative circle cnt++; bool update = false; for(int i=0;i&lt;edges.size();i++)&#123; int from = edges[i].from; int to = edges[i].to; if(d[to] &gt; d[from] + edges[i].w)&#123; d[to] = d[from] + edges[i].w; // par[to] = from; // record path update = true; &#125; &#125; if(update == false) break; &#125; return true;&#125; 练习题]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络流]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[最大流 将 $A$ 看作水源，$G$ 看作汇点，每一条边可以看作管道，每个管道有一个最大容量，每条路上有一个流量。很明显每条管道上的流量是不可能超过管道的容量的。 现在水从A源源不断的流入，那么单位时间内流过 $G$ 的最大流量是多少？ 先介绍增广路的概念 增广路：一条能从起点走到汇点的路，且这条路没有满流的边。 求解最大流的过程实际上就是不断寻找增广路的过程，当图中不存在增广路时，也就意味着水流无法再增加，即已经达到最大流。 但这还存在一些问题，举例说明一下： 首先对 $(s, 1, 2, t)$ 进行增广 再对 $(s ,2 ,t)$ 进行增广 我们发现这并不是最大流，因为 $(1,t)$ 这条边没有用到。 我们希望 $(1,2)$ 这条边的流量可以退回去，然后走 $(1,t)$ 这条边。我们称这个操作称为 退流。 要实现退流，需要在图中加入反向边。反向边的初始容量和流量都为0。 在进行增广的时候，如果某条边的流量增加 $x$，那么要在对应反向边的流量 减去 $x$。 这样的话反向边的流量就会出现负数的情况，我们可以理解为这条边有多少流量可以退流。 以上就是求解最大流的思想，具体的实现方法有很多，接下来会介绍一些常用算法。 时间复杂度分析： 可以证明最多进行 $O(nm)$ 次增广，所以想要优化时间，只能去加速找增广路的速度。如果每次增广都用 $bfs$，则总的复杂度就是 $O(nm^2)$。 Edmond—Karp从源点 $s$ 不断的广搜（BFS），记录从 $s$ 到当前点 $i$ 的可增加的水流量 $a[i]$。 如果 $a[t] &gt; 0$ 那么意味着有一条增广路存在，通过记录路径可以更新这条增广路上的流量。 如果直到搜索结束，$a[t]$ 还是为 $0$，则表示图中没有增广路，此时即可得到最大流。 时间复杂度为 $O(nm^2)$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Edge&#123; int from,to,cap,flow; Edge(int u,int v,int c,int f): from(u),to(v),cap(c),flow(f) &#123;&#125;&#125;;struct EdmonsKarp&#123; //时间复杂度O(v*E*E) int n,m; vector&lt;Edge&gt; edges; //边数的两倍 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号 int a[maxn]; //起点到i的可改进量 int p[maxn]; //最短路树上p的入弧编号 void init(int n)&#123; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap)&#123; edges.push_back(Edge(from,to,cap,0)); edges.push_back(Edge(to,from,0,0)); //反向弧 m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; int Maxflow(int s,int t)&#123; int flow = 0; for(;;)&#123; for (int i = 0; i &lt;= n; i++) a[i] = 0; queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while(!Q.empty())&#123; int x = Q.front();Q.pop(); for(int i=0;i&lt;G[x].size();i++)&#123; Edge&amp; e = edges[G[x][i]]; if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123; //!a[e.to] 是了保证不会回退和出现分叉 p[e.to] = G[x][i]; //记录边的编号 a[e.to] = min(a[x],e.cap - e.flow); Q.push(e.to); &#125; &#125; if(a[t]) break; //走到汇点 &#125; if(!a[t]) break; //没有一条增广路存在 for(int u=t;u != s;u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;; Dinic每次先用 $BFS$ 去构造层次图，然后在层次图上进行 $DFS$ 增广，不断重复这个过程，直到 $BFS$ 无法构建出 $s$ 到 $t$ 的层次图。 在层次图中，到源点 $s$ 的最近距离相同的点集属于同一层。每次 $DFS$ 增广时，只能从当前层次走到下一个层次，这样保证了从 $s$ 到 $t$ 最多经过 $n-1$ 层。 并且每次 $BFS$ 后，$s$ 到 $t$ 的最大距离至少会增加 $1$。因此最多增广 $n-1$ 次。一次 $DFS$ 增广的复杂度是 $O(nm)$（这里与 $EK$ 中的增广不太一样，$EK$ 中每次增广只是更新一条路径，而 $dinic$ 中每次增广是更新了所有可能的路径）。因此总复杂度为 $O(n^2m)$。 对于所有容量均为 $1$ 的图，$dinic$ 的复杂度为 $O(min(n^{\frac{2}{3}}, m^{\frac{1}{2}}) m)$。 对于二分图，$dinic$ 的复杂度为 $O(n^{\frac{1}{2}}m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const int maxn = 1e4 + 6;const int INF = 0x3f3f3f3f;struct Edge &#123; int u, v; int cap, flow; Edge(int u_, int v_, int cap_, int flow_) : u(u_), v(v_), cap(cap_), flow(flow_) &#123;&#125;&#125;;struct Dinic &#123; int n, m, s, t; //结点数，边数（包括反向弧），源点编号和汇点编号 vector&lt;Edge&gt; edges; //边表。edge[e]和edge[e^1]互为反向弧 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号 bool vis[maxn]; // BFS使用 int d[maxn]; //从起点到i的距离 int cur[maxn]; //当前弧下标 void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt;= n; i++) G[i].clear(); edges.clear(); &#125; int AddEdge(int from, int to, int cap) &#123; edges.emplace_back(from, to, cap, 0); edges.emplace_back(to, from, 0, 0); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); return m - 2; &#125; bool BFS() &#123; for (int i = 0; i &lt;= n; ++i) vis[i] = false, d[i] = 0; queue&lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0, v; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; v = e.v; if (!vis[v] &amp;&amp; e.cap &gt; e.flow) &#123; vis[v] = 1; d[v] = d[x] + 1; q.push(v); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int x, int a) &#123; if (x == t || a == 0) return a; int flow = 0, f; for (int &amp;i = cur[x], v; i &lt; G[x].size(); i++) &#123; //从上次考虑的弧 Edge&amp; e = edges[G[x][i]]; v = e.v; if (d[x] + 1 == d[v] &amp;&amp; (f = DFS(v, min(a, e.cap - e.flow))) &gt; 0) &#123; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; &#125; &#125; return flow; &#125; int Maxflow(int s, int t) &#123; this-&gt;s = s, this-&gt;t = t; int flow = 0; while (BFS()) &#123; for (int i = 0; i &lt;= n; i++) cur[i] = 0; flow += DFS(s, INF); &#125; return flow; &#125; int edge_id[maxn]; // 每条边的编号 vector&lt;int&gt; cut; // 割边的编号 void findCut(int m) &#123; cut.clear(); for (int i = 0; i &lt;= n; i++) vis[i] = 0; queue&lt;int&gt; q; q.push(s); vis[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (auto &amp;id : G[u]) &#123; auto &amp;e = edges[id]; if (!vis[e.v] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.v] = 1; q.push(e.v); &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; auto &amp;e = edges[edge_id[i]]; if (vis[e.u] == vis[e.v]) continue; if (e.cap == e.flow) cut.push_back(i + 1); // 1-index &#125; &#125;&#125;; ISAP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const int maxn = "Edit";struct ISAP &#123; int n, m, s, t; //结点数，边数（包括反向弧），源点编号和汇点编号 vector&lt;Edge&gt; edges; //边表。edges[e]和edges[e^1]互为反向弧 vector&lt;int&gt; G[maxn]; //邻接表，G[i][j]表示结点i的第j条边在e数组中的序号 bool vis[maxn]; // BFS使用 int d[maxn]; //起点到i的距离 int cur[maxn]; //当前弧下标 int p[maxn]; //可增广路上的一条弧 int num[maxn]; //距离标号计数 void init(int n) &#123; this-&gt;n = n; for (int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.emplace_back(from, to, cap, 0); edges.emplace_back(to, from, 0, 0); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int Augumemt() &#123; int x = t, a = INF; while (x != s) &#123; Edge&amp; e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; &#125; x = t; while (x != s) &#123; edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a; x = edges[p[x]].from; &#125; return a; &#125; void BFS() &#123; for (int i = 0; i &lt;= n; i++) vis[i] = 0; for (int i = 0; i &lt;= n; i++) d[i] = 0; queue&lt;int&gt; q; q.push(t); d[t] = 0; vis[t] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); int len = G[x].size(); for (int i = 0; i &lt; len; i++) &#123; Edge&amp; e = edges[G[x][i] ^ 1]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123; vis[e.from] = 1; d[e.from] = d[x] + 1; q.push(e.from); &#125; &#125; &#125; &#125; int Maxflow(int s, int t) &#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; BFS(); for (int i = 0; i &lt;= n; i++) num[i] = 0; for (int i = 0; i &lt; n; i++) if (d[i] &lt; INF) num[d[i]]++; int x = s; for (int i = 0; i &lt;= n; i++) cur[i] = 0; while (d[s] &lt; n) &#123; if (x == t) &#123; flow += Augumemt(); x = s; &#125; int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) &#123; ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; &#125; &#125; if (!ok) // Retreat &#123; int m = n - 1; for (int i = 0; i &lt; G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) m = min(m, d[e.to]); &#125; if (--num[d[x]] == 0) break; // gap优化 num[d[x] = m + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; &#125; &#125; return flow; &#125;&#125;; 最小费用最大流思想最小费最大流问题是指：在每条边都有一个权值的时候，使得流量最大时候，权值和最小。 注意这里的费用（可改进量）指的是单位流量的费用。 注意图中可以存在负边，但不能存在负圈。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct Edge&#123; int from,to,cap,flow,cost; Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w) &#123;&#125;&#125;;struct MCMF&#123; int n,m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int inq[maxn]; //是否在队列中 int d[maxn]; //bellmanford 到源点距离 int p[maxn]; //上一条弧 int a[maxn]; //可改进量 void init(int n)&#123; this-&gt; n = n; for(int i=0;i&lt;=n;i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from,int to,int cap,int cost)&#123; edges.push_back(Edge(from,to,cap,0,cost)); edges.push_back(Edge(to,from,0,0,-cost)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BellmanFord(int s,int t,int&amp; flow,ll&amp; cost)&#123; for(int i=0;i&lt;=n;i++) d[i] = INF; for (int i = 0; i &lt;= n; i++) inq[i] = 0; d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; Q; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); inq[u] = 0; for(int i=0;i&lt;G[u].size();i++)&#123; Edge&amp; e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to]) &#123;Q.push(e.to); inq[e.to] = 1;&#125; &#125; &#125; &#125; if(d[t] == INF) return false; // 当没有可增广的路时退出 flow += a[t]; cost += (ll)d[t] * (ll)a[t]; for(int u=t; u!= s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; return true; &#125; int MincostMaxflow(int s,int t,ll&amp; cost)&#123; int flow = 0; cost = 0; while(BellmanFord(s,t,flow,cost)); return flow; &#125;&#125;; 经典建图无源汇可行流（循环流）每条边的流量都有个上下界，并且每个点都要满足流量平衡，所以这一定是一个循环流。 做法： 建立附加源点 $ss$，附加汇点 $tt$。 初始假设每条边都已经有了下界的流量，但这样可能会使得流量不平衡。因此我们需要调整一下流量，使得每个点都满足流量平衡的要求。 建立残余网络，因为默认了每条边都已经拥有了下界的流量，所以每条边的上下界就由 $[low, high]$ 变为了 $[0, high - low]$。 设 $a[i]$ 表示 $i$ 点流入的流量与流出的流量之差。 对于 $a[i] &gt; 0$，建立 $(ss, i)$ 容量为 $a[i]$ 的边。 $a[i] &gt; 0$ 表示 $i$ 点流入的流量多于流出的流量，那我们需要在残余网络上表示出来这个多余的流量，因此建立 $(ss,i)$ 的边，表示 $i$ 点会多进入一些流量。如果最后这个边可以跑满，说明多余的流量可以找到出路，从而可以达到流量平衡。 对于 $a[i] &lt; 0$， 建立 $(i,tt)$ 容量为 $-a[i]$ 的边 同理。 对于原图中的边 $(u, v, low, high)$，建立 $(u,v)$ 容量为 $high - low$ 的边。 原因在上面说过了。 跑 $ss$ 到 $tt$ 的最大流，如果从 $ss$ 出去的边（进入 $tt$ 的边）全部满流，则证明有解，否则无解。 因为这些从 $ss$ 出去的边，都是那些原图中导致了流量不平衡的流量，只有修正了这些流量，才能使得原图流量平衡。 最后每条边的实际流量 = 下界 + 残余网络上的流量。 一道模板题：zoj 2314 有源汇可行流每条边的流量都有个上下界，并且除了源点和汇点之外每个点都要满足流量平衡。 做法： 设源点为 $s$，汇点为 $t$。 建立一条 $(t,s)$ 容量为无穷大的边。 再按照无源汇可行流的方式建图。 跑 $ss$ 到 $tt$ 的最大流，如果从 $ss$ 出去的边（进入 $tt$ 的边）全部满流，则证明有解，否则无解。 有源汇之后，原图就不满足流量平衡了，因为源点和汇点不满足流量平衡。但是因为从源点出发的总流量等于到达汇点的总流量，因此我们可以建立一条 $(t,s)$ 容量为无穷大的边，这样到达汇点的流量就会再流回到源点，从而达到了流量平衡。 最后 $(t,s)$ 这条边的流量就是原图的可行流。 因为建边的时候，$(s,tt)$ 这条边的上界就是所有从 $s$ 点出发的流量的下界。 有源汇上下界最大流每条边的流量都有个上下界，并且除了源点和汇点之外每个点都要满足流量平衡，并且希望总流量尽可能的大。 做法： 按照有源汇可行流的方式建图。 跑 $ss$ 到 $tt$ 的最大流，如果从 $ss$ 出去的边（进入 $tt$ 的边）全部满流，则证明有解，否则无解。 再跑 $s$ 到 $t$ 的最大流，得到的流量即为答案。 如何使可行流变为最大流呢？ 因为每条边的下界都已经满足了，要使得流最大，就要使得残余网络上的流最大。 因此只要跑 $s$ 到 $t$ 的最大流即可。 那么问题来了： 会不会有的边退流之后就不满足最后的流量平衡了？ 不会的，因为退流的操作实际上是：如果现在退流到 $p$ 点，那么 $p$ 点需要去找新的路径到达汇点，如果能找到则退流成功，否则退流失败。从结果上看，从 $p$ 点出去的流量并没有改变，因此不会有问题。 是否需要去掉源点汇点和 $(t,s)$ 这条边？ 实际上不需要去掉附加源点和附加汇点，因为这两个点所连接的边都已经满流了，并且它们都是单向边，因此再次跑 $s$ 到 $t$ 的最大流时附加源汇不会产生任何影响。 也不需要去掉 $(t,s)$ 这条反向边，因为这条边的流量会退回去。跑完 $ss$ 到 $tt$ 的最大流之后，这条边的流量实际上是满足下界的可行流。当我们再次跑 $s$ 到 $t$ 的最大流的时候这条边的流量会退回去，即也会算到答案中，因此不必去掉这条反向边。 一道模板题：zoj 3229 有源汇上下界最小流每条边的流量都有个上下界，并且除了源点和汇点之外每个点都要满足流量平衡，并且希望总流量尽可能的小。 做法： 按照无源汇可行流进行建图 跑 $ss$ 到 $tt$ 的最大流 建立 $(t,s)$ 再跑 $ss$ 到 $tt$ 的最大流，$(t,s)$ 这条边上的流量就是答案 为什么有源汇可行流跑出来的不是最小流？ 如图所示 没有写出来的上下界默认为 $[0, inf]$ 建立残余网络 跑 $ss$ 到 $tt$ 的最大流 可以发现 $(t,s)$ 这条边上的流量是 $5$，也就代表了可行流的大小。但从原图中可以看出，实际上最小的可行流是 $3$。 问题出在哪里呢？ $1$ 号点本可以直接走到 $2$ 点然后到达 $tt$ 点，但是它却经过了 $(t,s)$ 这条边绕了一圈才到 $tt$ 点。然而 $(t,s)$ 这条边的流量表示的是最后可行流的大小，所以想要获得最小流，那么应该让通过 $(t,s)$ 边的流量尽可能地少。 因此我们先不加 $(t,s)$ 这条边，跑一次 $ss$ 到 $tt$ 的最大流，目的就是使那些可以不经过 $(t,s)$ 就可以到达 $tt$ 点的流先流满。然后再加上 $(t,s)$ ，再跑一次 $ss$ 到 $tt$ 的最大流，得到的 $(t,s)$ 边的流量就是答案。 无解的情况还是和上面一样的判断。 一道模板题：uva 1440 无（有）源汇上下界费用流建图方式与对应的可行流是相同的，连接附加源汇的边的费用为 $0$。 最小割在有向图 $G$ 中，每条边都有一个权值，有源点 $s$，汇点 $t$。要使得 $s$ 和 $t$ 不连通，所需要去掉的边的集合称为 $G$ 的一个割。在所有的割中，权值和最小的称为最小割。 定理：最大流 = 最小割 考虑每条从 $s$ 到 $t$ 的流，如果选择割边，那么一定是选这条路上满流的一条边（瓶颈边）。最大流找出了所有的增广路，那么只要切掉每条增广路上的瓶颈边即可，最后割边的总权值就是最大流（因为瓶颈边的流量和权值（容量）相同）。 输出方案满流的边不一定是割边！ 考虑最小割是把 $s$ 和 $t$ 分成了两个不相交的点集。 因此我们可以从 $s$ 点出发，只走未满流的边，走到的点记 $vis[i] = 1$。 那么对于所有访问过的点 $(vis[i] = 1)$，如果他有一条满流的边连向为未访问过的点，则这条边就是割边。 一道模板题： hdu 3251 最大权闭合子图闭合子图：有向图 $G$ 中，称点集 $V$ 是 $G$ 的闭合子图，当且仅当从点集 $V$ 中出发的边的终点都在点集 $V$ 中，即 $V$ 中的所有后继都在 $V$ 中。 最大权闭合子图：每个点都有一个权值（必须有负数，没有负数的话直接全选），所选的闭合子图中点权和最大，可以不选。 做法： $s$ 向所有正权点连边，容量为权值。 所有负权点向 $t$ 连边，容量为权值的绝对值。 其他的边正常连，容量为正无穷。 跑 $s$ 到 $t$ 的最大流，答案为所有正权点的权值和减去最大流。 可以先贪心地把所有的正权点都选上，因为有些正权点的后继中既包含负权点也包含正权点，因此要么我们就把那些负权点选上，要么我就丢弃一些正权点。即我们的答案要不然就是减去一些正权点，要么就是减去一些负权点的绝对值。我们当然希望减去的东西越小越好。这个问题可以转化为一个最小割的模型。 按照上面的建图方式，大致可以分三种情况： 第一种： 跑完最大流（最小割）之后，可以看到流量是 $3$，表示要选上这些负权点，这些负权点的影响是 $3$。 第二种： 对于这张图，跑完最大流（最小割）之后流量是 $5$，表示这个正权点要去掉，他的影响是 $5$。 第三种： 图中存在反向边，但实际上反向边并不会影响结果。 对于那些没有依赖关系的正权点，是不会割到的（即不会丢弃）。 对于那些没有依赖关系的负权点，也是不会割到的（即不会选）。 输出方案割边只可能是那些连接着源点或汇点的边，因为其他边的容量都是正无穷。 连接源点的割边就是要舍弃的正权点，连接汇点的割边就是要加入的负权点。 一道模板题：洛谷 2762 推广其实这种建图方式可以解决一类问题： 每个点都有个权值，现在我可以选择某些点，使得权值和最大。 但是某些点之间可能存在直接或间接的依赖关系，因此选择某个点之后，可能某些点就无法选择了，或者某些点就必须要选择。 这种类型的都可以使用 最大权闭合子图 的建图方式，只不过中间的边的容量可能不是正无穷。 割边的意义根据题意来表示，不过无非就是选或不选。 例题：hdu 3251 最大密度子图定义一个无向图 $G = (V,E)$ 的密度 $D$ 为该图的边数与点数的比值。 $$D = \frac{|E|}{|V|}$$ 做法： 这实际上是一个分数规划问题。我们二分答案 $g$ 设 $h(g) = max {|E’| - |V’| \times g } $ 12h(g) &lt; 0 -&gt; g &gt; Dh(g) &gt; 0 -&gt; g &lt; D 求解 $h(g)$ 的问题可以转化为求最大闭合子图。 二分的精度为 $eps = \frac{1}{n\times n}$。 二分的上下界为 $[0,|E|]$。 源点向每条边建立容量为 $1$ 的边。 每条边向其两个顶点建立无穷大的边。 每个顶点向汇点建立容量为 $g$ 的边。 跑 $s$ 到 $t$ 的最大流，答案为 $|E| - flow$。 割边中连接着源点的是不选的边，连接着汇点的是要选的点。 拆点与拆边朴素的拆点与拆边可以用来保证该点（边）经过不超过 $k$ 次，即节点（边）容量。 还有一种是类似多重背包的拆点（边）。 拆点例题二维网格图上，有 $n$ 个交点上有人。你从基地出发，想要把这 $n$ 个人接回基地，但是你的车最多一次坐两个人。问最少的距离把这n个人接回基地？ $n \leq 24$ 因为一次最多接两个人，那么我们可以枚举所有的两人组合。从 $s$ 向每个两人组合连边，容量为 $1$，权值为接回来的距离。然后限制每个人只能接一次，就要把这 $n$ 个人拆点，中间建一条容量为 $1$ 费用为 $0$ 的边。最后每个两人组合 向 其所影响的两个人连边。（还有可能每次只接一个人） 拆边例题$n$ 个城市，$m$ 条有向路，现在要运送 $k$ 个货物从 $1$ 号城市到 $n$ 号城市。每条路有个系数 $a_i$，和一个流量上限 $c_i$，运送 $x$ 个货物的花费为 $a_ix^2$。现在求运送完成的最小花费。 $c_i \leq 5$ 因为花费不是线性的，所以没有办法表示单位流量费用。但我们注意到一条路最多运送5个货物，因此我们可以将费用拆开来建边。即拆成：$a,3a,5a,7a,9a$ 这样的费用。 区间模型区间K覆盖给定 $n$ 个开区间 $(a_i,b_i)$，每个区间有个权值 $w_i$，每个数字最多被覆盖 $k$ 次。问最大价值？ 数轴上相邻点的容量为 $k$，费用为 $0$。$a_i$ 到 $b_i$ 的容量为 $1$，价值为$-w_i$。跑一遍最小费用最大流即可。 对于点数多，区间少的情况可以离散化。 模板题 poj3680]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序思想拓扑排序: 就是按照逻辑上先后发生的顺序进行排序。 所以只有 有向图 才有拓扑序。 根据定义，如果图中有环则不能拓扑排序。 常用的方法有两种，一种是dfs，一种是根据度来bfs（可以字典序）。 这里主要介绍第二种方法。 把每一个事件都看作一个点。如果a事件在b事件后面发生，则连一条a到b的有向边。 如果一个点的入度为0，那么说明没有事件早于它发生，则将它入队。所以我们要先将所有入度为0的点入队。 每次取队头元素记为u， 将所有与u相连的点的入度减一，如果入度为0了，则入队。 如果原图中存在环，则最后topo数组内元素的数量一定小于n。 优点： 这种方法是以点为重心，dfs是以边为重心。那么如果有删边的操作，最好就用第二种方法 ： 直接入度减一即可。 可以保证拓扑序是按照字典序的。 如果想要输出是字典序的话，需要将队列改为优先队列。（ 如果用邻接矩阵实现，需要去重边 注意 : 判环的时候，如果是邻接矩阵实现，则要判重边！ 模板1234567891011121314151617181920212223242526vector&lt;int&gt; G[maxn],topo; //存图； 记录拓扑序。int deg[maxn];void addedge(int u,int v)&#123; G[u].push_back(v);&#125;bool Topo(int n)&#123; queue&lt;int&gt; Q; topo.clear(); for(int i=1;i&lt;=n;i++) if(deg[i] == 0) Q.push(i); while(!Q.empty())&#123; int u = Q.front(); Q.pop(); topo.push_back(u); for(int i=0;i&lt;G[u].size();i++)&#123; int v = G[u][i]; if(deg[v] &gt; 0)&#123; deg[v]--; if(deg[v] == 0) Q.push(v); &#125; &#125; &#125; if(topo.size() != n) return false; //存在环 return true;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>拓扑排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图最大权完美匹配]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[二分图最大权完美匹配思想 根据 大牛博客 改编 注意前提是二分图存在完美匹配 核心思想： 调整思想 讲算法之前先问个问题： 如果你要结婚，你会选择你爱的还是爱你的？（请各位直男以girl的角度回答） 相信大部分人的回答都是找一个爱自己多一点的。至于为什么…爱过你就知道了。 那么问题来了，我们如何高效的找出一种匹配方法，使得每个女孩都能尽可能的被爱自己更多的人在一起？ 如图，每条红线表示男生对女生的喜欢程度。 女生左边的数字是她们心里的期望。（即男生对她最大的喜欢程度） 男生右边的数字是他们的自我膨胀指数（后面会解释）。 问题搞清楚了，那么怎么找呢？ 首先，要理解这个算法，必须先明白几个道理： （如果你是从二分图匹配看下来的，那么你会发现接下来的男女和讲二分图匹配的时候顺序反了过了。只是因为网上的图是这么给的，所以就这么讲了。（其实是因为我有一颗男女平等的心）） 女生都有一颗不过分的舍己为人的心 （同二分图最大匹配） 女生在选男朋友的时候，只要这个男朋友满足她心里的期望，她就会选择他。 原因是：女生不傻，她的期望一定是在可满足范围内最高的，即总会存在至少一个男生满足她的心理期望。 男生也是人，也有自尊。 如果现在只有林俊杰和我同时喜欢徐佳莹，但是我对徐佳莹的喜欢有5分，林俊杰对她的喜欢只有3分。那么徐佳莹的心理期望肯定是5分，肯定也会选我作为她的男盆友 (๑•̀ㅂ•́)و✧ 徐佳莹选完之后，张碧晨开始选。她发现所有男生里只有我喜欢她，所以她不得不选我。但是因为我之前被徐佳莹选走了，抱着一颗舍己为人的心，徐佳莹只能重新选择林俊杰。所以徐佳莹的心理期望必须要由5降到3。那我就开始膨胀了，毕竟现在我是抢手货了，我的膨胀指数就会相应的增加2（后面有解释）。（可把我牛逼坏了，叉会腰&lt;(￣︶￣)&gt;)。我一膨胀，那么碧晨的期望值就要下降（毕竟哥哥我现在是抢手货，肯定不能像以前一样宠着她了），那么她的心理期望就应该成为： 我原来对她的喜欢程度 - 我的膨胀指数。 为什么增加2 ：可以从两个方面理解 一： 本来我对徐佳莹需要五分的喜欢，她才会选我。现在她的期望变成了三，所以只要三分就可以了。我就会觉得我的个人魅力（膨胀指数）提高了两分。（应该蛮好理解的吧，如果还是不理解…先去谈恋爱吧） 二： 参考接下来的第4条。 那么现在我们可以知道女生选择男朋友的条件实际上是： 心理期望 == 该男生对她原本的喜欢程度 - 该男生的膨胀指数 算法的原理其实和二分图最大匹配的原理差不多，只不过多出来了期望值和自我膨胀指数这两个东西。所以在每次无法成功找到匹配的时候都要相应的去减少女生的期望和增加男生的膨胀指数，然后再重新匹配，直到匹配成功为止，因为图本身就是完全图，所以一定会有解。 需要注意的是，为了保证所求的结果是最大的。 我们在女生降低期望时希望降低的尽可能小，于是这里用一个slack数组维护： 当一个女生需要重新选择时，她所需要降低的最小期望值。 同时，这个值也是男生所增加的膨胀值。 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 复杂度 O(nx * nx * ny)// x - girl , y - boy// lx - 心理期望 ly - 膨胀指数// slack - 女生心理期望降低的最小程度 或 男生膨胀指数增加的最小程度int nx,ny;int G[maxn][maxn];int linker[maxn],lx[maxn],ly[maxn];int slack[maxn];bool visx[maxn],visy[maxn];void addedge(int i,int k,int w)&#123; G[i][k] = w;&#125;bool dfs(int x) &#123; visx[x] = true; for (int y = 0; y &lt; ny; y++) &#123; if (visy[y]) continue; int temp = lx[x] + ly[y] - G[x][y]; //心理期望与男生实际喜欢自己程度的差值 if (temp == 0) &#123; // 该男生满足心理期望 visy[y] = true; if (linker[y] == -1 || dfs(linker[y])) &#123; linker[y] = x; return true; &#125; &#125; else if (slack[y] &gt; temp) //不满足心理期望，记录女生需要降低多少心理期望 slack[y] = temp; &#125; return false;&#125;int KM() &#123; memset(linker, -1, sizeof(linker)); memset(ly, 0, sizeof(ly)); //一开始男生一点都不膨胀 for (int i = 0; i &lt; nx; i++) &#123; lx[i] = NINF; for (int k = 0; k &lt; ny; k++) &#123; if (G[i][k] &gt; lx[i]) &#123; lx[i] = G[i][k]; &#125; &#125; &#125; for (int x = 0; x &lt; nx; x++) &#123; for (int i = 0; i &lt; ny; i++) slack[i] = INF; while (true) &#123; memset(visx, 0, sizeof(visx)); memset(visy, 0, sizeof(visy)); if (dfs(x)) break; // 如果x女生匹配成功则退出 int d = INF; for (int i = 0; i &lt; ny; i++) &#123; if (!visy[i] &amp;&amp; d &gt; slack[i]) d = slack[i]; // 记录x女生需要降低的最小期望值 &#125; for (int i = 0; i &lt; nx; i++) &#123; if (visx[i]) lx[i] -= d; &#125; for (int i = 0; i &lt; ny; i++) &#123; if (visy[i]) ly[i] += d; //女生期望降低对应着某些男性的膨胀 else slack[i] -= d; //因为女生的心理期望降低了，所以该女生和其它备胎之间的差值也会缩小 &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; ny; i++) &#123; if (linker[i] != -1) res += G[linker[i]][i]; &#125; return res;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分图]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[二分图二分图定义二分图的几种定义 ： 不含奇环的图 用两种颜色给每个顶点染色，可以保证相邻的顶点颜色不同 可以分成两堆，所有的边都是从一堆连到另一堆的 二分图判定判定方法 ： 染色法 12345678910111213141516171819202122232425vector&lt;int&gt; G[maxn];int color[maxn];// 把顶点染成1或-1bool dfs(int u,int c)&#123; color[u] = c; //把u点染成颜色c for(auto v : G[u])&#123; if(color[v] == c) return false; if(color[v] == 0 &amp;&amp; !dfs(v,-c)) return false; &#125; return true;&#125;void solve(int n)&#123; memset(color,0,sizeof(color)); for(int i=0;i&lt;n;i++)&#123; if(color[i] == 0)&#123; if(!dfs(i,1))&#123; cout &lt;&lt; "No" &lt;&lt; '\n'; return ; &#125; &#125; &#125; cout &lt;&lt; "Yes" &lt;&lt; '\n';&#125; 二分图上最大匹配和最小点覆盖的关系最大匹配数 = 最小点覆盖数 证明： 采用反证法。 首先，最小点覆盖的数量一定大于等于最大匹配数。若现在有一条边没有被覆盖，这与最大匹配数相矛盾。得证。 与最小边覆盖的关系最小边覆盖数 = 顶点数 - 最大匹配数 证明： 设最大匹配数为n，顶点数为V。 我们可以先选n条边，这样只剩 $V - 2\times n$ 个点了。 接下来只能一条边搞一个点，所以还需要 $V - 2\times n$条边。 于是，最小边覆盖数 $= V - 2\times n + n = V - n$ 与最大独立集的关系独立集：给定图$G=(V,E)$,$V’$ 是$V$的一个非空子集。若$V’$的任何两个顶点$u,v$都不是同一条边的两个端点，则称$V’$是$G$的一个空子图。设$V’$是G的空子图，若$V’$任意增加一个$G$中不在$V’$中的点后都不是空子图，则称$V’$是$G$的独立集。$G$中所含顶点数最多的独立集$V’$称为$G$的最大独立集。 最大独立集中的顶点数 = 最小边覆盖数 = 总顶点数 - 最大匹配数(最小顶点覆盖) 总顶点数再去最小顶点覆盖数就是孤立点的数目。这些点相互之间都没有边。 与最小支配集的关系支配集：设$G=(V,E)$是无向简单图，$S$是$V$的一个非空子集。若对于不在$S$中的$G$的点$u$，$u$与$S$里至少一个顶点$v$相关联，则称$S$是图$G$的支配集。设$S$是图$G$的支配集，若$S$的任何真子集都不是$G$的支配集，则称$S$为图$G$的极小支配集。$G$中含顶点数最少的支配集$S$，称为$G$的最小支配集，其顶点个数$|S|$称为图$G$的支配数。 设$G$是无孤立顶点的图，则$G$的极大独立集必为极小支配集，其逆不真。]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>二分图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324namespace Matrix &#123;// Matrix mat(row, vec(col));typedef vector&lt;ll&gt; vec;typedef vector&lt;vec&gt; mat;mat mul(mat&amp; A, mat&amp; B) &#123; mat C(A.size(), vec(B[0].size())); for (int i = 0; i &lt; A.size(); i++) for (int k = 0; k &lt; B.size(); k++) if (A[i][k]) for (int j = 0; j &lt; B[0].size(); j++) C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod; return C;&#125;mat Pow(mat A, ll n) &#123; mat B(A.size(), vec(A.size())); for (int i = 0; i &lt; A.size(); i++) B[i][i] = 1; while (n) &#123; if (n &amp; 1) B = mul(B, A); A = mul(A, A); n &gt;&gt;= 1; &#125; return B;&#125;&#125; // namespace Matrix 1234567891011121314151617181920212223242526272829struct Mat&#123; ll m[maxn][maxn];&#125;;Mat operator * (Mat a, Mat b)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i=0;i&lt;n;i++)&#123; for(int k=0;k&lt;n;k++)&#123; if(a.m[k][i] == 0) continue; for(int p=0;p&lt;n;p++)&#123; if(b.m[i][p] == 0) continue; c.m[k][p] = (c.m[k][p] + a.m[k][i] * b.m[i][p] % mod ) % mod; &#125; &#125; &#125; return c;&#125;Mat operator ^ (Mat a,int x)&#123; Mat c; for(int i=0;i&lt;n;i++) for(int k=0;k&lt;n;k++) c.m[i][k] = (i == k); for(; x ; x &gt;&gt;= 1)&#123; if(x &amp; 1) c = c * a; a = a * a; &#125; return c;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>常用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[一次不定方程设整数$k \geq 2$,$c,a_1…a_k$是整数，且$a_1…a_k$都不等于零，以及$x_1…x_k$是整数变数，方程$$a_1x_1 + … + a_kx_k = c \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)$$ 称为k元一次不定方程,$a_1….a_k$称为它的系数. (1)有解的充要条件: $gcd(a_1..a_k) | c$ 二元一次方程对于$ax + by = gcd(a,b)$ 可以利用辗转相除法得到一组整数解$(x_0,y_0)$ 那么对于$ax+by=c$ 方程有解当且仅当$gcd(a,b) | c$ 解为$$\begin{cases} x = x_{0} \times \frac{c}{gcd(a,b)} + \frac{b}{gcd(a,b)}\times t\\ {y = y_{0} \times \frac{c}{gcd(a,b)} - \frac{a}{gcd(a,b)}\times t} \end{cases}$$ $t = 0,\pm1,\pm2….$ 47x - 30y = 1与47x + 30y = 1之间有没有差别呢？ 其实是没有的，实际手算过程是是不考虑负号的，最后结束的时候才会考虑。所以在传递参数的时候只要传递47和30即可(不能传递47和-30！！)，然后再去直接改变x和y的符号. 手算模拟： 47 = 30*1 + 17 30 = 17*1 + 13 17 = 13*1 + 4 13 = 4*3 + 1 4 = 4*1 17 = 47 - 30*1 13 = 30 - 17*1 4 = 17 - 13*1 1 = 13 - 4*3 1 = 13 - (17 - 131)3 = 47(-7) + 3011 x = -7 y = 11 模板123456789101112131415161718192021222324// ax + by = gcd(a,b)// return d = gcd(a,b)ll ex_gcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (a == 0 &amp;&amp; b == 0) return -1; // 无最大公因数 ll d = a; if (b) d = ex_gcd(b, a % b, y, x), y -= x * (a / b); else x = 1, y = 0; return d;&#125;// X = x + dx * t, Y = y - dy * t// x是最小非负整数解bool solve(ll a, ll b, ll c, ll &amp;x, ll &amp;y, ll &amp;dx, ll &amp;dy) &#123; ll x0, y0, d; d = ex_gcd(a, b, x, y); if (d == -1 || c % d) return false; //无解 dx = b / d, dy = a / d; x = x0 * c / d; x = (x % dx + dx) % dx; y = (c - a * x) / b; return true;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2018%2F03%2F09%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树思想线段树是一棵二叉树，用来维护区间信息。 树的叶子用来记录结点信息，其父亲记录所有儿子(子区间)的信息。 根节点记录的就是整个区间的信息。 通过pushup的操作，将底层信息向根结点进行反馈。 通过pushdown的操作，将标记下放。 区间合并: 对于区间合并。 我们需要维护三个值： 最长连续子区间 - mx 包含左端点的最长连续子区间 - lmx 包含右端点的最长连续子区间 - rmx 那么对mx的更新，它的可能值有三个： 左儿子的mx 右儿子的mx 左儿子的mmx + 右儿子的lmx 对于lmx的更新： 左儿子的lmx 如果左儿子的lmx值为 左儿子区间长度(lson_len) 的话，那么还要加上右儿子的lmx 对于rmx的更新： 右儿子的rmx 如果右儿子的rmx值为 右儿子的区间长度(rson_len) 的话，那么还要加上左儿子的rmx 证明： 模板1234567// 左闭右闭#define lson (rt &lt;&lt; 1)#define rson (rt &lt;&lt; 1 | 1)#define lson_len (len - (len &gt;&gt; 1))#define rson_len (len &gt;&gt; 1)const int maxn = "Edit";int seg[maxn &lt;&lt; 2]; 单点更新，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 左闭右闭 [l,r]void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void build(int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] = num[l]; // cin &gt;&gt; seg[rt]; //建立的时候直接输入叶节点 return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int p, int add, int l, int r, int rt) &#123; if (l == r) &#123; seg[rt] += add; return; &#125; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, add,l,m,lson); else update(p, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; // L R 是要查询的区间 if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) s += query(L, R, l,m,lson); if (m &lt; R) s += query(L, R, m+1,r,rson); return ret;&#125;// update interval// lazy[rt]用于存放懒惰标记，注意PushDown时标记的传递const int maxn = "Edit";int lazy[maxn &lt;&lt; 2], seg[maxn &lt;&lt; 2];void pushup(int rt) &#123; seg[rt] = seg[lson] + seg[rson]; &#125;void pushdown(int rt, int len) &#123; if (lazy[rt] == 0) return; lazy[lson] += lazy[rt]; lazy[rson] += lazy[rt]; seg[lson] += lazy[rt] * lson_len; seg[rson] += lazy[rt] * rson_len; lazy[rt] = 0;&#125;void build(int l, int r, int rt) &#123; lazy[rt] = 0; if (l == r) &#123; seg[rt] = num[l]; //cin &gt;&gt; seg[rt]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l,m,lson); build(m+1,r,rson); pushup(rt);&#125;void update(int L, int R, int add, int l, int r, int rt) &#123; // L R 是要更新的区间 if (L &lt;= l &amp;&amp; r &lt;= R) &#123; lazy[rt] += add; seg[rt] += add * (r - l + 1); return; &#125; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, add, l,m,lson); if (m &lt; R) update(L, R, add, m+1,r,rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) return seg[rt]; pushdown(rt, r - l + 1); int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) ret += query(L, R, l,m,lson); if (m &lt; R) ret += query(L, R, m+1,r,rson); return ret;&#125;// interval mergestruct Seg&#123; int mx,lmx,rmx;&#125;;void pushup(int rt,int len)&#123; seg[rt].mx = max(seg[lson].mx, max(seg[rson].mx, seg[lson].rmx + seg[rson].lmx)); seg[rt].lmx = seg[lson].lmx; seg[rt].rmx = seg[rson].rmx; if(seg[rt].lmx == lson_len) seg[rt].lmx += seg[rson].lmx; if(seg[rt].rmx == rson_len) seg[rt].rmx += seg[lson].rmx;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[单调栈模板12345678910111213141516171819202122232425int L[maxn], R[maxn];int a[maxn];// 找到左边第一个大于它的元素位置l，和右边第一个大于它的元素位置r// [l,r]void init(int n) &#123; stack&lt;int&gt; st; for (int i = 0; i &lt; n; i++) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) L[i] = 0; else L[i] = st.top() + 1; st.push(i); &#125; while (!st.empty()) st.pop(); for (int i = n - 1; i &gt;= 0; i--) &#123; while (!st.empty() &amp;&amp; a[i] &gt; a[st.top()]) st.pop(); if (st.empty()) R[i] = n-1; else R[i] = st.top() - 1; st.push(i); &#125;&#125; 练习题poj2559 最大公共矩形题意 给定若干小矩形的高度（默认宽度都为 1），求出最大公共矩形。 分析我们想知道每个矩形向右能扩展多大和向左能扩展多大。枚举当然可以，这里介绍一种复杂度更低的做法，单调栈。从左向右遍历。保持栈里元素单调递增。对于每个 pop 出来的矩形，可以得到它所对应的左右扩展的位置。具体可以看代码 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;typedef long long ll;ll ans;int n;ll num[100005];void solve()&#123; stack&lt;pair&lt;int, ll &gt; &gt; st; for(int i= 0 ; i &lt; n; i++)&#123; int pos = i; //记录向左可扩展到的位置 while(st.size() &amp;&amp; num[i] &lt; st.top().second)&#123; pair&lt;int,ll&gt; temp = st.top(); pos = temp.first; st.pop(); ans = max(ans,(i - temp.first)*temp.second); &#125; st.push(make_pair(pos,num[i])); &#125; while(st.size())&#123; //若栈不为空，则继续pop pair&lt;int,ll&gt; temp = st.top(); st.pop(); ans = max(ans, (n - temp.first)*temp.second); &#125;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF)&#123; if(!n) break; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;num[i]); &#125; ans = -1000000; solve(); printf("%lld\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
</search>
