---
title: 图的匹配算法
date: 2019-10-27 12:29:07
categories:
- ACM
- 图论
tags:
- 图的匹配算法
---

参考文献：IOI国家集训队2015年论文——《浅谈图的匹配算法及其应用》。

本文只对论文中所提到的算法进行实现。


# 二分图最大匹配

## Dinic

## 增广路算法（匈牙利）

# 二分图最大匹配关键点

```cpp
struct MaxMatch {
  int n, clk;
  vector<int> G[maxn];
  int vis[maxn], ls[maxn], rs[maxn];
  void init(int n) {
    this->n = n;
    for (int i = 0; i < n; i++) G[i].clear();
    memset(rs, -1, sizeof(rs));
    memset(ls, -1, sizeof(ls));
    memset(vis, -1, sizeof(vis));
  }
  void addEdge(int u, int v) { G[u].push_back(v); }
  bool dfs(int u) {
    for (auto &v : G[u]) {
      if (vis[v] == clk) continue;
      vis[v] = clk;
      if (rs[v] == -1 || dfs(rs[v])) {
        ls[u] = v;
        rs[v] = u;
        return true;
      }
    }
    return false;
  }
  int match() {
    int ret = 0;
    for (clk = 0; clk < n; clk++)
      if (dfs(clk)) ++ret;
    return ret;
  }
  // ---------------------------------------
  void dfs_kp_ls(int u) {
    vis[u] = 1;
    for (auto &v : G[u]) {
      if (rs[v] == -1 || vis[rs[v]]) continue;
      dfs_kp_ls(rs[v]);
    }
  }
  void dfs_kp_rs(int u) {
    vis[u] = 1;
    for (auto &v : G[u]) {
      if (ls[v] == -1 || vis[ls[v]]) continue;
      dfs_kp_ls(ls[v]);
    }
  }
  // O(n+m)
  int findKeyPoint() {
    // match();
    memset(vis, 0, sizeof(vis));
    int ret = 0;
    for (int i = 0; i < n; i++)
      if (ls[i] == -1) dfs_kp_ls(i);
    for (int i = 0; i < n; i++)
      if (!vis[i]) ret++;

    memset(vis, 0, sizeof(vis));
    for (int i = 0; i < n; i++)
      if (rs[i] == -1) dfs_kp_rs(i);
    for (int i = 0; i < n; i++)
      if (!vis[i]) ret++;

    return ret;
  }
} bio;
```