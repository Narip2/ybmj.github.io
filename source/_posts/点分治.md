---
title: 点分治
date: 2019-05-21 12:58:20
categories:
- ACM
tags:
- 分治
---


树上权值和小于等于k的路径数 [poj1741](https://vjudge.net/problem/POJ-1741)

树上权值和为k的倍数的路径数 [bzoj2152](https://www.lydsy.com/JudgeOnline/problem.php?id=2152)

树上权值和为素数的路径数 [PRIMEDST](https://www.codechef.com/problems/PRIMEDST)

## 模板
```cpp
const int maxn = 1e5 + 5;
int rt, ans, treesz;
bool vis[maxn];
vector<pii> G[maxn];
int heavySonSz[maxn], sz[maxn];
vector<int> nodes;

// 找重心
void getRoot(int u, int fa) {   
    sz[u] = 1, heavySonSz[u] = 0;
    for (int i = 0; i < G[u].size(); i++) {
        int v = G[u][i].first;
        if (vis[v] || v == fa) continue;
        getRoot(v, u);
        sz[u] += sz[v];
        heavySonSz[u] = max(heavySonSz[u], sz[v]);
    }
    heavySonSz[u] = max(heavySonSz[u], treesz - sz[u]);
    if (heavySonSz[u] < heavySonSz[rt]) rt = u;
}

void dfsSub(int u, int fa, int val) {
    // 对子树中每个点的操作
    nodes.push_back(u);
    for (int i = 0; i < G[u].size(); i++) {
        int v = G[u][i].first;
        int w = G[u][i].second;
        if (vis[v] || v == fa) continue;
        dfsSub(v, u, val + w);
    }
}

int cal(int u, int val) {
    // 遍历子树得到想要的信息
    nodes.clear();
    dfsSub(u, 0, val);
    int ret = 0;
    // 计算贡献
    for (int i = 0; i < nodes.size(); i++) {

    }
    return ret;
}

void dfs(int u) {
    vis[u] = 1;
    ans += cal(u, 0);
    for (int i = 0; i < G[u].size(); i++) {
        int v = G[u][i].first;
        if (vis[v]) continue;
        ans -= cal(v, G[u][i].second);  // 减去两端点在同一子树中的贡献
        treesz = sz[v], rt = 0, getRoot(v, u);
        dfs(rt);
    }
}
```