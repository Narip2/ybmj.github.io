---
title: 欧拉降幂
comments: true
date: 2018-07-15 21:05:33
categories:
- ACM
- 数学
- 数论
- 欧拉降幂
---

# 欧拉降幂

在模 $p$ 意义下：

$$a^b \equiv \begin{cases}
        a ^{b \% \phi(p)} \quad gcd(a,p) = 1\\\\
        a^b     \quad   gcd(a,p) \neq 1, b < \phi(p) \\\\
        a ^{b \% \phi(p) + \phi(p)} \quad gcd(a,p) \neq 1, b \geq \phi(p)
        \end{cases}
        $$

对于 $b$ 和 $\phi(p)$ 的相对大小，可以在快速幂的过程中判断。

# 例题

[题目链接](https://nanti.jisuanke.com/t/41299)

题意： 计算 $a^{a^{a^{...}}} \% m $ 的值， 一共有 $b$ 个 $a$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int maxn = 1e7 + 5;
bool vis[maxn];
int prime[maxn], phi[maxn];
void CalPhi() {
  memset(vis, 0, sizeof(vis));
  phi[1] = 1;
  int tot = 0;
  for (int i = 2; i < maxn; i++) {
    if (!vis[i]) {
      prime[tot++] = i;
      phi[i] = i - 1;
    }
    for (int k = 0; k < tot && 1LL * i * prime[k] < maxn; k++) {
      vis[i * prime[k]] = 1;
      if (i % prime[k] == 0) {
        phi[i * prime[k]] = phi[i] * prime[k];
        break;
      }
      phi[i * prime[k]] = phi[i] * (prime[k] - 1);
    }
  }
}

/*
 快速幂的时候更改取模方式。
 保证在 a^b < p 的时候返回 a^b；在 a^b >=p，返回 a^b % p + p。
*/
#define Mod(x, p) (x < p ? x : x % p + p);
ll Pow(ll a, ll b, ll p) {
  ll ret = 1;
  bool ok = false;
  while (b) {
    if (b & 1) ret = Mod(ret * a, p);
    a = Mod(a * a, p);
    b >>= 1;
  }
  return Mod(ret, p);
}

// --------------------------------------------------------
ll cal(int a, int b, int p) {
  if (b == 1 || p == 1) return a < p ? a : a % p + p;
  return Pow(a, cal(a, b - 1, phi[p]), p);
}
int main() {
  CalPhi();
  int T;
  scanf("%d", &T);
  while (T--) {
    int a, b, m;
    scanf("%d%d%d", &a, &b, &m);
    if (!b) {
      printf("%d\n", 1 % m);
      continue;
    }
    ll ans = cal(a, b, m) % m;
    printf("%lld\n", ans);
  }
}
```