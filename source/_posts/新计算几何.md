---
title: 新计算几何
date: 2019-10-31 20:48:03
categories:
- ACM
- 计算几何
tags:
- 计算几何
---

# 点积
$\vec{a} \cdot \vec{b} = |\vec{a}| \cdot |\vec{b}| \cdot cos(\theta) = a_x \cdot b_x + a_y \cdot b_y$

1. $\vec{a} \cdot \vec{b} < 0$ 两向量成钝角
2. $\vec{a} \cdot \vec{b} = 0$ 两向量垂直
3. $\vec{a} \cdot \vec{b} > 0$ 两向量成锐角

几何意义：一个向量在另一个向量上的投影长度。

# 叉积

$|\vec{a} \times \vec{b}| = |\vec{a}| \cdot |\vec{b}| \cdot sin<\vec{a}, \vec{b}> = x_a \times y_b - x_b \times y_a$

$sin<\vec{a}, \vec{b}>$ 指有向角。即从 $\vec{a}$ **逆时针**旋转到 $\vec{b}$ 的角度。

1. $\vec{a} \times \vec{b} < 0$ $\vec{a}$ 在 $\vec{b}$ 的逆时针
2. $\vec{a} \times \vec{b} = 0$ 两向量同向或反向
3. $\vec{a} \times \vec{b} > 0$ $\vec{a}$ 在 $\vec{b}$ 的顺时针

叉积还可以表示以两向量为边的平行四边形的有向面积。

# 极角排序

直接用 $atan2$ 这个函数进行极角排序的话，精度是非常查的。考虑 $(1e9,1), (1e9-1,1)$ 这两个向量的极角，差距是非常小的，大概在 $1e{-18}$ 左右。

而如果纯用叉积来判断，会出现环的情况。

所以我们可以先将平面分为两个半区：上半区和下半区。对于处在同一半区的向量，利用叉积来判断相对位置即可。

经典题目：[Rikka with Triangles](http://hihocoder.com/problemset/problem/1879)



```cpp
#include <bits/stdc++.h>
using namespace std;

using db = double;
const db eps = 1e-9;

inline int sign(db a) { return a < -eps ? -1 : a > eps; }
inline int cmp(db a, db b) { return sign(a - b); }

struct Point {
  db x, y;

  Point operator+(const Point &rhs) const { return {rhs.x + x, rhs.y + y}; }
  Point operator-(const Point &rhs) const { return {x - rhs.x, y - rhs.y}; }
  Point operator*(db rhs) const { return {x * rhs, y * rhs}; }
  Point operator/(db rhs) const { return {x / rhs, y / rhs}; }

  bool operator<(const Point &rhs) const {
    int s = cmp(x, rhs.x);
    if (s) return s == -1;
    return cmp(y, rhs.y) == -1;
  }
  bool operator==(const Point &rhs) const {
    return cmp(x, rhs.x) == 0 && cmp(y, rhs.y) == 0;
  }

  // 是否在上半区
  bool quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }

  // (-pi, pi]
  db alpha() { return atan2(y, x); }

  db abs2() { return x * x + y * y; }
  db abs() { return sqrt(abs2()); }
  db distTo(const Point &rhs) { return (*this - rhs).abs(); }

  db dot(const Point &rhs) { return x * rhs.x + y * rhs.y; }
  db det(const Point &rhs) { return x * rhs.y - y * rhs.x; }

  Point rotate(db an) {
    return {x * cos(an) - y * sin(an), x * sin(an) + y * cos(an)};
  }
};

inline db cross(const Point &a, const Point &b) {
  return a.x * b.y - a.y * b.x;
}
inline db cross(const Point &a, const Point &b, const Point &c) {
  return cross(b - a, c - a);
}
inline db dot(const Point &a, const Point &b) { return a.x * b.x + a.y + b.y; }
inline db dot(const Point &a, const Point &b, const Point &c) {
  return dot(b - a, c - a);
}

// 先判断是否处于同一半区，再根据叉积判断相对位置
bool cmpAngle(Point a, Point b) {
  if (a.quad() != b.quad())
    return a.quad() < b.quad();
  else
    return sign(cross(a, b)) > 0;
}

// 直线平行
bool isLLparallel(const Point &a, const Point &b, const Point &c,
                  const Point &d) {
  db a1 = cross(c, d, a), a2 = -cross(c, d, b);
  return sign(a1 + a2) != 0;
}

Point intersectLL(const Point &a, const Point &b, const Point &c,
                  const Point &d) {
  db x = cross(c, d, a), y = -cross(c, d, b);
  return (a * y + b * x) / (x + y);
}

// p1 -> p2 左侧
vector<Point> ConvexCut(const vector<Point> &ps, Point p1, Point p2) {
  vector<Point> ret;
  int n = ps.size();
  for (int i = 0; i < n; i++) {
    auto p3 = ps[i], p4 = ps[(i + 1) % n];
    int s1 = sign(cross(p1, p2, p3)), s2 = sign(cross(p1, p2, p4));
    if (s1 >= 0) ret.push_back(p3);
    if (s1 * s2 < 0) ret.push_back(intersectLL(p1, p2, p3, p4));
  }
  return ret;
}

struct Line {
  // p[0] -> p[1]
  Point p[2];
  Point &operator[](int k) { return p[k]; }
  Point dir() { return p[1] - p[0]; }
  // k 在直线左侧
  bool include(Point k) { return sign(cross(p[1] - p[0], k - p[0])) > 0; }
};

Point intersectLL(Line &a, Line &b) {
  return intersectLL(a[0], a[1], b[0], b[1]);
}

bool parallel(Line k1, Line k2) { return sign(cross(k1.dir(), k2.dir())) == 0; }
bool sameDir(Line k1, Line k2) {
  return parallel(k1, k2) && sign(dot(k1.dir(), k2.dir())) == 1;
}

bool operator<(Line k1, Line k2) {
  if (sameDir(k1, k2)) return k2.include(k1[0]);
  return cmpAngle(k1.dir(), k2.dir());
}
// k1 和 k2 的交点在 k3 的左侧
int checkpos(Line k1, Line k2, Line k3) {
  return k3.include(intersectLL(k1, k2));
}

vector<Line> halfPlaneIS(vector<Line> &L) {
  // 极角排序
  sort(L.begin(), L.end());
  deque<Line> q;
  for (int i = 0; i < L.size(); i++) {
    if (i && sameDir(L[i], L[i - 1])) continue;
    while (q.size() > 1 && !checkpos(q[q.size() - 2], q[q.size() - 1], L[i]))
      q.pop_back();
    while (q.size() > 1 && !checkpos(q[1], q[0], L[i])) q.pop_front();
    q.push_back(L[i]);
  }
  while (q.size() > 2 && !checkpos(q[q.size() - 2], q[q.size() - 1], q[0]))
    q.pop_back();
  while (q.size() > 2 && !checkpos(q[1], q[0], q[q.size() - 1])) q.pop_front();
  vector<Line> ans;
  for (int i = 0; i < q.size(); i++) ans.push_back(q[i]);
  return ans;
}
```