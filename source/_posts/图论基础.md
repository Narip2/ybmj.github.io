---
title: 图论基础
date: 2019-04-14 13:38:43
categories:
  - ACM
  - 图论
tags:
  - 图论
---

## 割点与割边

注意对每个割点或者割边来说，判定定理可能不止一次成立，所以不要边判定边输出。

### 割点

$dfn[u]:$ 代表进入 u 点的时间

$low[u]:$ 为 u 及其后代所能回到的最早的祖先的 dfn 值

判定割点有两种情况：

- 如果根有两个及以上的孩子，则根是割点
- 叶节点不是割点。非叶结点 u 若是割点，那么那么$low[v] >= dfn[u]$ (v 是 u 的孩子)

```cpp
vector<int> G[maxn];
int dfs_clock, dfn[maxn];
bool iscut[maxn];
int dfs(int u, int fa) {
    int lowu = dfn[u] = ++dfs_clock;
    int child = 0;
    for (auto &v : G[u]) {
        if (!dfn[v]) {
            child++;
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv);
            if (lowv >= dfn[u]) iscut[u] = true;
        } else if (dfn[v] < dfn[u] && v != fa)
            lowu = min(lowu, dfn[v]);
    }
    if (fa < 0 && child == 1) iscut[u] = false;  // root
    return lowu;
}
```

### 割边

当$low[v] > dfn[u]$时，(u,v)是桥

同时为了防止重边，需要记录(u,fa)的数量，若大于 1 说明有重边，则要设置 low[u] = pre[fa].

```cpp
vector<pii> G[maxn];  // first: 下一个点， second: 该边的编号
int dfs_clock, dfn[maxn];
bool iscut[N];  // N: 边数

int dfs(int u, int fa) {
    int lowu = dfn[u] = ++dfs_clock;
    // int father = 0;
    for (auto &V : G[u]) {
        int v = V.first;
        int id = V.second;  // 边的编号
        // if(v == fa) father++;
        if (!dfn[v]) {
            int lowv = dfs(v, u);
            lowu = min(lowv, lowu);
            if (lowv > dfn[u]) iscut[id] = true;
        } else if (dfn[v] < dfn[u] && v != fa)
            lowu = min(lowu, dfn[v]);
    }
    // if(father > 1) return dfn[fa];
    return lowu;
}

```

## 点双联通与边双联通

### 点双联通分量

对于一个连通图，如果任意两点至少存在两条点不重复路径，则称这个图为点双连通的。

```cpp
vector<int> G[maxn], bcc[maxn];
int bcc_cnt, dfs_clock;
int dfn[maxn], iscut[maxn], bccno[maxn];
stack<pii> stk;
int dfs(int u) {
    int lowu = dfn[u] = ++dfs_clock;
    int child = 0;
    for (auto &v : G[u]) {
        pii e = {u, v};
        if (!dfn[v]) {
            stk.push(e);
            child++;
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv);
            if (lowv >= dfn[u]) {  // u为割点
                iscut[u] = true;
                bcc_cnt++;
                bcc[bcc_cnt].clear();  //注意！bcc从1开始编号
                for (;;) {
                    pii x = stk.top();
                    stk.pop();
                    if (bccno[x.first] != bcc_cnt)
                        bcc[bcc_cnt].push_back(x.first), bcc[x.first] = bcc_cnt;
                    if (bccno[x.second] != bcc_cnt)
                        bcc[bcc_cnt].push_back(x.second),
                            bcc[x.second] = bcc_cnt;
                    if (x.first == u && x.second == v) break;
                }
            }
        } else if (dfn[v] < dfn[u] && v != fa) {
            stk.push(e);
            lowu = min(lowu, dfn[v]);
        }
    }
    if (fa < 0 && child == 1) iscut[u] = 0;
    return lowu;
}
//割顶的bccno无意义
void solve(int n) {
    //调用结束后stack保证为空，所以不用清空
    memset(iscut, 0, sizeof(iscut));
    memset(bccno, 0, sizeof(bccno));
    memset(dfn, 0, sizeof(dfn));
    dfs_clock = bcc_cnt = 0;
    for (int i = 0; i < n; i++)
        if (!dfn[i]) dfs(i, -1);
}
```

### 边双联通分量

对于一个连通图，如果任意两点至少存在两条边不重复路径，则称该图为边双连通的。

```cpp
vector<int> G[maxn];
int bcc_cnt, dfs_clock;
int dfn[maxn], bccno[maxn];
stack<int> stk;
int dfs(int u, int fa) {
    int lowu = dfn[u] = ++dfs_clock;
    stk.push(u);
    bool flag = false;  // 有重边
    for (auto &v : G[u]) {
        if (v == fa && !flag) {
            flag = true;
            continue;
        }
        if (!dfn[v]) {
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv);
        } else
            lowu = min(lowu, dfn[v]);
    }
    if (lowu == dfn[u]) {
        bcc_cnt++;  // 编号从1开始
        while (!stk.empty()) {
            int v = stk.top();
            bccno[v] = bcc_cnt;
            if (u == v) break;
        }
    }
}
```

## 强连通分量

若在一张有向图中，各个点互相可达，则称此图强连通。

最大强连通子图又称强连通分量。

实际问题中，强连通分量往往会被看成一个点来处理(缩点)。

```cpp
vector<int> G[maxn];
int scc, dfs_clock, top;  // scc: 强连通分量的数量
bool instack[maxn];
int dfn[maxn], low[maxn], belong[maxn], Stack[maxn];
// int num[maxn];      // 每个强连通分量的数量。 1 ~ scc
// int maps[maxn];      //缩点之后 每个点对应的新点的标号
void Tarjan(int u) {
    dfn[u] = low[u] = ++dfs_clock;
    instack[u] = true;
    Stack[top++] = u;
    for (auto &v : G[u]) {
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (instack[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++scc;
        int cnt = 0;
        int now;
        while (top > 0) {
            now = Stack[--top];
            instack[now] = false;
            belong[now] = u;
            ++cnt;
            if (now == u) {
                // num[scc] = cnt;
                // maps[u] = scc;
                break;
            }
        }
    }
}
void solve(int n) {
    memset(instack, 0, sizeof(instack));
    memset(dfn, 0, sizeof(dfn));
    scc = dfs_clock = top = 0;
    for (int i = 1; i <= n; i++) {  // 点的标号从1开始
        if (!dfn[i]) Tarjan(i);
    }
}
```
