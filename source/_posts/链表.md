---
title: 链表
date: 2019-09-01 23:13:53
categories:
- 数据结构
tags:
- 链表
---

```cpp
#include <bits/stdc++.h>
using namespace std;
using uint = unsigned int;

template <typename T>
struct listNode {
  T data;
  listNode<T>*succ, *pred;  // successor, predecessor
  
 public:
  listNode() { succ = nullptr, pred = nullptr; }
  listNode(T data, listNode<T>* s = nullptr, listNode<T>* p = nullptr)
      : data(data), succ(s), pred(p) {}

  listNode<T>* insertAsSucc(const T& rhs);  // 返回插入后的位置
  listNode<T>* insertAsPred(const T& rhs);
};

template <typename T>
listNode<T>* listNode<T>::insertAsSucc(const T& rhs) {  // 插到该节点的后继
  listNode<T>* it = new listNode<T>(rhs, succ, this);
  succ->pred = it;
  succ = it;
  return it;
}

template <typename T>
listNode<T>* listNode<T>::insertAsPred(const T& rhs) {  // 插到该节点的前驱
  listNode<T>* it = new listNode<T>(rhs, this, pred);
  pred->succ = it;
  pred = it;
  return it;
}

// --------------------------------------------------------------------------------------------------
template <typename T>
class linkList {
  listNode<T>*header, *trailer;  // 尾节点方便尾部插入和删除节点
  uint _size;

 public:
  linkList();
  ~linkList();

  T& operator[](uint p) const;  // const: 该函数不会修改数据成员

  listNode<T>* begin() { return header->succ; }
  listNode<T>* end() { return trailer; }

  listNode<T>* find(const T& data) const;
  listNode<T>* insertAsFirst(const T& data) {
    ++_size;
    return header->insertAsSucc(data);
  }
  listNode<T>* insertAsLast(const T& data) {
    ++_size;
    return trailer->insertAsPred(data);
  }
  T remove(listNode<T>* p);

  listNode<T>* search(listNode<T>* begin, listNode<T>* end,
                      const T& data) const;  // 找到第一个大于等于data的位置

  // 排序算法，左闭右开
  void insertionSort(listNode<T>* begin, listNode<T>* end);  // 插入排序
  void selectionSort(listNode<T>* begin, listNode<T>* end);  // 选择排序
  listNode<T>* mergeSort(listNode<T>* begin, listNode<T>* end,
                         int n = -1);  // 归并排序
};

template <typename T>
linkList<T>::linkList() {
  header = new listNode<T>;
  trailer = new listNode<T>;
  header->succ = trailer;
  trailer->pred = header;
  _size = 0;
}

// 如果不throw，可以设置成private
template <typename T>
T& linkList<T>::operator[](uint p) const {
  // if (p >= sz) throw;
  listNode<T>* now = header->succ;
  while (p--) now = now->succ;
  return now->data;
}

template <typename T>
listNode<T>* linkList<T>::find(const T& data) const {
  listNode<T>* it = header->nxt;
  while (it != trailer) {
    if (it->data == data)
      return it;
    else
      it = it->nxt;
  }
  return nullptr;
}

template <typename T>
T linkList<T>::remove(listNode<T>* p) {
  T tmp = p->data;
  p->pred->succ = p->succ;
  p->succ->pred = p->pred;
  delete p;
  --_size;
  return tmp;
}

template <typename T>
linkList<T>::~linkList() {
  listNode<T>* it = header;
  while (it != nullptr) {
    auto tmp = it->succ;
    delete it;
    it = tmp;
  }
  _size = 0;
}

template <typename T>
listNode<T>* linkList<T>::search(listNode<T>* begin, listNode<T>* end,
                                 const T& data) const {
  listNode<T>* it = begin;
  while (it != end) {
    if (it->data >= data) return it;
    it = it->succ;
  }
  return end;
}
template <typename T>
void linkList<T>::insertionSort(listNode<T>* begin, listNode<T>* end) {
  if (begin == end) return;
  listNode<T>* head = begin;
  listNode<T>* it = begin->succ;
  while (it != end) {
    listNode<T>* p =
        search(head, it, it->data);  // 找到第一个大于等于data的位置
    p->insertAsPred(it->data);       //  插入到它的前驱
    if (p == head) head = p->pred;
    listNode<T>* succ = it->succ;
    remove(it);
    it = succ;
  }
}

template <typename T>
void linkList<T>::selectionSort(listNode<T>* begin, listNode<T>* end) {
  if (begin == end) return;
  listNode<T>* it = begin;
  while (it != end) {
    listNode<T>*p = it->succ, *Min = it;
    while (p != end) {
      if (p->data < Min->data) Min = p;
      p = p->succ;
    }
    if (it == Min)
      it = it->succ;
    else
      it->insertAsPred(Min->data), remove(Min);
  }
}

template <typename T>
listNode<T>* linkList<T>::mergeSort(listNode<T>* begin, listNode<T>* end,
                                    int n) {  // 默认参数写在定义
  if (n == -1) {                              // 计算长度
    n = 0;
    listNode<T>* it = begin;
    while (it != end) ++n, it = it->succ;
  }
  if (begin == end || n < 2) return begin;

  int mid = n / 2;
  listNode<T>* midNode = begin;
  for (int i = 0; i < mid; i++) midNode = midNode->succ;
  begin = mergeSort(begin, midNode, mid);
  midNode = mergeSort(midNode, end, n - mid);
  //  因为有删除操作，因此merge后首节点可能会改变。所以函数要返回排序后的首节点。

  listNode<T>*l1 = begin, *l2 = midNode;

  // 注意判断条件， 因为有删除操作，所以不能判 l1 != minNode， 而要判 l1 != l2。
  while (l1 != l2 && l2 != end) {
    if (l1->data <= l2->data) {
      l1 = l1->succ;
    } else {
      l1->insertAsPred(l2->data);
      if (l1 == begin) begin = l1->pred;
      l2 = l2->succ;
      remove(l2->pred);
    }
  }
  return begin;
}

int main() {
  linkList<int> test;
  mt19937 rnd(time(0));
  int n = 10;
  for (int i = 0; i < n; i++) test.insertAsLast(rnd());
  for (int i = 0; i < n; i++) cout << test[i] << ' ';
  cout << endl;

  test.mergeSort(test.begin(), test.end());
  for (int i = 0; i < n; i++) cout << test[i] << ' ';
  cout << endl;

  test.selectionSort(test.begin(), test.end());
  for (int i = 0; i < n; i++) cout << test[i] << ' ';
  cout << endl;
}
```