---
title: hdu6677 度度熊与组题
date: 2019-08-19 23:44:04
categories:
- ACM
- 题目
tags:
- 动态规划
---

[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6677)

# 题意

给定 $2n$ 个数，平均分成两组，每组 $n$ 个数。将每组按从小到大排序，求使得 $\sum_{i=1}^{n} |a_i - b_i|$ 最小的方案数，答案模 $10^9+7$。

$ 1 \leq n \leq 10^5$

# 分析

设 $dp[v]$  表示值小于等于 $v$ 的数已经完成分组的方案数。

可以发现将小于等于 $v$ 的数分组后，两组大小之差的绝对值不会超过 $1$。

简单证明：

设 `o` 表示小于等于 $v$ 的数字， `x`表示大于 $v$ 的数字。

对于下面这种情况：
```
ooxxx
oooox
```
可以通过置换可以变为：
```
oooxx
oooxx
```

而显然后者答案更优。

设等于 $v$ 的数字有 $k$ 个，小于 $v$ 的数字有 $t$ 个。

- 如果 $k$ 为奇数，且 $t$ 为奇数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2}$
- 如果 $k$ 为奇数，且 $t$ 为偶数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2} \times 2$
- 如果 $k$ 为偶数，且 $t$ 为奇数，则转移为： $dp[v] = dp[v-1] \times (C_{k}^{k / 2} + C_{k}^{k / 2 + 1})$
- 如果 $k$ 为偶数，且 $t$ 为偶数，则转移为： $dp[v] = dp[v-1] \times C_{k}^{k / 2}$

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int mod = 1e9 + 7;
const int maxn = 2e5 + 5;
int a[maxn];
ll dp[maxn], f[maxn];

ll Pow(ll a, ll b) {
  ll ret = 1;
  while (b) {
    if (b & 1) ret = ret * a % mod;
    a = a * a % mod;
    b >>= 1;
  }
  return ret;
}
inline ll inv(ll x) { return Pow(x, mod - 2); }
ll C(ll n, ll m) {
  if (n < m) return 0;
  return f[n] * inv(f[m] * f[n - m] % mod) % mod;
}
int main() {
  f[0] = 1;
  for (int i = 1; i < maxn; i++) f[i] = f[i - 1] * i % mod;

  int T;
  scanf("%d", &T);
  while (T--) {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < 2 * n; i++) scanf("%d", a + i);
    int p = 0;
    dp[0] = 1;
    for (int i = 1; i <= 2 * n; i++) {
      int k = 0, t;
      while (p < 2 * n && a[p] <= i) {
        k++;
        p++;
      }
      t = p - k;
      if (t & 1) {
        if (p & 1) {
          dp[i] = dp[i - 1] * (C(k, k / 2) + C(k, k / 2 + 1)) % mod;
        } else {
          dp[i] = dp[i - 1] * C(k, k / 2) % mod;
        }
      } else {
        if (p & 1) {
          dp[i] = dp[i - 1] * C(k, k / 2) % mod * 2LL % mod;
        } else {
          dp[i] = dp[i - 1] * C(k, k / 2) % mod;
        }
      }
    }
    printf("%lld\n", dp[2 * n]);
  }
}
```