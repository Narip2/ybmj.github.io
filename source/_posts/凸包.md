---
title: 凸包
date: 2019-10-09 12:04:39
categories:
- ACM
- 计算几何
tags:
- 凸包
---

# 凸包

凸包具体的性质还没来得及好好研究，希望日后可以补上。

模板 from dls.

```cpp
struct Point {
  int x, y;
  bool operator<(const Point& a) const {
    if (x == a.x) return y < a.y;
    return x < a.x;
  }
};
Point operator-(Point a, Point b) { return Point{a.x - b.x, a.y - b.y}; }
int Cross(Point A, Point B) { return A.x * B.y - A.y * B.x; }
int Cross(Point A, Point B, Point C) { return Cross(B - A, C - A); }

vector<Point> ConvexHull(vector<Point> ps) {
  int n = ps.size(), k = 0;
  if (n <= 1) return ps;
  sort(ps.begin(), ps.end());
  vector<Point> ret(n * 2);
  for (int i = 0; i < n; ret[k++] = ps[i++])
    while (k > 1 && Cross(ret[k - 2], ret[k - 1], ps[i]) <= 0) --k;
  for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--])
    while (k > t && Cross(ret[k - 2], ret[k - 1], ps[i]) <= 0) --k;
  ret.resize(k - 1);
  return ret;
}

vector<Point> ConvexHullNonStrict(vector<Point> ps) {
  // caution: need to unique the ps first.
  int n = ps.size(), k = 0;
  if (n <= 1) return ps;
  sort(ps.begin(), ps.end());
  vector<Point> ret(n * 2);
  for (int i = 0; i < n; ret[k++] = ps[i++])
    while (k > 1 && Cross(ret[k - 2], ret[k - 1], ps[i]) < 0) --k;
  for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--])
    while (k > t && Cross(ret[k - 2], ret[k - 1], ps[i]) < 0) --k;
  ret.resize(k - 1);
  return ret;
}
```

# 旋转卡壳

基于凸包的一种算法，具体思想见下图。

![](https://ybmj-blog-1256173108.cos.ap-shanghai.myqcloud.com/blog-picture/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B31.jpg)



## 平面最远点对

[参考链接](https://www.cnblogs.com/cjyyb/p/7260913.html)

![](https://ybmj-blog-1256173108.cos.ap-shanghai.myqcloud.com/blog-picture/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B32.gif)


点对一定在凸包（严格）上。

枚举边，然后找到这条边距离最远的点（叉积最大），那么这个点和当前枚举边的端点就可能是答案。

例题：洛谷1452

```cpp
Point operator-(Point a, Point b) { return Point{a.x - b.x, a.y - b.y}; }
int Cross(Point A, Point B) { return A.x * B.y - A.y * B.x; }
int Cross(Point A, Point B, Point C) { return Cross(B - A, C - A); }
int sqr(int x) { return x * x; }
int dis(Point A, Point B) { return sqr(A.x - B.x) + sqr(A.y - B.y); }

int work(vector<Point> ps) {
  if (ps.size() <= 1) return 0;
  if (ps.size() == 2) return dis(ps[0], ps[1]);
  ps.push_back(ps[0]);
  int n = ps.size(), ret = 0;
  for (int i = 0, j = 2; i < n - 1; i++) {
    while (Cross(ps[i], ps[i + 1], ps[j]) <= Cross(ps[i], ps[i + 1], ps[j + 1]))
      (++j) %= (n - 1);
    ret = max({ret, dis(ps[i], ps[j]), dis(ps[i + 1], ps[j])});
  }
  return ret;
}
```

## 平面最大三角形

三个顶点一定在凸包（严格）上。但三角形的边不一定是凸包的边！

例题：hdu2202

```cpp
Point operator-(Point a, Point b) { return Point{a.x - b.x, a.y - b.y}; }
ll Cross(Point A, Point B) { return 1LL * A.x * B.y - 1LL * A.y * B.x; }
ll Cross(Point A, Point B, Point C) { return Cross(B - A, C - A); }
double area(Point A, Point B, Point C) { return Cross(A, B, C) * 0.5; }

double work(vector<Point> ps) {
  if (ps.size() <= 2) return 0;
  ps.push_back(ps[0]);
  int n = ps.size();
  double ret = 0;
  for (int i = 0; i < n - 1; i++) {
    int p = i;
    for (int j = i + 1; j < n - 1; j++) {
      while (abs(Cross(ps[i], ps[j], ps[p])) <=
             abs(Cross(ps[i], ps[j], ps[p + 1])))
        (++p) %= (n - 1);
      ret = max(ret, area(ps[i], ps[j], ps[p]));
    }
  }
  return ret;
}
```

## 最小矩形覆盖

[参考链接](https://blog.csdn.net/wzq_QwQ/article/details/48319923)

![](https://ybmj-blog-1256173108.cos.ap-shanghai.myqcloud.com/blog-picture/%E5%87%B8%E5%8C%85.jpg)

如图，最小矩形一定有一条边在凸包上。

设 $AB$ 是当前枚举的边，那么 $C$ 一定是点积最大的点，$D$ 一定是叉积最大的点，$E$ 一定是点积最小的点。然后就快乐旋转即可。

例题：洛谷3187。因为输出-0，调了好久。

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-12;
struct Point {
  double x, y;
  bool operator<(const Point& a) const {
    if (x == a.x) return y < a.y;
    return x < a.x;
  }
};
Point operator-(Point a, Point b) { return Point{a.x - b.x, a.y - b.y}; }
Point operator+(Point a, Point b) { return Point{a.x + b.x, a.y + b.y}; }
Point operator*(Point a, double b) { return Point{a.x * b, a.y * b}; }
double Cross(Point A, Point B) { return A.x * B.y - A.y * B.x; }
double Cross(Point A, Point B, Point C) { return Cross(B - A, C - A); }
double Dot(Point A, Point B) { return A.x * B.x + A.y * B.y; }
double Dot(Point A, Point B, Point C) { return Dot(B - A, C - A); }
double sqr(double x) { return x * x; }
double dis(Point A, Point B) { return sqrt(sqr(A.x - B.x) + sqr(A.y - B.y)); }

int dcmp(double x) {
  if (fabs(x) < eps)
    return 0;
  else
    return x > 0 ? 1 : -1;
}

vector<Point> ConvexHull(vector<Point> ps) {
  int n = ps.size(), k = 0;
  if (n <= 1) return ps;
  sort(ps.begin(), ps.end());
  vector<Point> ret(n * 2);
  for (int i = 0; i < n; ret[k++] = ps[i++])
    while (k > 1 && dcmp(Cross(ret[k - 2], ret[k - 1], ps[i])) <= 0) --k;
  for (int i = n - 2, t = k; ~i; ret[k++] = ps[i--])
    while (k > t && dcmp(Cross(ret[k - 2], ret[k - 1], ps[i])) <= 0) --k;
  ret.resize(k - 1);
  return ret;
}

vector<Point> work(vector<Point> ps) {
  ps.push_back(ps[0]);
  int n = ps.size();
  vector<Point> ret(4);
  double res = 1e18;

  for (int i = 0, j = 2, k = 2, t = 2; i < n - 1; i++) {
    while (dcmp(Dot(ps[i], ps[i + 1], ps[j]) -
                Dot(ps[i], ps[i + 1], ps[j + 1])) <= 0)
      (++j) %= (n - 1);
    while (dcmp(Cross(ps[i], ps[i + 1], ps[k]) -
                Cross(ps[i], ps[i + 1], ps[k + 1])) <= 0)
      (++k) %= (n - 1);
    while (dcmp(Dot(ps[i], ps[i + 1], ps[t]) -
                Dot(ps[i], ps[i + 1], ps[t + 1])) >= 0)
      (++t) %= (n - 1);

    double ab = dis(ps[i], ps[i + 1]);
    double hei = Cross(ps[i], ps[i + 1], ps[k]) / ab;
    double l = fabs(Dot(ps[i], ps[i + 1], ps[j])) / ab;
    double r = fabs(Dot(ps[i], ps[i + 1], ps[t])) / ab;
    double wide = l + r;
    if (hei * wide < res) {
      res = hei * wide;
      ret[0] = ps[i] + (ps[i + 1] - ps[i]) * (l / ab);
      ret[1] = ret[0] + (ps[j] - ret[0]) * (hei / dis(ret[0], ps[j]));
      ret[2] = ret[1] + (ps[k] - ret[1]) * (wide / dis(ret[1], ps[k]));
      ret[3] = ret[2] + (ps[t] - ret[2]) * (hei / dis(ret[2], ps[t]));
    }
  }
  if (dcmp(res) <= 0) res = 0;
  printf("%.5f\n", res);
  return ret;
}
int main() {
  int n;
  scanf("%d", &n);
  double x, y;
  vector<Point> ps;
  for (int i = 0; i < n; i++) {
    scanf("%lf%lf", &x, &y);
    ps.push_back({x, y});
  }
  auto ch = ConvexHull(ps);
  auto ans = work(ch);
  int k = 0;
  for (int i = 1; i < ans.size(); i++) {
    if (dcmp(ans[k].y - ans[i].y) == 0 && ans[k].x > ans[i].x)
      k = i;
    else if (ans[k].y > ans[i].y)
      k = i;
  }
  for (int i = 0; i < 4; i++) {
    if (dcmp(ans[(i + k) % 4].x) <= 0) ans[(i + k) % 4].x = 0;
    if (dcmp(ans[(i + k) % 4].y) <= 0) ans[(i + k) % 4].y = 0;
    printf("%.5f %.5f\n", ans[(i + k) % 4].x, ans[(i + k) % 4].y);
  }
}
```