---
title: bzoj4025 二分图
date: 2019-11-14 14:29:08
categories:
- ACM
- 题目
tags:
- 线段树分治
- 并查集
---

[题目链接](https://www.lydsy.com/JudgeOnline/problem.php?id=4025)

## 题意

$n$ 个节点的无向图，有 $m$ 条边，每条边都有一个出现时间和消失时间。要回答出每个时刻该图是否是二分图。

$n \leq 1e5, m \leq 2e5, T \leq 1e5$

## 分析

首先每个时刻有哪些边这个是可以通过线段树维护的，类似线段树分治的做法。

接下来就是遍历整颗线段树，进入某个节点的时候加边，退出某个节点的时候删边。

接下来考虑对于一个边集，如何知道其是否构成二分图，还要支持加边和删边的操作。

判断是否是二分图的标准是奇环是否存在。

考虑维护一棵生成树，如果加了一条边之后出现了偶环，那么应该删去环中最早应该删去的边（线段树上加边和删边的顺序正好满足这个性质）。

如果加了一条边之后出现了奇环，那么表示该节点所覆盖的时刻都不是二分图，这里可以剪枝。

最后回溯的时候把之前加的边删掉。

用可撤销并查集就可以做到。维护每个点到根的距离的奇偶性，需要注意的是并查集的形态和实际树的形态是不同的：比如连接 $u,v$ 两条边，假设他们的根是 $x,y$。那么 $dis(x,y)$ 的距离应该是 $dis(u,x) ^ dis(v,y) ^ 1$，而不是 $1$。


## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define lson (rt << 1)
#define rson (rt << 1 | 1)
#define Lson l, m, lson
#define Rson m + 1, r, rson
typedef pair<int, int> pii;
const int maxn = 1e5 + 5;
vector<pii> seg[maxn << 2];

struct UFS {
  int par[maxn], h[maxn], top;
  bool dis[maxn];
  struct Node {
    int x, y, fa, h;
    bool dis;
    Node(int x = 0, int y = 0, int fa = 0, int h = 0, bool dis = 0)
        : x(x), y(y), fa(fa), h(h), dis(dis) {}
  } stk[maxn];

  void init(int n) {
    top = 0;
    for (int i = 1; i <= n; i++) par[i] = i, h[i] = 1, dis[i] = 0;
  }
  int find(int x) { return x == par[x] ? x : find(par[x]); }
  int dist(int x) { return x == par[x] ? dis[x] : dist(par[x]) ^ dis[x]; }
  void merge(int u, int v) {
    int x = find(u), y = find(v);
    if (h[x] > h[y]) swap(x, y);
    stk[top++] = Node(x, y, par[x], h[y], dis[x]);
    if (h[x] == h[y]) h[y]++;
    par[x] = y;
    dis[x] = dist(u) ^ dist(v) ^ 1;
  }
  void undo(int k) {
    for (int i = 0; i < k; i++) {
      Node it = stk[--top];
      par[it.x] = it.fa;
      h[it.y] = it.h;
      dis[it.x] = it.dis;
    }
  }
} ufs;

bool ans[maxn];

void update(int l, int r, int rt, int L, int R, int u, int v) {
  if (L <= l && R >= r) {
    seg[rt].push_back(make_pair(u, v));
    return;
  }
  int m = l + r >> 1;
  if (L <= m) update(Lson, L, R, u, v);
  if (m + 1 <= R) update(Rson, L, R, u, v);
}

void dfs(int l, int r, int rt) {
  int cnt = 0, flag = 1;
  for (int i = 0; i < seg[rt].size(); i++) {
    pii e = seg[rt][i];
    int x = ufs.find(e.first), y = ufs.find(e.second);
    if (x == y && !(ufs.dist(e.first) ^ ufs.dist(e.second))) {
      flag = 0;
      break;
    } else if (x != y) {
      cnt++;
      ufs.merge(e.first, e.second);
    }
  }
  if (flag) {
    if (l == r)
      ans[l] = true;
    else {
      int m = l + r >> 1;
      dfs(Lson);
      dfs(Rson);
    }
  }
  ufs.undo(cnt);
}

int main() {
  int n, m, T;
  scanf("%d%d%d", &n, &m, &T);
  for (int i = 0, u, v, s, t; i < m; i++) {
    scanf("%d%d%d%d", &u, &v, &s, &t);
    if (s < t) update(0, T, 1, s, t - 1, u, v);
  }
  ufs.init(n);
  dfs(0, T, 1);
  for (int i = 0; i < T; i++)
    if (ans[i])
      puts("Yes");
    else
      puts("No");
}
```
